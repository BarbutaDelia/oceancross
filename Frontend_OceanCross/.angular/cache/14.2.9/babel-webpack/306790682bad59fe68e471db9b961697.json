{"ast":null,"code":"\"use strict\";\n\nconst {\n  validate\n} = require(\"schema-utils\");\n\nconst mime = require(\"mime-types\");\n\nconst middleware = require(\"./middleware\");\n\nconst getFilenameFromUrl = require(\"./utils/getFilenameFromUrl\");\n\nconst setupHooks = require(\"./utils/setupHooks\");\n\nconst setupWriteToDisk = require(\"./utils/setupWriteToDisk\");\n\nconst setupOutputFileSystem = require(\"./utils/setupOutputFileSystem\");\n\nconst ready = require(\"./utils/ready\");\n\nconst schema = require(\"./options.json\");\n\nconst noop = () => {};\n/** @typedef {import(\"schema-utils/declarations/validate\").Schema} Schema */\n\n/** @typedef {import(\"webpack\").Compiler} Compiler */\n\n/** @typedef {import(\"webpack\").MultiCompiler} MultiCompiler */\n\n/** @typedef {import(\"webpack\").Configuration} Configuration */\n\n/** @typedef {import(\"webpack\").Stats} Stats */\n\n/** @typedef {import(\"webpack\").MultiStats} MultiStats */\n\n/**\n * @typedef {Object} ExtendedServerResponse\n * @property {{ webpack?: { devMiddleware?: Context<IncomingMessage, ServerResponse> } }} [locals]\n */\n\n/** @typedef {import(\"http\").IncomingMessage} IncomingMessage */\n\n/** @typedef {import(\"http\").ServerResponse & ExtendedServerResponse} ServerResponse */\n\n/**\n * @callback NextFunction\n * @param {any} [err]\n * @return {void}\n */\n\n/**\n * @typedef {NonNullable<Configuration[\"watchOptions\"]>} WatchOptions\n */\n\n/**\n * @typedef {Compiler[\"watching\"]} Watching\n */\n\n/**\n * @typedef {ReturnType<Compiler[\"watch\"]>} MultiWatching\n */\n\n/**\n * @typedef {Compiler[\"outputFileSystem\"] & { createReadStream?: import(\"fs\").createReadStream, statSync?: import(\"fs\").statSync, lstat?: import(\"fs\").lstat, readFileSync?: import(\"fs\").readFileSync }} OutputFileSystem\n */\n\n/** @typedef {ReturnType<Compiler[\"getInfrastructureLogger\"]>} Logger */\n\n/**\n * @callback Callback\n * @param {Stats | MultiStats} [stats]\n */\n\n/**\n * @template {IncomingMessage} Request\n * @template {ServerResponse} Response\n * @typedef {Object} Context\n * @property {boolean} state\n * @property {Stats | MultiStats | undefined} stats\n * @property {Callback[]} callbacks\n * @property {Options<Request, Response>} options\n * @property {Compiler | MultiCompiler} compiler\n * @property {Watching | MultiWatching} watching\n * @property {Logger} logger\n * @property {OutputFileSystem} outputFileSystem\n */\n\n/**\n * @template {IncomingMessage} Request\n * @template {ServerResponse} Response\n * @typedef {Record<string, string | number> | Array<{ key: string, value: number | string }> | ((req: Request, res: Response, context: Context<Request, Response>) =>  void | undefined | Record<string, string | number>) | undefined} Headers\n */\n\n/**\n * @template {IncomingMessage} Request\n * @template {ServerResponse} Response\n * @typedef {Object} Options\n * @property {{[key: string]: string}} [mimeTypes]\n * @property {boolean | ((targetPath: string) => boolean)} [writeToDisk]\n * @property {string} [methods]\n * @property {Headers<Request, Response>} [headers]\n * @property {NonNullable<Configuration[\"output\"]>[\"publicPath\"]} [publicPath]\n * @property {Configuration[\"stats\"]} [stats]\n * @property {boolean} [serverSideRender]\n * @property {OutputFileSystem} [outputFileSystem]\n * @property {boolean | string} [index]\n */\n\n/**\n * @template {IncomingMessage} Request\n * @template {ServerResponse} Response\n * @callback Middleware\n * @param {Request} req\n * @param {Response} res\n * @param {NextFunction} next\n * @return {Promise<void>}\n */\n\n/**\n * @callback GetFilenameFromUrl\n * @param {string} url\n * @returns {string | undefined}\n */\n\n/**\n * @callback WaitUntilValid\n * @param {Callback} callback\n */\n\n/**\n * @callback Invalidate\n * @param {Callback} callback\n */\n\n/**\n * @callback Close\n * @param {(err: Error | null | undefined) => void} callback\n */\n\n/**\n * @template {IncomingMessage} Request\n * @template {ServerResponse} Response\n * @typedef {Object} AdditionalMethods\n * @property {GetFilenameFromUrl} getFilenameFromUrl\n * @property {WaitUntilValid} waitUntilValid\n * @property {Invalidate} invalidate\n * @property {Close} close\n * @property {Context<Request, Response>} context\n */\n\n/**\n * @template {IncomingMessage} Request\n * @template {ServerResponse} Response\n * @typedef {Middleware<Request, Response> & AdditionalMethods<Request, Response>} API\n */\n\n/**\n * @template {IncomingMessage} Request\n * @template {ServerResponse} Response\n * @param {Compiler | MultiCompiler} compiler\n * @param {Options<Request, Response>} [options]\n * @returns {API<Request, Response>}\n */\n\n\nfunction wdm(compiler, options = {}) {\n  validate(\n  /** @type {Schema} */\n  schema, options, {\n    name: \"Dev Middleware\",\n    baseDataPath: \"options\"\n  });\n  const {\n    mimeTypes\n  } = options;\n\n  if (mimeTypes) {\n    const {\n      types\n    } = mime; // mimeTypes from user provided options should take priority\n    // over existing, known types\n    // @ts-ignore\n\n    mime.types = { ...types,\n      ...mimeTypes\n    };\n  }\n  /**\n   * @type {Context<Request, Response>}\n   */\n\n\n  const context = {\n    state: false,\n    // eslint-disable-next-line no-undefined\n    stats: undefined,\n    callbacks: [],\n    options,\n    compiler,\n    // @ts-ignore\n    // eslint-disable-next-line no-undefined\n    watching: undefined,\n    logger: compiler.getInfrastructureLogger(\"webpack-dev-middleware\"),\n    // @ts-ignore\n    // eslint-disable-next-line no-undefined\n    outputFileSystem: undefined\n  };\n  setupHooks(context);\n\n  if (options.writeToDisk) {\n    setupWriteToDisk(context);\n  }\n\n  setupOutputFileSystem(context); // Start watching\n\n  if (\n  /** @type {Compiler} */\n  context.compiler.watching) {\n    context.watching =\n    /** @type {Compiler} */\n    context.compiler.watching;\n  } else {\n    /**\n     * @type {WatchOptions | WatchOptions[]}\n     */\n    let watchOptions;\n    /**\n     * @param {Error | null | undefined} error\n     */\n\n    const errorHandler = error => {\n      if (error) {\n        // TODO: improve that in future\n        // For example - `writeToDisk` can throw an error and right now it is ends watching.\n        // We can improve that and keep watching active, but it is require API on webpack side.\n        // Let's implement that in webpack@5 because it is rare case.\n        context.logger.error(error);\n      }\n    };\n\n    if (Array.isArray(\n    /** @type {MultiCompiler} */\n    context.compiler.compilers)) {\n      watchOptions =\n      /** @type {MultiCompiler} */\n      context.compiler.compilers.map(\n      /**\n       * @param {Compiler} childCompiler\n       * @returns {WatchOptions}\n       */\n      childCompiler => childCompiler.options.watchOptions || {});\n      context.watching =\n      /** @type {MultiWatching} */\n      context.compiler.watch(\n      /** @type {WatchOptions}} */\n      watchOptions, errorHandler);\n    } else {\n      watchOptions =\n      /** @type {Compiler} */\n      context.compiler.options.watchOptions || {};\n      context.watching =\n      /** @type {Watching} */\n      context.compiler.watch(watchOptions, errorHandler);\n    }\n  }\n\n  const instance =\n  /** @type {API<Request, Response>} */\n  middleware(context); // API\n\n  /** @type {API<Request, Response>} */\n\n  instance.getFilenameFromUrl =\n  /**\n   * @param {string} url\n   * @returns {string|undefined}\n   */\n  url => getFilenameFromUrl(context, url);\n  /** @type {API<Request, Response>} */\n\n\n  instance.waitUntilValid = (callback = noop) => {\n    ready(context, callback);\n  };\n  /** @type {API<Request, Response>} */\n\n\n  instance.invalidate = (callback = noop) => {\n    ready(context, callback);\n    context.watching.invalidate();\n  };\n  /** @type {API<Request, Response>} */\n\n\n  instance.close = (callback = noop) => {\n    context.watching.close(callback);\n  };\n  /** @type {API<Request, Response>} */\n\n\n  instance.context = context;\n  return instance;\n}\n\nmodule.exports = wdm;","map":{"version":3,"names":["validate","require","mime","middleware","getFilenameFromUrl","setupHooks","setupWriteToDisk","setupOutputFileSystem","ready","schema","noop","wdm","compiler","options","name","baseDataPath","mimeTypes","types","context","state","stats","undefined","callbacks","watching","logger","getInfrastructureLogger","outputFileSystem","writeToDisk","watchOptions","errorHandler","error","Array","isArray","compilers","map","childCompiler","watch","instance","url","waitUntilValid","callback","invalidate","close","module","exports"],"sources":["/Users/deliabarbuta/Documents/An4Sem1/PAW/Proiect/proiect-paw-tadam/Frontend_OceanCross/node_modules/webpack-dev-middleware/dist/index.js"],"sourcesContent":["\"use strict\";\n\nconst {\n  validate\n} = require(\"schema-utils\");\n\nconst mime = require(\"mime-types\");\n\nconst middleware = require(\"./middleware\");\n\nconst getFilenameFromUrl = require(\"./utils/getFilenameFromUrl\");\n\nconst setupHooks = require(\"./utils/setupHooks\");\n\nconst setupWriteToDisk = require(\"./utils/setupWriteToDisk\");\n\nconst setupOutputFileSystem = require(\"./utils/setupOutputFileSystem\");\n\nconst ready = require(\"./utils/ready\");\n\nconst schema = require(\"./options.json\");\n\nconst noop = () => {};\n/** @typedef {import(\"schema-utils/declarations/validate\").Schema} Schema */\n\n/** @typedef {import(\"webpack\").Compiler} Compiler */\n\n/** @typedef {import(\"webpack\").MultiCompiler} MultiCompiler */\n\n/** @typedef {import(\"webpack\").Configuration} Configuration */\n\n/** @typedef {import(\"webpack\").Stats} Stats */\n\n/** @typedef {import(\"webpack\").MultiStats} MultiStats */\n\n/**\n * @typedef {Object} ExtendedServerResponse\n * @property {{ webpack?: { devMiddleware?: Context<IncomingMessage, ServerResponse> } }} [locals]\n */\n\n/** @typedef {import(\"http\").IncomingMessage} IncomingMessage */\n\n/** @typedef {import(\"http\").ServerResponse & ExtendedServerResponse} ServerResponse */\n\n/**\n * @callback NextFunction\n * @param {any} [err]\n * @return {void}\n */\n\n/**\n * @typedef {NonNullable<Configuration[\"watchOptions\"]>} WatchOptions\n */\n\n/**\n * @typedef {Compiler[\"watching\"]} Watching\n */\n\n/**\n * @typedef {ReturnType<Compiler[\"watch\"]>} MultiWatching\n */\n\n/**\n * @typedef {Compiler[\"outputFileSystem\"] & { createReadStream?: import(\"fs\").createReadStream, statSync?: import(\"fs\").statSync, lstat?: import(\"fs\").lstat, readFileSync?: import(\"fs\").readFileSync }} OutputFileSystem\n */\n\n/** @typedef {ReturnType<Compiler[\"getInfrastructureLogger\"]>} Logger */\n\n/**\n * @callback Callback\n * @param {Stats | MultiStats} [stats]\n */\n\n/**\n * @template {IncomingMessage} Request\n * @template {ServerResponse} Response\n * @typedef {Object} Context\n * @property {boolean} state\n * @property {Stats | MultiStats | undefined} stats\n * @property {Callback[]} callbacks\n * @property {Options<Request, Response>} options\n * @property {Compiler | MultiCompiler} compiler\n * @property {Watching | MultiWatching} watching\n * @property {Logger} logger\n * @property {OutputFileSystem} outputFileSystem\n */\n\n/**\n * @template {IncomingMessage} Request\n * @template {ServerResponse} Response\n * @typedef {Record<string, string | number> | Array<{ key: string, value: number | string }> | ((req: Request, res: Response, context: Context<Request, Response>) =>  void | undefined | Record<string, string | number>) | undefined} Headers\n */\n\n/**\n * @template {IncomingMessage} Request\n * @template {ServerResponse} Response\n * @typedef {Object} Options\n * @property {{[key: string]: string}} [mimeTypes]\n * @property {boolean | ((targetPath: string) => boolean)} [writeToDisk]\n * @property {string} [methods]\n * @property {Headers<Request, Response>} [headers]\n * @property {NonNullable<Configuration[\"output\"]>[\"publicPath\"]} [publicPath]\n * @property {Configuration[\"stats\"]} [stats]\n * @property {boolean} [serverSideRender]\n * @property {OutputFileSystem} [outputFileSystem]\n * @property {boolean | string} [index]\n */\n\n/**\n * @template {IncomingMessage} Request\n * @template {ServerResponse} Response\n * @callback Middleware\n * @param {Request} req\n * @param {Response} res\n * @param {NextFunction} next\n * @return {Promise<void>}\n */\n\n/**\n * @callback GetFilenameFromUrl\n * @param {string} url\n * @returns {string | undefined}\n */\n\n/**\n * @callback WaitUntilValid\n * @param {Callback} callback\n */\n\n/**\n * @callback Invalidate\n * @param {Callback} callback\n */\n\n/**\n * @callback Close\n * @param {(err: Error | null | undefined) => void} callback\n */\n\n/**\n * @template {IncomingMessage} Request\n * @template {ServerResponse} Response\n * @typedef {Object} AdditionalMethods\n * @property {GetFilenameFromUrl} getFilenameFromUrl\n * @property {WaitUntilValid} waitUntilValid\n * @property {Invalidate} invalidate\n * @property {Close} close\n * @property {Context<Request, Response>} context\n */\n\n/**\n * @template {IncomingMessage} Request\n * @template {ServerResponse} Response\n * @typedef {Middleware<Request, Response> & AdditionalMethods<Request, Response>} API\n */\n\n/**\n * @template {IncomingMessage} Request\n * @template {ServerResponse} Response\n * @param {Compiler | MultiCompiler} compiler\n * @param {Options<Request, Response>} [options]\n * @returns {API<Request, Response>}\n */\n\n\nfunction wdm(compiler, options = {}) {\n  validate(\n  /** @type {Schema} */\n  schema, options, {\n    name: \"Dev Middleware\",\n    baseDataPath: \"options\"\n  });\n  const {\n    mimeTypes\n  } = options;\n\n  if (mimeTypes) {\n    const {\n      types\n    } = mime; // mimeTypes from user provided options should take priority\n    // over existing, known types\n    // @ts-ignore\n\n    mime.types = { ...types,\n      ...mimeTypes\n    };\n  }\n  /**\n   * @type {Context<Request, Response>}\n   */\n\n\n  const context = {\n    state: false,\n    // eslint-disable-next-line no-undefined\n    stats: undefined,\n    callbacks: [],\n    options,\n    compiler,\n    // @ts-ignore\n    // eslint-disable-next-line no-undefined\n    watching: undefined,\n    logger: compiler.getInfrastructureLogger(\"webpack-dev-middleware\"),\n    // @ts-ignore\n    // eslint-disable-next-line no-undefined\n    outputFileSystem: undefined\n  };\n  setupHooks(context);\n\n  if (options.writeToDisk) {\n    setupWriteToDisk(context);\n  }\n\n  setupOutputFileSystem(context); // Start watching\n\n  if (\n  /** @type {Compiler} */\n  context.compiler.watching) {\n    context.watching =\n    /** @type {Compiler} */\n    context.compiler.watching;\n  } else {\n    /**\n     * @type {WatchOptions | WatchOptions[]}\n     */\n    let watchOptions;\n    /**\n     * @param {Error | null | undefined} error\n     */\n\n    const errorHandler = error => {\n      if (error) {\n        // TODO: improve that in future\n        // For example - `writeToDisk` can throw an error and right now it is ends watching.\n        // We can improve that and keep watching active, but it is require API on webpack side.\n        // Let's implement that in webpack@5 because it is rare case.\n        context.logger.error(error);\n      }\n    };\n\n    if (Array.isArray(\n    /** @type {MultiCompiler} */\n    context.compiler.compilers)) {\n      watchOptions =\n      /** @type {MultiCompiler} */\n      context.compiler.compilers.map(\n      /**\n       * @param {Compiler} childCompiler\n       * @returns {WatchOptions}\n       */\n      childCompiler => childCompiler.options.watchOptions || {});\n      context.watching =\n      /** @type {MultiWatching} */\n      context.compiler.watch(\n      /** @type {WatchOptions}} */\n      watchOptions, errorHandler);\n    } else {\n      watchOptions =\n      /** @type {Compiler} */\n      context.compiler.options.watchOptions || {};\n      context.watching =\n      /** @type {Watching} */\n      context.compiler.watch(watchOptions, errorHandler);\n    }\n  }\n\n  const instance =\n  /** @type {API<Request, Response>} */\n  middleware(context); // API\n\n  /** @type {API<Request, Response>} */\n\n  instance.getFilenameFromUrl =\n  /**\n   * @param {string} url\n   * @returns {string|undefined}\n   */\n  url => getFilenameFromUrl(context, url);\n  /** @type {API<Request, Response>} */\n\n\n  instance.waitUntilValid = (callback = noop) => {\n    ready(context, callback);\n  };\n  /** @type {API<Request, Response>} */\n\n\n  instance.invalidate = (callback = noop) => {\n    ready(context, callback);\n    context.watching.invalidate();\n  };\n  /** @type {API<Request, Response>} */\n\n\n  instance.close = (callback = noop) => {\n    context.watching.close(callback);\n  };\n  /** @type {API<Request, Response>} */\n\n\n  instance.context = context;\n  return instance;\n}\n\nmodule.exports = wdm;"],"mappings":"AAAA;;AAEA,MAAM;EACJA;AADI,IAEFC,OAAO,CAAC,cAAD,CAFX;;AAIA,MAAMC,IAAI,GAAGD,OAAO,CAAC,YAAD,CAApB;;AAEA,MAAME,UAAU,GAAGF,OAAO,CAAC,cAAD,CAA1B;;AAEA,MAAMG,kBAAkB,GAAGH,OAAO,CAAC,4BAAD,CAAlC;;AAEA,MAAMI,UAAU,GAAGJ,OAAO,CAAC,oBAAD,CAA1B;;AAEA,MAAMK,gBAAgB,GAAGL,OAAO,CAAC,0BAAD,CAAhC;;AAEA,MAAMM,qBAAqB,GAAGN,OAAO,CAAC,+BAAD,CAArC;;AAEA,MAAMO,KAAK,GAAGP,OAAO,CAAC,eAAD,CAArB;;AAEA,MAAMQ,MAAM,GAAGR,OAAO,CAAC,gBAAD,CAAtB;;AAEA,MAAMS,IAAI,GAAG,MAAM,CAAE,CAArB;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,SAASC,GAAT,CAAaC,QAAb,EAAuBC,OAAO,GAAG,EAAjC,EAAqC;EACnCb,QAAQ;EACR;EACAS,MAFQ,EAEAI,OAFA,EAES;IACfC,IAAI,EAAE,gBADS;IAEfC,YAAY,EAAE;EAFC,CAFT,CAAR;EAMA,MAAM;IACJC;EADI,IAEFH,OAFJ;;EAIA,IAAIG,SAAJ,EAAe;IACb,MAAM;MACJC;IADI,IAEFf,IAFJ,CADa,CAGH;IACV;IACA;;IAEAA,IAAI,CAACe,KAAL,GAAa,EAAE,GAAGA,KAAL;MACX,GAAGD;IADQ,CAAb;EAGD;EACD;AACF;AACA;;;EAGE,MAAME,OAAO,GAAG;IACdC,KAAK,EAAE,KADO;IAEd;IACAC,KAAK,EAAEC,SAHO;IAIdC,SAAS,EAAE,EAJG;IAKdT,OALc;IAMdD,QANc;IAOd;IACA;IACAW,QAAQ,EAAEF,SATI;IAUdG,MAAM,EAAEZ,QAAQ,CAACa,uBAAT,CAAiC,wBAAjC,CAVM;IAWd;IACA;IACAC,gBAAgB,EAAEL;EAbJ,CAAhB;EAeAhB,UAAU,CAACa,OAAD,CAAV;;EAEA,IAAIL,OAAO,CAACc,WAAZ,EAAyB;IACvBrB,gBAAgB,CAACY,OAAD,CAAhB;EACD;;EAEDX,qBAAqB,CAACW,OAAD,CAArB,CAhDmC,CAgDH;;EAEhC;EACA;EACAA,OAAO,CAACN,QAAR,CAAiBW,QAFjB,EAE2B;IACzBL,OAAO,CAACK,QAAR;IACA;IACAL,OAAO,CAACN,QAAR,CAAiBW,QAFjB;EAGD,CAND,MAMO;IACL;AACJ;AACA;IACI,IAAIK,YAAJ;IACA;AACJ;AACA;;IAEI,MAAMC,YAAY,GAAGC,KAAK,IAAI;MAC5B,IAAIA,KAAJ,EAAW;QACT;QACA;QACA;QACA;QACAZ,OAAO,CAACM,MAAR,CAAeM,KAAf,CAAqBA,KAArB;MACD;IACF,CARD;;IAUA,IAAIC,KAAK,CAACC,OAAN;IACJ;IACAd,OAAO,CAACN,QAAR,CAAiBqB,SAFb,CAAJ,EAE6B;MAC3BL,YAAY;MACZ;MACAV,OAAO,CAACN,QAAR,CAAiBqB,SAAjB,CAA2BC,GAA3B;MACA;AACN;AACA;AACA;MACMC,aAAa,IAAIA,aAAa,CAACtB,OAAd,CAAsBe,YAAtB,IAAsC,EALvD,CAFA;MAQAV,OAAO,CAACK,QAAR;MACA;MACAL,OAAO,CAACN,QAAR,CAAiBwB,KAAjB;MACA;MACAR,YAFA,EAEcC,YAFd,CAFA;IAKD,CAhBD,MAgBO;MACLD,YAAY;MACZ;MACAV,OAAO,CAACN,QAAR,CAAiBC,OAAjB,CAAyBe,YAAzB,IAAyC,EAFzC;MAGAV,OAAO,CAACK,QAAR;MACA;MACAL,OAAO,CAACN,QAAR,CAAiBwB,KAAjB,CAAuBR,YAAvB,EAAqCC,YAArC,CAFA;IAGD;EACF;;EAED,MAAMQ,QAAQ;EACd;EACAlC,UAAU,CAACe,OAAD,CAFV,CArGmC,CAuGd;;EAErB;;EAEAmB,QAAQ,CAACjC,kBAAT;EACA;AACF;AACA;AACA;EACEkC,GAAG,IAAIlC,kBAAkB,CAACc,OAAD,EAAUoB,GAAV,CALzB;EAMA;;;EAGAD,QAAQ,CAACE,cAAT,GAA0B,CAACC,QAAQ,GAAG9B,IAAZ,KAAqB;IAC7CF,KAAK,CAACU,OAAD,EAAUsB,QAAV,CAAL;EACD,CAFD;EAGA;;;EAGAH,QAAQ,CAACI,UAAT,GAAsB,CAACD,QAAQ,GAAG9B,IAAZ,KAAqB;IACzCF,KAAK,CAACU,OAAD,EAAUsB,QAAV,CAAL;IACAtB,OAAO,CAACK,QAAR,CAAiBkB,UAAjB;EACD,CAHD;EAIA;;;EAGAJ,QAAQ,CAACK,KAAT,GAAiB,CAACF,QAAQ,GAAG9B,IAAZ,KAAqB;IACpCQ,OAAO,CAACK,QAAR,CAAiBmB,KAAjB,CAAuBF,QAAvB;EACD,CAFD;EAGA;;;EAGAH,QAAQ,CAACnB,OAAT,GAAmBA,OAAnB;EACA,OAAOmB,QAAP;AACD;;AAEDM,MAAM,CAACC,OAAP,GAAiBjC,GAAjB"},"metadata":{},"sourceType":"script"}