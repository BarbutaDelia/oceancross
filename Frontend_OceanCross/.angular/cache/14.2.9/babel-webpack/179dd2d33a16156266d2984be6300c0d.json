{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BuilderWatchPlugin = void 0;\n\nclass TimeInfoMap extends Map {\n  update(path, timestamp) {\n    this.set(path, Object.freeze({\n      safeTime: timestamp,\n      timestamp\n    }));\n  }\n\n  toTimestamps() {\n    const timestamps = new Map();\n\n    for (const [file, entry] of this) {\n      timestamps.set(file, entry.timestamp);\n    }\n\n    return timestamps;\n  }\n\n}\n\nclass BuilderWatchFileSystem {\n  constructor(watcherFactory, inputFileSystem) {\n    this.watcherFactory = watcherFactory;\n    this.inputFileSystem = inputFileSystem;\n  }\n\n  watch(files, directories, missing, startTime, _options, callback, callbackUndelayed) {\n    const watchedFiles = new Set(files);\n    const watchedDirectories = new Set(directories);\n    const watchedMissing = new Set(missing);\n    const timeInfo = new TimeInfoMap();\n\n    for (const file of files) {\n      timeInfo.update(file, startTime);\n    }\n\n    for (const directory of directories) {\n      timeInfo.update(directory, startTime);\n    }\n\n    const watcher = this.watcherFactory.watch(files, directories, events => {\n      if (events.length === 0) {\n        return;\n      }\n\n      if (callbackUndelayed) {\n        process.nextTick(() => {\n          var _a;\n\n          return callbackUndelayed(events[0].path, (_a = events[0].time) !== null && _a !== void 0 ? _a : Date.now());\n        });\n      }\n\n      process.nextTick(() => {\n        var _a, _b, _c;\n\n        const removals = new Set();\n        const fileChanges = new Set();\n        const directoryChanges = new Set();\n        const missingChanges = new Set();\n\n        for (const event of events) {\n          (_b = (_a = this.inputFileSystem).purge) === null || _b === void 0 ? void 0 : _b.call(_a, event.path);\n\n          if (event.type === 'deleted') {\n            timeInfo.delete(event.path);\n            removals.add(event.path);\n          } else {\n            timeInfo.update(event.path, (_c = event.time) !== null && _c !== void 0 ? _c : Date.now());\n\n            if (watchedFiles.has(event.path)) {\n              fileChanges.add(event.path);\n            } else if (watchedDirectories.has(event.path)) {\n              directoryChanges.add(event.path);\n            } else if (watchedMissing.has(event.path)) {\n              missingChanges.add(event.path);\n            }\n          }\n        }\n\n        const timeInfoMap = new Map(timeInfo);\n        callback(undefined, timeInfoMap, timeInfoMap, new Set([...fileChanges, ...directoryChanges, ...missingChanges]), removals);\n      });\n    });\n    return {\n      close() {\n        watcher.close();\n      },\n\n      pause() {},\n\n      getFileTimeInfoEntries() {\n        return new Map(timeInfo);\n      },\n\n      getContextTimeInfoEntries() {\n        return new Map(timeInfo);\n      }\n\n    };\n  }\n\n}\n\nclass BuilderWatchPlugin {\n  constructor(watcherFactory) {\n    this.watcherFactory = watcherFactory;\n  }\n\n  apply(compiler) {\n    compiler.hooks.environment.tap('BuilderWatchPlugin', () => {\n      compiler.watchFileSystem = new BuilderWatchFileSystem(this.watcherFactory, compiler.inputFileSystem);\n    });\n  }\n\n}\n\nexports.BuilderWatchPlugin = BuilderWatchPlugin;","map":{"version":3,"names":["Object","defineProperty","exports","value","BuilderWatchPlugin","TimeInfoMap","Map","update","path","timestamp","set","freeze","safeTime","toTimestamps","timestamps","file","entry","BuilderWatchFileSystem","constructor","watcherFactory","inputFileSystem","watch","files","directories","missing","startTime","_options","callback","callbackUndelayed","watchedFiles","Set","watchedDirectories","watchedMissing","timeInfo","directory","watcher","events","length","process","nextTick","_a","time","Date","now","_b","_c","removals","fileChanges","directoryChanges","missingChanges","event","purge","call","type","delete","add","has","timeInfoMap","undefined","close","pause","getFileTimeInfoEntries","getContextTimeInfoEntries","apply","compiler","hooks","environment","tap","watchFileSystem"],"sources":["/Users/deliabarbuta/Documents/An4Sem1/PAW/Proiect/proiect-paw-tadam/Frontend_OceanCross/node_modules/@angular-devkit/build-angular/src/webpack/plugins/builder-watch-plugin.js"],"sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BuilderWatchPlugin = void 0;\nclass TimeInfoMap extends Map {\n    update(path, timestamp) {\n        this.set(path, Object.freeze({ safeTime: timestamp, timestamp }));\n    }\n    toTimestamps() {\n        const timestamps = new Map();\n        for (const [file, entry] of this) {\n            timestamps.set(file, entry.timestamp);\n        }\n        return timestamps;\n    }\n}\nclass BuilderWatchFileSystem {\n    constructor(watcherFactory, inputFileSystem) {\n        this.watcherFactory = watcherFactory;\n        this.inputFileSystem = inputFileSystem;\n    }\n    watch(files, directories, missing, startTime, _options, callback, callbackUndelayed) {\n        const watchedFiles = new Set(files);\n        const watchedDirectories = new Set(directories);\n        const watchedMissing = new Set(missing);\n        const timeInfo = new TimeInfoMap();\n        for (const file of files) {\n            timeInfo.update(file, startTime);\n        }\n        for (const directory of directories) {\n            timeInfo.update(directory, startTime);\n        }\n        const watcher = this.watcherFactory.watch(files, directories, (events) => {\n            if (events.length === 0) {\n                return;\n            }\n            if (callbackUndelayed) {\n                process.nextTick(() => { var _a; return callbackUndelayed(events[0].path, (_a = events[0].time) !== null && _a !== void 0 ? _a : Date.now()); });\n            }\n            process.nextTick(() => {\n                var _a, _b, _c;\n                const removals = new Set();\n                const fileChanges = new Set();\n                const directoryChanges = new Set();\n                const missingChanges = new Set();\n                for (const event of events) {\n                    (_b = (_a = this.inputFileSystem).purge) === null || _b === void 0 ? void 0 : _b.call(_a, event.path);\n                    if (event.type === 'deleted') {\n                        timeInfo.delete(event.path);\n                        removals.add(event.path);\n                    }\n                    else {\n                        timeInfo.update(event.path, (_c = event.time) !== null && _c !== void 0 ? _c : Date.now());\n                        if (watchedFiles.has(event.path)) {\n                            fileChanges.add(event.path);\n                        }\n                        else if (watchedDirectories.has(event.path)) {\n                            directoryChanges.add(event.path);\n                        }\n                        else if (watchedMissing.has(event.path)) {\n                            missingChanges.add(event.path);\n                        }\n                    }\n                }\n                const timeInfoMap = new Map(timeInfo);\n                callback(undefined, timeInfoMap, timeInfoMap, new Set([...fileChanges, ...directoryChanges, ...missingChanges]), removals);\n            });\n        });\n        return {\n            close() {\n                watcher.close();\n            },\n            pause() { },\n            getFileTimeInfoEntries() {\n                return new Map(timeInfo);\n            },\n            getContextTimeInfoEntries() {\n                return new Map(timeInfo);\n            },\n        };\n    }\n}\nclass BuilderWatchPlugin {\n    constructor(watcherFactory) {\n        this.watcherFactory = watcherFactory;\n    }\n    apply(compiler) {\n        compiler.hooks.environment.tap('BuilderWatchPlugin', () => {\n            compiler.watchFileSystem = new BuilderWatchFileSystem(this.watcherFactory, compiler.inputFileSystem);\n        });\n    }\n}\nexports.BuilderWatchPlugin = BuilderWatchPlugin;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}