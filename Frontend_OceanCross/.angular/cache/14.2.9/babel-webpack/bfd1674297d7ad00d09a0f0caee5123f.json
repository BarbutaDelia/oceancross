{"ast":null,"code":"\"use strict\";\n/*\n * Based on the packages get-port https://www.npmjs.com/package/get-port\n * and portfinder https://www.npmjs.com/package/portfinder\n * The code structure is similar to get-port, but it searches\n * ports deterministically like portfinder\n */\n\nvar _asyncToGenerator = require(\"/Users/deliabarbuta/Documents/An4Sem1/PAW/Proiect/proiect-paw-tadam/Frontend_OceanCross/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nconst net = require(\"net\");\n\nconst os = require(\"os\");\n\nconst minPort = 1024;\nconst maxPort = 65_535;\n/**\n * @return {Set<string|undefined>}\n */\n\nconst getLocalHosts = () => {\n  const interfaces = os.networkInterfaces(); // Add undefined value for createServer function to use default host,\n  // and default IPv4 host in case createServer defaults to IPv6.\n  // eslint-disable-next-line no-undefined\n\n  const results = new Set([undefined, \"0.0.0.0\"]);\n\n  for (const _interface of Object.values(interfaces)) {\n    if (_interface) {\n      for (const config of _interface) {\n        results.add(config.address);\n      }\n    }\n  }\n\n  return results;\n};\n/**\n * @param {number} basePort\n * @param {string | undefined} host\n * @return {Promise<number>}\n */\n\n\nconst checkAvailablePort = (basePort, host) => new Promise((resolve, reject) => {\n  const server = net.createServer();\n  server.unref();\n  server.on(\"error\", reject);\n  server.listen(basePort, host, () => {\n    // Next line should return AdressInfo because we're calling it after listen() and before close()\n    const {\n      port\n    } =\n    /** @type {import(\"net\").AddressInfo} */\n    server.address();\n    server.close(() => {\n      resolve(port);\n    });\n  });\n});\n/**\n * @param {number} port\n * @param {Set<string|undefined>} hosts\n * @return {Promise<number>}\n */\n\n\nconst getAvailablePort = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (port, hosts) {\n    /**\n     * Errors that mean that host is not available.\n     * @type {Set<string | undefined>}\n     */\n    const nonExistentInterfaceErrors = new Set([\"EADDRNOTAVAIL\", \"EINVAL\"]);\n    /* Check if the post is available on every local host name */\n\n    for (const host of hosts) {\n      try {\n        yield checkAvailablePort(port, host); // eslint-disable-line no-await-in-loop\n      } catch (error) {\n        /* We throw an error only if the interface exists */\n        if (!nonExistentInterfaceErrors.has(\n        /** @type {NodeJS.ErrnoException} */\n        error.code)) {\n          throw error;\n        }\n      }\n    }\n\n    return port;\n  });\n\n  return function getAvailablePort(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\n/**\n * @param {number} basePort\n * @param {string=} host\n * @return {Promise<number>}\n */\n\n\nfunction getPorts(_x3, _x4) {\n  return _getPorts.apply(this, arguments);\n}\n\nfunction _getPorts() {\n  _getPorts = _asyncToGenerator(function* (basePort, host) {\n    if (basePort < minPort || basePort > maxPort) {\n      throw new Error(`Port number must lie between ${minPort} and ${maxPort}`);\n    }\n\n    let port = basePort;\n    const localhosts = getLocalHosts();\n    let hosts;\n\n    if (host && !localhosts.has(host)) {\n      hosts = new Set([host]);\n    } else {\n      /* If the host is equivalent to localhost\n         we need to check every equivalent host\n         else the port might falsely appear as available\n         on some operating systems  */\n      hosts = localhosts;\n    }\n    /** @type {Set<string | undefined>} */\n\n\n    const portUnavailableErrors = new Set([\"EADDRINUSE\", \"EACCES\"]);\n\n    while (port <= maxPort) {\n      try {\n        const availablePort = yield getAvailablePort(port, hosts); // eslint-disable-line no-await-in-loop\n\n        return availablePort;\n      } catch (error) {\n        /* Try next port if port is busy; throw for any other error */\n        if (!portUnavailableErrors.has(\n        /** @type {NodeJS.ErrnoException} */\n        error.code)) {\n          throw error;\n        }\n\n        port += 1;\n      }\n    }\n\n    throw new Error(\"No available ports found\");\n  });\n  return _getPorts.apply(this, arguments);\n}\n\nmodule.exports = getPorts;","map":{"version":3,"names":["net","require","os","minPort","maxPort","getLocalHosts","interfaces","networkInterfaces","results","Set","undefined","_interface","Object","values","config","add","address","checkAvailablePort","basePort","host","Promise","resolve","reject","server","createServer","unref","on","listen","port","close","getAvailablePort","hosts","nonExistentInterfaceErrors","error","has","code","getPorts","Error","localhosts","portUnavailableErrors","availablePort","module","exports"],"sources":["/Users/deliabarbuta/Documents/An4Sem1/PAW/Proiect/proiect-paw-tadam/Frontend_OceanCross/node_modules/webpack-dev-server/lib/getPort.js"],"sourcesContent":["\"use strict\";\n\n/*\n * Based on the packages get-port https://www.npmjs.com/package/get-port\n * and portfinder https://www.npmjs.com/package/portfinder\n * The code structure is similar to get-port, but it searches\n * ports deterministically like portfinder\n */\nconst net = require(\"net\");\nconst os = require(\"os\");\n\nconst minPort = 1024;\nconst maxPort = 65_535;\n\n/**\n * @return {Set<string|undefined>}\n */\nconst getLocalHosts = () => {\n  const interfaces = os.networkInterfaces();\n\n  // Add undefined value for createServer function to use default host,\n  // and default IPv4 host in case createServer defaults to IPv6.\n  // eslint-disable-next-line no-undefined\n  const results = new Set([undefined, \"0.0.0.0\"]);\n\n  for (const _interface of Object.values(interfaces)) {\n    if (_interface) {\n      for (const config of _interface) {\n        results.add(config.address);\n      }\n    }\n  }\n\n  return results;\n};\n\n/**\n * @param {number} basePort\n * @param {string | undefined} host\n * @return {Promise<number>}\n */\nconst checkAvailablePort = (basePort, host) =>\n  new Promise((resolve, reject) => {\n    const server = net.createServer();\n    server.unref();\n    server.on(\"error\", reject);\n\n    server.listen(basePort, host, () => {\n      // Next line should return AdressInfo because we're calling it after listen() and before close()\n      const { port } = /** @type {import(\"net\").AddressInfo} */ (\n        server.address()\n      );\n      server.close(() => {\n        resolve(port);\n      });\n    });\n  });\n\n/**\n * @param {number} port\n * @param {Set<string|undefined>} hosts\n * @return {Promise<number>}\n */\nconst getAvailablePort = async (port, hosts) => {\n  /**\n   * Errors that mean that host is not available.\n   * @type {Set<string | undefined>}\n   */\n  const nonExistentInterfaceErrors = new Set([\"EADDRNOTAVAIL\", \"EINVAL\"]);\n  /* Check if the post is available on every local host name */\n  for (const host of hosts) {\n    try {\n      await checkAvailablePort(port, host); // eslint-disable-line no-await-in-loop\n    } catch (error) {\n      /* We throw an error only if the interface exists */\n      if (\n        !nonExistentInterfaceErrors.has(\n          /** @type {NodeJS.ErrnoException} */ (error).code\n        )\n      ) {\n        throw error;\n      }\n    }\n  }\n\n  return port;\n};\n\n/**\n * @param {number} basePort\n * @param {string=} host\n * @return {Promise<number>}\n */\nasync function getPorts(basePort, host) {\n  if (basePort < minPort || basePort > maxPort) {\n    throw new Error(`Port number must lie between ${minPort} and ${maxPort}`);\n  }\n\n  let port = basePort;\n  const localhosts = getLocalHosts();\n  let hosts;\n  if (host && !localhosts.has(host)) {\n    hosts = new Set([host]);\n  } else {\n    /* If the host is equivalent to localhost\n       we need to check every equivalent host\n       else the port might falsely appear as available\n       on some operating systems  */\n    hosts = localhosts;\n  }\n  /** @type {Set<string | undefined>} */\n  const portUnavailableErrors = new Set([\"EADDRINUSE\", \"EACCES\"]);\n  while (port <= maxPort) {\n    try {\n      const availablePort = await getAvailablePort(port, hosts); // eslint-disable-line no-await-in-loop\n      return availablePort;\n    } catch (error) {\n      /* Try next port if port is busy; throw for any other error */\n      if (\n        !portUnavailableErrors.has(\n          /** @type {NodeJS.ErrnoException} */ (error).code\n        )\n      ) {\n        throw error;\n      }\n      port += 1;\n    }\n  }\n\n  throw new Error(\"No available ports found\");\n}\n\nmodule.exports = getPorts;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}