{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"/Users/deliabarbuta/Documents/An4Sem1/PAW/Proiect/proiect-paw-tadam/Frontend_OceanCross/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nconst path = require(\"path\");\n\nconst {\n  validate\n} = require(\"schema-utils\");\n\nconst serialize = require(\"serialize-javascript\");\n\nconst normalizePath = require(\"normalize-path\");\n\nconst globParent = require(\"glob-parent\");\n\nconst fastGlob = require(\"fast-glob\"); // @ts-ignore\n\n\nconst {\n  version\n} = require(\"../package.json\");\n\nconst schema = require(\"./options.json\");\n\nconst {\n  readFile,\n  stat,\n  throttleAll\n} = require(\"./utils\");\n\nconst template = /\\[\\\\*([\\w:]+)\\\\*\\]/i;\n/** @typedef {import(\"schema-utils/declarations/validate\").Schema} Schema */\n\n/** @typedef {import(\"webpack\").Compiler} Compiler */\n\n/** @typedef {import(\"webpack\").Compilation} Compilation */\n\n/** @typedef {import(\"webpack\").WebpackError} WebpackError */\n\n/** @typedef {import(\"webpack\").Asset} Asset */\n\n/** @typedef {import(\"globby\").Options} GlobbyOptions */\n\n/** @typedef {import(\"globby\").GlobEntry} GlobEntry */\n\n/** @typedef {ReturnType<Compilation[\"getLogger\"]>} WebpackLogger */\n\n/** @typedef {ReturnType<Compilation[\"getCache\"]>} CacheFacade */\n\n/** @typedef {ReturnType<ReturnType<Compilation[\"getCache\"]>[\"getLazyHashedEtag\"]>} Etag */\n\n/** @typedef {ReturnType<Compilation[\"fileSystemInfo\"][\"mergeSnapshots\"]>} Snapshot */\n\n/**\n * @typedef {boolean} Force\n */\n\n/**\n * @typedef {Object} CopiedResult\n * @property {string} sourceFilename\n * @property {string} absoluteFilename\n * @property {string} filename\n * @property {Asset[\"source\"]} source\n * @property {Force | undefined} force\n * @property {Record<string, any>} info\n */\n\n/**\n * @typedef {string} StringPattern\n */\n\n/**\n * @typedef {boolean} NoErrorOnMissing\n */\n\n/**\n * @typedef {string} Context\n */\n\n/**\n * @typedef {string} From\n */\n\n/**\n * @callback ToFunction\n * @param {{ context: string, absoluteFilename?: string }} pathData\n * @return {string | Promise<string>}\n */\n\n/**\n * @typedef {string | ToFunction} To\n */\n\n/**\n * @typedef {\"dir\" | \"file\" | \"template\"} ToType\n */\n\n/**\n * @callback TransformerFunction\n * @param {Buffer} input\n * @param {string} absoluteFilename\n * @returns {string | Buffer | Promise<string> | Promise<Buffer>}\n */\n\n/**\n * @typedef {{ keys: { [key: string]: any } } | { keys: ((defaultCacheKeys: { [key: string]: any }, absoluteFilename: string) => Promise<{ [key: string]: any }>) }} TransformerCacheObject\n */\n\n/**\n * @typedef {Object} TransformerObject\n * @property {TransformerFunction} transformer\n * @property {boolean | TransformerCacheObject} [cache]\n */\n\n/**\n * @typedef {TransformerFunction | TransformerObject} Transform\n */\n\n/**\n * @callback Filter\n * @param {string} filepath\n * @returns {boolean | Promise<boolean>}\n */\n\n/**\n * @callback TransformAllFunction\n * @param {{ data: Buffer, sourceFilename: string, absoluteFilename: string }[]} data\n * @returns {string | Buffer | Promise<string> | Promise<Buffer>}\n */\n\n/**\n * @typedef { Record<string, any> | ((item: { absoluteFilename: string, sourceFilename: string, filename: string, toType: ToType }) => Record<string, any>) } Info\n */\n\n/**\n * @typedef {Object} ObjectPattern\n * @property {From} from\n * @property {GlobbyOptions} [globOptions]\n * @property {Context} [context]\n * @property {To} [to]\n * @property {ToType} [toType]\n * @property {Info} [info]\n * @property {Filter} [filter]\n * @property {Transform} [transform]\n * @property {TransformAllFunction} [transformAll]\n * @property {Force} [force]\n * @property {number} [priority]\n * @property {NoErrorOnMissing} [noErrorOnMissing]\n */\n\n/**\n * @typedef {StringPattern | ObjectPattern} Pattern\n */\n\n/**\n * @typedef {Object} AdditionalOptions\n * @property {number} [concurrency]\n */\n\n/**\n * @typedef {Object} PluginOptions\n * @property {Pattern[]} patterns\n * @property {AdditionalOptions} [options]\n */\n\nclass CopyPlugin {\n  /**\n   * @param {PluginOptions} [options]\n   */\n  constructor(options = {\n    patterns: []\n  }) {\n    validate(\n    /** @type {Schema} */\n    schema, options, {\n      name: \"Copy Plugin\",\n      baseDataPath: \"options\"\n    });\n    /**\n     * @private\n     * @type {Pattern[]}\n     */\n\n    this.patterns = options.patterns;\n    /**\n     * @private\n     * @type {AdditionalOptions}\n     */\n\n    this.options = options.options || {};\n  }\n  /**\n   * @private\n   * @param {Compilation} compilation\n   * @param {number} startTime\n   * @param {string} dependency\n   * @returns {Promise<Snapshot | undefined>}\n   */\n\n\n  static createSnapshot(compilation, startTime, dependency) {\n    return _asyncToGenerator(function* () {\n      // eslint-disable-next-line consistent-return\n      return new Promise((resolve, reject) => {\n        compilation.fileSystemInfo.createSnapshot(startTime, [dependency], // @ts-ignore\n        // eslint-disable-next-line no-undefined\n        undefined, // eslint-disable-next-line no-undefined\n        undefined, null, (error, snapshot) => {\n          if (error) {\n            reject(error);\n            return;\n          }\n\n          resolve(\n          /** @type {Snapshot} */\n          snapshot);\n        });\n      });\n    })();\n  }\n  /**\n   * @private\n   * @param {Compilation} compilation\n   * @param {Snapshot} snapshot\n   * @returns {Promise<boolean | undefined>}\n   */\n\n\n  static checkSnapshotValid(compilation, snapshot) {\n    return _asyncToGenerator(function* () {\n      // eslint-disable-next-line consistent-return\n      return new Promise((resolve, reject) => {\n        compilation.fileSystemInfo.checkSnapshotValid(snapshot, (error, isValid) => {\n          if (error) {\n            reject(error);\n            return;\n          }\n\n          resolve(isValid);\n        });\n      });\n    })();\n  }\n  /**\n   * @private\n   * @param {Compiler} compiler\n   * @param {Compilation} compilation\n   * @param {Buffer} source\n   * @returns {string}\n   */\n\n\n  static getContentHash(compiler, compilation, source) {\n    const {\n      outputOptions\n    } = compilation;\n    const {\n      hashDigest,\n      hashDigestLength,\n      hashFunction,\n      hashSalt\n    } = outputOptions;\n    const hash = compiler.webpack.util.createHash(\n    /** @type {string} */\n    hashFunction);\n\n    if (hashSalt) {\n      hash.update(hashSalt);\n    }\n\n    hash.update(source);\n    const fullContentHash = hash.digest(hashDigest);\n    return fullContentHash.toString().slice(0, hashDigestLength);\n  }\n  /**\n   * @private\n   * @param {typeof import(\"globby\").globby} globby\n   * @param {Compiler} compiler\n   * @param {Compilation} compilation\n   * @param {WebpackLogger} logger\n   * @param {CacheFacade} cache\n   * @param {ObjectPattern & { context: string }} inputPattern\n   * @param {number} index\n   * @returns {Promise<Array<CopiedResult | undefined> | undefined>}\n   */\n\n\n  static runPattern(globby, compiler, compilation, logger, cache, inputPattern, index) {\n    return _asyncToGenerator(function* () {\n      const {\n        RawSource\n      } = compiler.webpack.sources;\n      const pattern = { ...inputPattern\n      };\n      const originalFrom = pattern.from;\n      const normalizedOriginalFrom = path.normalize(originalFrom);\n      logger.log(`starting to process a pattern from '${normalizedOriginalFrom}' using '${pattern.context}' context`);\n      let absoluteFrom;\n\n      if (path.isAbsolute(normalizedOriginalFrom)) {\n        absoluteFrom = normalizedOriginalFrom;\n      } else {\n        absoluteFrom = path.resolve(pattern.context, normalizedOriginalFrom);\n      }\n\n      logger.debug(`getting stats for '${absoluteFrom}'...`);\n      const {\n        inputFileSystem\n      } = compiler;\n      let stats;\n\n      try {\n        stats = yield stat(inputFileSystem, absoluteFrom);\n      } catch (error) {// Nothing\n      }\n      /**\n       * @type {\"file\" | \"dir\" | \"glob\"}\n       */\n\n\n      let fromType;\n\n      if (stats) {\n        if (stats.isDirectory()) {\n          fromType = \"dir\";\n          logger.debug(`determined '${absoluteFrom}' is a directory`);\n        } else if (stats.isFile()) {\n          fromType = \"file\";\n          logger.debug(`determined '${absoluteFrom}' is a file`);\n        } else {\n          // Fallback\n          fromType = \"glob\";\n          logger.debug(`determined '${absoluteFrom}' is unknown`);\n        }\n      } else {\n        fromType = \"glob\";\n        logger.debug(`determined '${absoluteFrom}' is a glob`);\n      }\n      /** @type {GlobbyOptions & { objectMode: true }} */\n\n\n      const globOptions = { ...{\n          followSymbolicLinks: true\n        },\n        ...(pattern.globOptions || {}),\n        ...{\n          cwd: pattern.context,\n          objectMode: true\n        }\n      }; // @ts-ignore\n\n      globOptions.fs = inputFileSystem;\n      let glob;\n\n      switch (fromType) {\n        case \"dir\":\n          compilation.contextDependencies.add(absoluteFrom);\n          logger.debug(`added '${absoluteFrom}' as a context dependency`);\n          pattern.context = absoluteFrom;\n          glob = path.posix.join(fastGlob.escapePath(normalizePath(path.resolve(absoluteFrom))), \"**/*\");\n          absoluteFrom = path.join(absoluteFrom, \"**/*\");\n\n          if (typeof globOptions.dot === \"undefined\") {\n            globOptions.dot = true;\n          }\n\n          break;\n\n        case \"file\":\n          compilation.fileDependencies.add(absoluteFrom);\n          logger.debug(`added '${absoluteFrom}' as a file dependency`);\n          pattern.context = path.dirname(absoluteFrom);\n          glob = fastGlob.escapePath(normalizePath(path.resolve(absoluteFrom)));\n\n          if (typeof globOptions.dot === \"undefined\") {\n            globOptions.dot = true;\n          }\n\n          break;\n\n        case \"glob\":\n        default:\n          {\n            const contextDependencies = path.normalize(globParent(absoluteFrom));\n            compilation.contextDependencies.add(contextDependencies);\n            logger.debug(`added '${contextDependencies}' as a context dependency`);\n            glob = path.isAbsolute(originalFrom) ? originalFrom : path.posix.join(fastGlob.escapePath(normalizePath(path.resolve(pattern.context))), originalFrom);\n          }\n      }\n\n      logger.log(`begin globbing '${glob}'...`);\n      /**\n       * @type {GlobEntry[]}\n       */\n\n      let globEntries;\n\n      try {\n        globEntries = yield globby(glob, globOptions);\n      } catch (error) {\n        compilation.errors.push(\n        /** @type {WebpackError} */\n        error);\n        return;\n      }\n\n      if (globEntries.length === 0) {\n        if (pattern.noErrorOnMissing) {\n          logger.log(`finished to process a pattern from '${normalizedOriginalFrom}' using '${pattern.context}' context to '${pattern.to}'`);\n          return;\n        }\n\n        const missingError = new Error(`unable to locate '${glob}' glob`);\n        compilation.errors.push(\n        /** @type {WebpackError} */\n        missingError);\n        return;\n      }\n      /**\n       * @type {Array<CopiedResult | undefined>}\n       */\n\n\n      let copiedResult;\n\n      try {\n        copiedResult = yield Promise.all(globEntries.map(\n        /*#__PURE__*/\n\n        /**\n         * @param {GlobEntry} globEntry\n         * @returns {Promise<CopiedResult | undefined>}\n         */\n        function () {\n          var _ref = _asyncToGenerator(function* (globEntry) {\n            // Exclude directories\n            if (!globEntry.dirent.isFile()) {\n              return;\n            }\n\n            if (pattern.filter) {\n              let isFiltered;\n\n              try {\n                isFiltered = yield pattern.filter(globEntry.path);\n              } catch (error) {\n                compilation.errors.push(\n                /** @type {WebpackError} */\n                error);\n                return;\n              }\n\n              if (!isFiltered) {\n                logger.log(`skip '${globEntry.path}', because it was filtered`);\n                return;\n              }\n            }\n\n            const from = globEntry.path;\n            logger.debug(`found '${from}'`); // `globby`/`fast-glob` return the relative path when the path contains special characters on windows\n\n            const absoluteFilename = path.resolve(pattern.context, from);\n            const to = typeof pattern.to === \"function\" ? yield pattern.to({\n              context: pattern.context,\n              absoluteFilename\n            }) : path.normalize(typeof pattern.to !== \"undefined\" ? pattern.to : \"\");\n            const toType = pattern.toType ? pattern.toType : template.test(to) ? \"template\" : path.extname(to) === \"\" || to.slice(-1) === path.sep ? \"dir\" : \"file\";\n            logger.log(`'to' option '${to}' determinated as '${toType}'`);\n            const relativeFrom = path.relative(pattern.context, absoluteFilename);\n            let filename = toType === \"dir\" ? path.join(to, relativeFrom) : to;\n\n            if (path.isAbsolute(filename)) {\n              filename = path.relative(\n              /** @type {string} */\n              compiler.options.output.path, filename);\n            }\n\n            logger.log(`determined that '${from}' should write to '${filename}'`);\n            const sourceFilename = normalizePath(path.relative(compiler.context, absoluteFilename)); // If this came from a glob or dir, add it to the file dependencies\n\n            if (fromType === \"dir\" || fromType === \"glob\") {\n              compilation.fileDependencies.add(absoluteFilename);\n              logger.debug(`added '${absoluteFilename}' as a file dependency`);\n            }\n\n            let cacheEntry;\n            logger.debug(`getting cache for '${absoluteFilename}'...`);\n\n            try {\n              cacheEntry = yield cache.getPromise(`${sourceFilename}|${index}`, null);\n            } catch (error) {\n              compilation.errors.push(\n              /** @type {WebpackError} */\n              error);\n              return;\n            }\n            /**\n             * @type {Asset[\"source\"] | undefined}\n             */\n\n\n            let source;\n\n            if (cacheEntry) {\n              logger.debug(`found cache for '${absoluteFilename}'...`);\n              let isValidSnapshot;\n              logger.debug(`checking snapshot on valid for '${absoluteFilename}'...`);\n\n              try {\n                isValidSnapshot = yield CopyPlugin.checkSnapshotValid(compilation, cacheEntry.snapshot);\n              } catch (error) {\n                compilation.errors.push(\n                /** @type {WebpackError} */\n                error);\n                return;\n              }\n\n              if (isValidSnapshot) {\n                logger.debug(`snapshot for '${absoluteFilename}' is valid`);\n                ({\n                  source\n                } = cacheEntry);\n              } else {\n                logger.debug(`snapshot for '${absoluteFilename}' is invalid`);\n              }\n            } else {\n              logger.debug(`missed cache for '${absoluteFilename}'`);\n            }\n\n            if (!source) {\n              const startTime = Date.now();\n              logger.debug(`reading '${absoluteFilename}'...`);\n              let data;\n\n              try {\n                data = yield readFile(inputFileSystem, absoluteFilename);\n              } catch (error) {\n                compilation.errors.push(\n                /** @type {WebpackError} */\n                error);\n                return;\n              }\n\n              logger.debug(`read '${absoluteFilename}'`);\n              source = new RawSource(data);\n              let snapshot;\n              logger.debug(`creating snapshot for '${absoluteFilename}'...`);\n\n              try {\n                snapshot = yield CopyPlugin.createSnapshot(compilation, startTime, absoluteFilename);\n              } catch (error) {\n                compilation.errors.push(\n                /** @type {WebpackError} */\n                error);\n                return;\n              }\n\n              if (snapshot) {\n                logger.debug(`created snapshot for '${absoluteFilename}'`);\n                logger.debug(`storing cache for '${absoluteFilename}'...`);\n\n                try {\n                  yield cache.storePromise(`${sourceFilename}|${index}`, null, {\n                    source,\n                    snapshot\n                  });\n                } catch (error) {\n                  compilation.errors.push(\n                  /** @type {WebpackError} */\n                  error);\n                  return;\n                }\n\n                logger.debug(`stored cache for '${absoluteFilename}'`);\n              }\n            }\n\n            if (pattern.transform) {\n              /**\n               * @type {TransformerObject}\n               */\n              const transformObj = typeof pattern.transform === \"function\" ? {\n                transformer: pattern.transform\n              } : pattern.transform;\n\n              if (transformObj.transformer) {\n                logger.log(`transforming content for '${absoluteFilename}'...`);\n                const buffer = source.buffer();\n\n                if (transformObj.cache) {\n                  // TODO: remove in the next major release\n                  const hasher = compiler.webpack && compiler.webpack.util && compiler.webpack.util.createHash ? compiler.webpack.util.createHash(\"xxhash64\") : // eslint-disable-next-line global-require\n                  require(\"crypto\").createHash(\"md4\");\n                  const defaultCacheKeys = {\n                    version,\n                    sourceFilename,\n                    transform: transformObj.transformer,\n                    contentHash: hasher.update(buffer).digest(\"hex\"),\n                    index\n                  };\n                  const cacheKeys = `transform|${serialize(typeof transformObj.cache === \"boolean\" ? defaultCacheKeys : typeof transformObj.cache.keys === \"function\" ? yield transformObj.cache.keys(defaultCacheKeys, absoluteFilename) : { ...defaultCacheKeys,\n                    ...transformObj.cache.keys\n                  })}`;\n                  logger.debug(`getting transformation cache for '${absoluteFilename}'...`);\n                  const cacheItem = cache.getItemCache(cacheKeys, cache.getLazyHashedEtag(source));\n                  source = yield cacheItem.getPromise();\n                  logger.debug(source ? `found transformation cache for '${absoluteFilename}'` : `no transformation cache for '${absoluteFilename}'`);\n\n                  if (!source) {\n                    const transformed = yield transformObj.transformer(buffer, absoluteFilename);\n                    source = new RawSource(transformed);\n                    logger.debug(`caching transformation for '${absoluteFilename}'...`);\n                    yield cacheItem.storePromise(source);\n                    logger.debug(`cached transformation for '${absoluteFilename}'`);\n                  }\n                } else {\n                  source = new RawSource(yield transformObj.transformer(buffer, absoluteFilename));\n                }\n              }\n            }\n\n            let info = typeof pattern.info === \"undefined\" ? {} : typeof pattern.info === \"function\" ? pattern.info({\n              absoluteFilename,\n              sourceFilename,\n              filename,\n              toType\n            }) || {} : pattern.info || {};\n\n            if (toType === \"template\") {\n              logger.log(`interpolating template '${filename}' for '${sourceFilename}'...`);\n              const contentHash = CopyPlugin.getContentHash(compiler, compilation, source.buffer());\n              const ext = path.extname(sourceFilename);\n              const base = path.basename(sourceFilename);\n              const name = base.slice(0, base.length - ext.length);\n              const data = {\n                filename: normalizePath(path.relative(pattern.context, absoluteFilename)),\n                contentHash,\n                chunk: {\n                  name,\n                  id:\n                  /** @type {string} */\n                  sourceFilename,\n                  hash: contentHash\n                }\n              };\n              const {\n                path: interpolatedFilename,\n                info: assetInfo\n              } = compilation.getPathWithInfo(normalizePath(filename), data);\n              info = { ...info,\n                ...assetInfo\n              };\n              filename = interpolatedFilename;\n              logger.log(`interpolated template '${filename}' for '${sourceFilename}'`);\n            } else {\n              filename = normalizePath(filename);\n            } // eslint-disable-next-line consistent-return\n\n\n            return {\n              sourceFilename,\n              absoluteFilename,\n              filename,\n              source,\n              info,\n              force: pattern.force\n            };\n          });\n\n          return function (_x) {\n            return _ref.apply(this, arguments);\n          };\n        }()));\n      } catch (error) {\n        compilation.errors.push(\n        /** @type {WebpackError} */\n        error);\n        return;\n      }\n\n      if (copiedResult.length === 0) {\n        if (pattern.noErrorOnMissing) {\n          logger.log(`finished to process a pattern from '${normalizedOriginalFrom}' using '${pattern.context}' context to '${pattern.to}'`);\n          return;\n        }\n\n        const missingError = new Error(`unable to locate '${glob}' glob after filtering paths`);\n        compilation.errors.push(\n        /** @type {WebpackError} */\n        missingError);\n        return;\n      }\n\n      logger.log(`finished to process a pattern from '${normalizedOriginalFrom}' using '${pattern.context}' context`); // eslint-disable-next-line consistent-return\n\n      return copiedResult;\n    })();\n  }\n  /**\n   * @param {Compiler} compiler\n   */\n\n\n  apply(compiler) {\n    var _this = this;\n\n    const pluginName = this.constructor.name;\n    compiler.hooks.thisCompilation.tap(pluginName, compilation => {\n      const logger = compilation.getLogger(\"copy-webpack-plugin\");\n      const cache = compilation.getCache(\"CopyWebpackPlugin\");\n      /**\n       * @type {typeof import(\"globby\").globby}\n       */\n\n      let globby;\n      compilation.hooks.processAssets.tapAsync({\n        name: \"copy-webpack-plugin\",\n        stage: compiler.webpack.Compilation.PROCESS_ASSETS_STAGE_ADDITIONAL\n      }, /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator(function* (unusedAssets, callback) {\n          if (typeof globby === \"undefined\") {\n            try {\n              // @ts-ignore\n              ({\n                globby\n              } = yield import(\"globby\"));\n            } catch (error) {\n              callback(\n              /** @type {Error} */\n              error);\n              return;\n            }\n          }\n\n          logger.log(\"starting to add additional assets...\");\n          const copiedResultMap = new Map();\n          /**\n           * @type {(() => Promise<void>)[]}\n           */\n\n          const scheduledTasks = [];\n\n          _this.patterns.map(\n          /**\n           * @param {Pattern} item\n           * @param {number} index\n           * @return {number}\n           */\n          (item, index) => scheduledTasks.push( /*#__PURE__*/_asyncToGenerator(function* () {\n            /**\n             * @type {ObjectPattern}\n             */\n            const normalizedPattern = typeof item === \"string\" ? {\n              from: item\n            } : { ...item\n            };\n            const context = typeof normalizedPattern.context === \"undefined\" ? compiler.context : path.isAbsolute(normalizedPattern.context) ? normalizedPattern.context : path.join(compiler.context, normalizedPattern.context);\n            normalizedPattern.context = context;\n            /**\n             * @type {Array<CopiedResult | undefined> | undefined}\n             */\n\n            let copiedResult;\n\n            try {\n              copiedResult = yield CopyPlugin.runPattern(globby, compiler, compilation, logger, cache,\n              /** @type {ObjectPattern & { context: string }} */\n              normalizedPattern, index);\n            } catch (error) {\n              compilation.errors.push(\n              /** @type {WebpackError} */\n              error);\n              return;\n            }\n\n            if (!copiedResult) {\n              return;\n            }\n            /**\n             * @type {Array<CopiedResult>}\n             */\n\n\n            let filteredCopiedResult = copiedResult.filter(\n            /**\n             * @param {CopiedResult | undefined} result\n             * @returns {result is CopiedResult}\n             */\n            result => Boolean(result));\n\n            if (typeof normalizedPattern.transformAll !== \"undefined\") {\n              if (typeof normalizedPattern.to === \"undefined\") {\n                compilation.errors.push(\n                /** @type {WebpackError} */\n                new Error(`Invalid \"pattern.to\" for the \"pattern.from\": \"${normalizedPattern.from}\" and \"pattern.transformAll\" function. The \"to\" option must be specified.`));\n                return;\n              }\n\n              filteredCopiedResult.sort((a, b) => a.absoluteFilename > b.absoluteFilename ? 1 : a.absoluteFilename < b.absoluteFilename ? -1 : 0);\n              const mergedEtag = filteredCopiedResult.length === 1 ? cache.getLazyHashedEtag(filteredCopiedResult[0].source) : filteredCopiedResult.reduce(\n              /**\n               * @param {Etag} accumulator\n               * @param {CopiedResult} asset\n               * @param {number} i\n               * @return {Etag}\n               */\n              // @ts-ignore\n              (accumulator, asset, i) => {\n                // eslint-disable-next-line no-param-reassign\n                accumulator = cache.mergeEtags(i === 1 ? cache.getLazyHashedEtag(\n                /** @type {CopiedResult}*/\n                accumulator.source) : accumulator, cache.getLazyHashedEtag(asset.source));\n                return accumulator;\n              });\n              const cacheItem = cache.getItemCache(`transformAll|${serialize({\n                version,\n                from: normalizedPattern.from,\n                to: normalizedPattern.to,\n                transformAll: normalizedPattern.transformAll\n              })}`, mergedEtag);\n              let transformedAsset = yield cacheItem.getPromise();\n\n              if (!transformedAsset) {\n                transformedAsset = {\n                  filename: normalizedPattern.to\n                };\n\n                try {\n                  transformedAsset.data = yield normalizedPattern.transformAll(filteredCopiedResult.map(asset => {\n                    return {\n                      data: asset.source.buffer(),\n                      sourceFilename: asset.sourceFilename,\n                      absoluteFilename: asset.absoluteFilename\n                    };\n                  }));\n                } catch (error) {\n                  compilation.errors.push(\n                  /** @type {WebpackError} */\n                  error);\n                  return;\n                }\n\n                const filename = typeof normalizedPattern.to === \"function\" ? yield normalizedPattern.to({\n                  context\n                }) : normalizedPattern.to;\n\n                if (template.test(filename)) {\n                  const contentHash = CopyPlugin.getContentHash(compiler, compilation, transformedAsset.data);\n                  const {\n                    path: interpolatedFilename,\n                    info: assetInfo\n                  } = compilation.getPathWithInfo(normalizePath(filename), {\n                    contentHash,\n                    chunk: {\n                      id: \"unknown-copied-asset\",\n                      hash: contentHash\n                    }\n                  });\n                  transformedAsset.filename = interpolatedFilename;\n                  transformedAsset.info = assetInfo;\n                }\n\n                const {\n                  RawSource\n                } = compiler.webpack.sources;\n                transformedAsset.source = new RawSource(transformedAsset.data);\n                transformedAsset.force = normalizedPattern.force;\n                yield cacheItem.storePromise(transformedAsset);\n              }\n\n              filteredCopiedResult = [transformedAsset];\n            }\n\n            const priority = normalizedPattern.priority || 0;\n\n            if (!copiedResultMap.has(priority)) {\n              copiedResultMap.set(priority, []);\n            }\n\n            copiedResultMap.get(priority).push(...filteredCopiedResult);\n          })));\n\n          yield throttleAll(_this.options.concurrency || 100, scheduledTasks);\n          const copiedResult = [...copiedResultMap.entries()].sort((a, b) => a[0] - b[0]); // Avoid writing assets inside `p-limit`, because it creates concurrency.\n          // It could potentially lead to an error - 'Multiple assets emit different content to the same filename'\n\n          copiedResult.reduce((acc, val) => acc.concat(val[1]), []).filter(Boolean).forEach(\n          /**\n           * @param {CopiedResult} result\n           * @returns {void}\n           */\n          result => {\n            const {\n              absoluteFilename,\n              sourceFilename,\n              filename,\n              source,\n              force\n            } = result;\n            const existingAsset = compilation.getAsset(filename);\n\n            if (existingAsset) {\n              if (force) {\n                const info = {\n                  copied: true,\n                  sourceFilename\n                };\n                logger.log(`force updating '${filename}' from '${absoluteFilename}' to compilation assets, because it already exists...`);\n                compilation.updateAsset(filename, source, { ...info,\n                  ...result.info\n                });\n                logger.log(`force updated '${filename}' from '${absoluteFilename}' to compilation assets, because it already exists`);\n                return;\n              }\n\n              logger.log(`skip adding '${filename}' from '${absoluteFilename}' to compilation assets, because it already exists`);\n              return;\n            }\n\n            const info = {\n              copied: true,\n              sourceFilename\n            };\n            logger.log(`writing '${filename}' from '${absoluteFilename}' to compilation assets...`);\n            compilation.emitAsset(filename, source, { ...info,\n              ...result.info\n            });\n            logger.log(`written '${filename}' from '${absoluteFilename}' to compilation assets`);\n          });\n          logger.log(\"finished to adding additional assets\");\n          callback();\n        });\n\n        return function (_x2, _x3) {\n          return _ref2.apply(this, arguments);\n        };\n      }());\n\n      if (compilation.hooks.statsPrinter) {\n        compilation.hooks.statsPrinter.tap(pluginName, stats => {\n          stats.hooks.print.for(\"asset.info.copied\").tap(\"copy-webpack-plugin\", (copied, {\n            green,\n            formatFlag\n          }) => copied ?\n          /** @type {Function} */\n          green(\n          /** @type {Function} */\n          formatFlag(\"copied\")) : \"\");\n        });\n      }\n    });\n  }\n\n}\n\nmodule.exports = CopyPlugin;","map":{"version":3,"names":["path","require","validate","serialize","normalizePath","globParent","fastGlob","version","schema","readFile","stat","throttleAll","template","CopyPlugin","constructor","options","patterns","name","baseDataPath","createSnapshot","compilation","startTime","dependency","Promise","resolve","reject","fileSystemInfo","undefined","error","snapshot","checkSnapshotValid","isValid","getContentHash","compiler","source","outputOptions","hashDigest","hashDigestLength","hashFunction","hashSalt","hash","webpack","util","createHash","update","fullContentHash","digest","toString","slice","runPattern","globby","logger","cache","inputPattern","index","RawSource","sources","pattern","originalFrom","from","normalizedOriginalFrom","normalize","log","context","absoluteFrom","isAbsolute","debug","inputFileSystem","stats","fromType","isDirectory","isFile","globOptions","followSymbolicLinks","cwd","objectMode","fs","glob","contextDependencies","add","posix","join","escapePath","dot","fileDependencies","dirname","globEntries","errors","push","length","noErrorOnMissing","to","missingError","Error","copiedResult","all","map","globEntry","dirent","filter","isFiltered","absoluteFilename","toType","test","extname","sep","relativeFrom","relative","filename","output","sourceFilename","cacheEntry","getPromise","isValidSnapshot","Date","now","data","storePromise","transform","transformObj","transformer","buffer","hasher","defaultCacheKeys","contentHash","cacheKeys","keys","cacheItem","getItemCache","getLazyHashedEtag","transformed","info","ext","base","basename","chunk","id","interpolatedFilename","assetInfo","getPathWithInfo","force","apply","pluginName","hooks","thisCompilation","tap","getLogger","getCache","processAssets","tapAsync","stage","Compilation","PROCESS_ASSETS_STAGE_ADDITIONAL","unusedAssets","callback","copiedResultMap","Map","scheduledTasks","item","normalizedPattern","filteredCopiedResult","result","Boolean","transformAll","sort","a","b","mergedEtag","reduce","accumulator","asset","i","mergeEtags","transformedAsset","priority","has","set","get","concurrency","entries","acc","val","concat","forEach","existingAsset","getAsset","copied","updateAsset","emitAsset","statsPrinter","print","for","green","formatFlag","module","exports"],"sources":["/Users/deliabarbuta/Documents/An4Sem1/PAW/Proiect/proiect-paw-tadam/Frontend_OceanCross/node_modules/copy-webpack-plugin/dist/index.js"],"sourcesContent":["\"use strict\";\n\nconst path = require(\"path\");\n\nconst {\n  validate\n} = require(\"schema-utils\");\n\nconst serialize = require(\"serialize-javascript\");\n\nconst normalizePath = require(\"normalize-path\");\n\nconst globParent = require(\"glob-parent\");\n\nconst fastGlob = require(\"fast-glob\"); // @ts-ignore\n\n\nconst {\n  version\n} = require(\"../package.json\");\n\nconst schema = require(\"./options.json\");\n\nconst {\n  readFile,\n  stat,\n  throttleAll\n} = require(\"./utils\");\n\nconst template = /\\[\\\\*([\\w:]+)\\\\*\\]/i;\n/** @typedef {import(\"schema-utils/declarations/validate\").Schema} Schema */\n\n/** @typedef {import(\"webpack\").Compiler} Compiler */\n\n/** @typedef {import(\"webpack\").Compilation} Compilation */\n\n/** @typedef {import(\"webpack\").WebpackError} WebpackError */\n\n/** @typedef {import(\"webpack\").Asset} Asset */\n\n/** @typedef {import(\"globby\").Options} GlobbyOptions */\n\n/** @typedef {import(\"globby\").GlobEntry} GlobEntry */\n\n/** @typedef {ReturnType<Compilation[\"getLogger\"]>} WebpackLogger */\n\n/** @typedef {ReturnType<Compilation[\"getCache\"]>} CacheFacade */\n\n/** @typedef {ReturnType<ReturnType<Compilation[\"getCache\"]>[\"getLazyHashedEtag\"]>} Etag */\n\n/** @typedef {ReturnType<Compilation[\"fileSystemInfo\"][\"mergeSnapshots\"]>} Snapshot */\n\n/**\n * @typedef {boolean} Force\n */\n\n/**\n * @typedef {Object} CopiedResult\n * @property {string} sourceFilename\n * @property {string} absoluteFilename\n * @property {string} filename\n * @property {Asset[\"source\"]} source\n * @property {Force | undefined} force\n * @property {Record<string, any>} info\n */\n\n/**\n * @typedef {string} StringPattern\n */\n\n/**\n * @typedef {boolean} NoErrorOnMissing\n */\n\n/**\n * @typedef {string} Context\n */\n\n/**\n * @typedef {string} From\n */\n\n/**\n * @callback ToFunction\n * @param {{ context: string, absoluteFilename?: string }} pathData\n * @return {string | Promise<string>}\n */\n\n/**\n * @typedef {string | ToFunction} To\n */\n\n/**\n * @typedef {\"dir\" | \"file\" | \"template\"} ToType\n */\n\n/**\n * @callback TransformerFunction\n * @param {Buffer} input\n * @param {string} absoluteFilename\n * @returns {string | Buffer | Promise<string> | Promise<Buffer>}\n */\n\n/**\n * @typedef {{ keys: { [key: string]: any } } | { keys: ((defaultCacheKeys: { [key: string]: any }, absoluteFilename: string) => Promise<{ [key: string]: any }>) }} TransformerCacheObject\n */\n\n/**\n * @typedef {Object} TransformerObject\n * @property {TransformerFunction} transformer\n * @property {boolean | TransformerCacheObject} [cache]\n */\n\n/**\n * @typedef {TransformerFunction | TransformerObject} Transform\n */\n\n/**\n * @callback Filter\n * @param {string} filepath\n * @returns {boolean | Promise<boolean>}\n */\n\n/**\n * @callback TransformAllFunction\n * @param {{ data: Buffer, sourceFilename: string, absoluteFilename: string }[]} data\n * @returns {string | Buffer | Promise<string> | Promise<Buffer>}\n */\n\n/**\n * @typedef { Record<string, any> | ((item: { absoluteFilename: string, sourceFilename: string, filename: string, toType: ToType }) => Record<string, any>) } Info\n */\n\n/**\n * @typedef {Object} ObjectPattern\n * @property {From} from\n * @property {GlobbyOptions} [globOptions]\n * @property {Context} [context]\n * @property {To} [to]\n * @property {ToType} [toType]\n * @property {Info} [info]\n * @property {Filter} [filter]\n * @property {Transform} [transform]\n * @property {TransformAllFunction} [transformAll]\n * @property {Force} [force]\n * @property {number} [priority]\n * @property {NoErrorOnMissing} [noErrorOnMissing]\n */\n\n/**\n * @typedef {StringPattern | ObjectPattern} Pattern\n */\n\n/**\n * @typedef {Object} AdditionalOptions\n * @property {number} [concurrency]\n */\n\n/**\n * @typedef {Object} PluginOptions\n * @property {Pattern[]} patterns\n * @property {AdditionalOptions} [options]\n */\n\nclass CopyPlugin {\n  /**\n   * @param {PluginOptions} [options]\n   */\n  constructor(options = {\n    patterns: []\n  }) {\n    validate(\n    /** @type {Schema} */\n    schema, options, {\n      name: \"Copy Plugin\",\n      baseDataPath: \"options\"\n    });\n    /**\n     * @private\n     * @type {Pattern[]}\n     */\n\n    this.patterns = options.patterns;\n    /**\n     * @private\n     * @type {AdditionalOptions}\n     */\n\n    this.options = options.options || {};\n  }\n  /**\n   * @private\n   * @param {Compilation} compilation\n   * @param {number} startTime\n   * @param {string} dependency\n   * @returns {Promise<Snapshot | undefined>}\n   */\n\n\n  static async createSnapshot(compilation, startTime, dependency) {\n    // eslint-disable-next-line consistent-return\n    return new Promise((resolve, reject) => {\n      compilation.fileSystemInfo.createSnapshot(startTime, [dependency], // @ts-ignore\n      // eslint-disable-next-line no-undefined\n      undefined, // eslint-disable-next-line no-undefined\n      undefined, null, (error, snapshot) => {\n        if (error) {\n          reject(error);\n          return;\n        }\n\n        resolve(\n        /** @type {Snapshot} */\n        snapshot);\n      });\n    });\n  }\n  /**\n   * @private\n   * @param {Compilation} compilation\n   * @param {Snapshot} snapshot\n   * @returns {Promise<boolean | undefined>}\n   */\n\n\n  static async checkSnapshotValid(compilation, snapshot) {\n    // eslint-disable-next-line consistent-return\n    return new Promise((resolve, reject) => {\n      compilation.fileSystemInfo.checkSnapshotValid(snapshot, (error, isValid) => {\n        if (error) {\n          reject(error);\n          return;\n        }\n\n        resolve(isValid);\n      });\n    });\n  }\n  /**\n   * @private\n   * @param {Compiler} compiler\n   * @param {Compilation} compilation\n   * @param {Buffer} source\n   * @returns {string}\n   */\n\n\n  static getContentHash(compiler, compilation, source) {\n    const {\n      outputOptions\n    } = compilation;\n    const {\n      hashDigest,\n      hashDigestLength,\n      hashFunction,\n      hashSalt\n    } = outputOptions;\n    const hash = compiler.webpack.util.createHash(\n    /** @type {string} */\n    hashFunction);\n\n    if (hashSalt) {\n      hash.update(hashSalt);\n    }\n\n    hash.update(source);\n    const fullContentHash = hash.digest(hashDigest);\n    return fullContentHash.toString().slice(0, hashDigestLength);\n  }\n  /**\n   * @private\n   * @param {typeof import(\"globby\").globby} globby\n   * @param {Compiler} compiler\n   * @param {Compilation} compilation\n   * @param {WebpackLogger} logger\n   * @param {CacheFacade} cache\n   * @param {ObjectPattern & { context: string }} inputPattern\n   * @param {number} index\n   * @returns {Promise<Array<CopiedResult | undefined> | undefined>}\n   */\n\n\n  static async runPattern(globby, compiler, compilation, logger, cache, inputPattern, index) {\n    const {\n      RawSource\n    } = compiler.webpack.sources;\n    const pattern = { ...inputPattern\n    };\n    const originalFrom = pattern.from;\n    const normalizedOriginalFrom = path.normalize(originalFrom);\n    logger.log(`starting to process a pattern from '${normalizedOriginalFrom}' using '${pattern.context}' context`);\n    let absoluteFrom;\n\n    if (path.isAbsolute(normalizedOriginalFrom)) {\n      absoluteFrom = normalizedOriginalFrom;\n    } else {\n      absoluteFrom = path.resolve(pattern.context, normalizedOriginalFrom);\n    }\n\n    logger.debug(`getting stats for '${absoluteFrom}'...`);\n    const {\n      inputFileSystem\n    } = compiler;\n    let stats;\n\n    try {\n      stats = await stat(inputFileSystem, absoluteFrom);\n    } catch (error) {// Nothing\n    }\n    /**\n     * @type {\"file\" | \"dir\" | \"glob\"}\n     */\n\n\n    let fromType;\n\n    if (stats) {\n      if (stats.isDirectory()) {\n        fromType = \"dir\";\n        logger.debug(`determined '${absoluteFrom}' is a directory`);\n      } else if (stats.isFile()) {\n        fromType = \"file\";\n        logger.debug(`determined '${absoluteFrom}' is a file`);\n      } else {\n        // Fallback\n        fromType = \"glob\";\n        logger.debug(`determined '${absoluteFrom}' is unknown`);\n      }\n    } else {\n      fromType = \"glob\";\n      logger.debug(`determined '${absoluteFrom}' is a glob`);\n    }\n    /** @type {GlobbyOptions & { objectMode: true }} */\n\n\n    const globOptions = { ...{\n        followSymbolicLinks: true\n      },\n      ...(pattern.globOptions || {}),\n      ...{\n        cwd: pattern.context,\n        objectMode: true\n      }\n    }; // @ts-ignore\n\n    globOptions.fs = inputFileSystem;\n    let glob;\n\n    switch (fromType) {\n      case \"dir\":\n        compilation.contextDependencies.add(absoluteFrom);\n        logger.debug(`added '${absoluteFrom}' as a context dependency`);\n        pattern.context = absoluteFrom;\n        glob = path.posix.join(fastGlob.escapePath(normalizePath(path.resolve(absoluteFrom))), \"**/*\");\n        absoluteFrom = path.join(absoluteFrom, \"**/*\");\n\n        if (typeof globOptions.dot === \"undefined\") {\n          globOptions.dot = true;\n        }\n\n        break;\n\n      case \"file\":\n        compilation.fileDependencies.add(absoluteFrom);\n        logger.debug(`added '${absoluteFrom}' as a file dependency`);\n        pattern.context = path.dirname(absoluteFrom);\n        glob = fastGlob.escapePath(normalizePath(path.resolve(absoluteFrom)));\n\n        if (typeof globOptions.dot === \"undefined\") {\n          globOptions.dot = true;\n        }\n\n        break;\n\n      case \"glob\":\n      default:\n        {\n          const contextDependencies = path.normalize(globParent(absoluteFrom));\n          compilation.contextDependencies.add(contextDependencies);\n          logger.debug(`added '${contextDependencies}' as a context dependency`);\n          glob = path.isAbsolute(originalFrom) ? originalFrom : path.posix.join(fastGlob.escapePath(normalizePath(path.resolve(pattern.context))), originalFrom);\n        }\n    }\n\n    logger.log(`begin globbing '${glob}'...`);\n    /**\n     * @type {GlobEntry[]}\n     */\n\n    let globEntries;\n\n    try {\n      globEntries = await globby(glob, globOptions);\n    } catch (error) {\n      compilation.errors.push(\n      /** @type {WebpackError} */\n      error);\n      return;\n    }\n\n    if (globEntries.length === 0) {\n      if (pattern.noErrorOnMissing) {\n        logger.log(`finished to process a pattern from '${normalizedOriginalFrom}' using '${pattern.context}' context to '${pattern.to}'`);\n        return;\n      }\n\n      const missingError = new Error(`unable to locate '${glob}' glob`);\n      compilation.errors.push(\n      /** @type {WebpackError} */\n      missingError);\n      return;\n    }\n    /**\n     * @type {Array<CopiedResult | undefined>}\n     */\n\n\n    let copiedResult;\n\n    try {\n      copiedResult = await Promise.all(globEntries.map(\n      /**\n       * @param {GlobEntry} globEntry\n       * @returns {Promise<CopiedResult | undefined>}\n       */\n      async globEntry => {\n        // Exclude directories\n        if (!globEntry.dirent.isFile()) {\n          return;\n        }\n\n        if (pattern.filter) {\n          let isFiltered;\n\n          try {\n            isFiltered = await pattern.filter(globEntry.path);\n          } catch (error) {\n            compilation.errors.push(\n            /** @type {WebpackError} */\n            error);\n            return;\n          }\n\n          if (!isFiltered) {\n            logger.log(`skip '${globEntry.path}', because it was filtered`);\n            return;\n          }\n        }\n\n        const from = globEntry.path;\n        logger.debug(`found '${from}'`); // `globby`/`fast-glob` return the relative path when the path contains special characters on windows\n\n        const absoluteFilename = path.resolve(pattern.context, from);\n        const to = typeof pattern.to === \"function\" ? await pattern.to({\n          context: pattern.context,\n          absoluteFilename\n        }) : path.normalize(typeof pattern.to !== \"undefined\" ? pattern.to : \"\");\n        const toType = pattern.toType ? pattern.toType : template.test(to) ? \"template\" : path.extname(to) === \"\" || to.slice(-1) === path.sep ? \"dir\" : \"file\";\n        logger.log(`'to' option '${to}' determinated as '${toType}'`);\n        const relativeFrom = path.relative(pattern.context, absoluteFilename);\n        let filename = toType === \"dir\" ? path.join(to, relativeFrom) : to;\n\n        if (path.isAbsolute(filename)) {\n          filename = path.relative(\n          /** @type {string} */\n          compiler.options.output.path, filename);\n        }\n\n        logger.log(`determined that '${from}' should write to '${filename}'`);\n        const sourceFilename = normalizePath(path.relative(compiler.context, absoluteFilename)); // If this came from a glob or dir, add it to the file dependencies\n\n        if (fromType === \"dir\" || fromType === \"glob\") {\n          compilation.fileDependencies.add(absoluteFilename);\n          logger.debug(`added '${absoluteFilename}' as a file dependency`);\n        }\n\n        let cacheEntry;\n        logger.debug(`getting cache for '${absoluteFilename}'...`);\n\n        try {\n          cacheEntry = await cache.getPromise(`${sourceFilename}|${index}`, null);\n        } catch (error) {\n          compilation.errors.push(\n          /** @type {WebpackError} */\n          error);\n          return;\n        }\n        /**\n         * @type {Asset[\"source\"] | undefined}\n         */\n\n\n        let source;\n\n        if (cacheEntry) {\n          logger.debug(`found cache for '${absoluteFilename}'...`);\n          let isValidSnapshot;\n          logger.debug(`checking snapshot on valid for '${absoluteFilename}'...`);\n\n          try {\n            isValidSnapshot = await CopyPlugin.checkSnapshotValid(compilation, cacheEntry.snapshot);\n          } catch (error) {\n            compilation.errors.push(\n            /** @type {WebpackError} */\n            error);\n            return;\n          }\n\n          if (isValidSnapshot) {\n            logger.debug(`snapshot for '${absoluteFilename}' is valid`);\n            ({\n              source\n            } = cacheEntry);\n          } else {\n            logger.debug(`snapshot for '${absoluteFilename}' is invalid`);\n          }\n        } else {\n          logger.debug(`missed cache for '${absoluteFilename}'`);\n        }\n\n        if (!source) {\n          const startTime = Date.now();\n          logger.debug(`reading '${absoluteFilename}'...`);\n          let data;\n\n          try {\n            data = await readFile(inputFileSystem, absoluteFilename);\n          } catch (error) {\n            compilation.errors.push(\n            /** @type {WebpackError} */\n            error);\n            return;\n          }\n\n          logger.debug(`read '${absoluteFilename}'`);\n          source = new RawSource(data);\n          let snapshot;\n          logger.debug(`creating snapshot for '${absoluteFilename}'...`);\n\n          try {\n            snapshot = await CopyPlugin.createSnapshot(compilation, startTime, absoluteFilename);\n          } catch (error) {\n            compilation.errors.push(\n            /** @type {WebpackError} */\n            error);\n            return;\n          }\n\n          if (snapshot) {\n            logger.debug(`created snapshot for '${absoluteFilename}'`);\n            logger.debug(`storing cache for '${absoluteFilename}'...`);\n\n            try {\n              await cache.storePromise(`${sourceFilename}|${index}`, null, {\n                source,\n                snapshot\n              });\n            } catch (error) {\n              compilation.errors.push(\n              /** @type {WebpackError} */\n              error);\n              return;\n            }\n\n            logger.debug(`stored cache for '${absoluteFilename}'`);\n          }\n        }\n\n        if (pattern.transform) {\n          /**\n           * @type {TransformerObject}\n           */\n          const transformObj = typeof pattern.transform === \"function\" ? {\n            transformer: pattern.transform\n          } : pattern.transform;\n\n          if (transformObj.transformer) {\n            logger.log(`transforming content for '${absoluteFilename}'...`);\n            const buffer = source.buffer();\n\n            if (transformObj.cache) {\n              // TODO: remove in the next major release\n              const hasher = compiler.webpack && compiler.webpack.util && compiler.webpack.util.createHash ? compiler.webpack.util.createHash(\"xxhash64\") : // eslint-disable-next-line global-require\n              require(\"crypto\").createHash(\"md4\");\n              const defaultCacheKeys = {\n                version,\n                sourceFilename,\n                transform: transformObj.transformer,\n                contentHash: hasher.update(buffer).digest(\"hex\"),\n                index\n              };\n              const cacheKeys = `transform|${serialize(typeof transformObj.cache === \"boolean\" ? defaultCacheKeys : typeof transformObj.cache.keys === \"function\" ? await transformObj.cache.keys(defaultCacheKeys, absoluteFilename) : { ...defaultCacheKeys,\n                ...transformObj.cache.keys\n              })}`;\n              logger.debug(`getting transformation cache for '${absoluteFilename}'...`);\n              const cacheItem = cache.getItemCache(cacheKeys, cache.getLazyHashedEtag(source));\n              source = await cacheItem.getPromise();\n              logger.debug(source ? `found transformation cache for '${absoluteFilename}'` : `no transformation cache for '${absoluteFilename}'`);\n\n              if (!source) {\n                const transformed = await transformObj.transformer(buffer, absoluteFilename);\n                source = new RawSource(transformed);\n                logger.debug(`caching transformation for '${absoluteFilename}'...`);\n                await cacheItem.storePromise(source);\n                logger.debug(`cached transformation for '${absoluteFilename}'`);\n              }\n            } else {\n              source = new RawSource(await transformObj.transformer(buffer, absoluteFilename));\n            }\n          }\n        }\n\n        let info = typeof pattern.info === \"undefined\" ? {} : typeof pattern.info === \"function\" ? pattern.info({\n          absoluteFilename,\n          sourceFilename,\n          filename,\n          toType\n        }) || {} : pattern.info || {};\n\n        if (toType === \"template\") {\n          logger.log(`interpolating template '${filename}' for '${sourceFilename}'...`);\n          const contentHash = CopyPlugin.getContentHash(compiler, compilation, source.buffer());\n          const ext = path.extname(sourceFilename);\n          const base = path.basename(sourceFilename);\n          const name = base.slice(0, base.length - ext.length);\n          const data = {\n            filename: normalizePath(path.relative(pattern.context, absoluteFilename)),\n            contentHash,\n            chunk: {\n              name,\n              id:\n              /** @type {string} */\n              sourceFilename,\n              hash: contentHash\n            }\n          };\n          const {\n            path: interpolatedFilename,\n            info: assetInfo\n          } = compilation.getPathWithInfo(normalizePath(filename), data);\n          info = { ...info,\n            ...assetInfo\n          };\n          filename = interpolatedFilename;\n          logger.log(`interpolated template '${filename}' for '${sourceFilename}'`);\n        } else {\n          filename = normalizePath(filename);\n        } // eslint-disable-next-line consistent-return\n\n\n        return {\n          sourceFilename,\n          absoluteFilename,\n          filename,\n          source,\n          info,\n          force: pattern.force\n        };\n      }));\n    } catch (error) {\n      compilation.errors.push(\n      /** @type {WebpackError} */\n      error);\n      return;\n    }\n\n    if (copiedResult.length === 0) {\n      if (pattern.noErrorOnMissing) {\n        logger.log(`finished to process a pattern from '${normalizedOriginalFrom}' using '${pattern.context}' context to '${pattern.to}'`);\n        return;\n      }\n\n      const missingError = new Error(`unable to locate '${glob}' glob after filtering paths`);\n      compilation.errors.push(\n      /** @type {WebpackError} */\n      missingError);\n      return;\n    }\n\n    logger.log(`finished to process a pattern from '${normalizedOriginalFrom}' using '${pattern.context}' context`); // eslint-disable-next-line consistent-return\n\n    return copiedResult;\n  }\n  /**\n   * @param {Compiler} compiler\n   */\n\n\n  apply(compiler) {\n    const pluginName = this.constructor.name;\n    compiler.hooks.thisCompilation.tap(pluginName, compilation => {\n      const logger = compilation.getLogger(\"copy-webpack-plugin\");\n      const cache = compilation.getCache(\"CopyWebpackPlugin\");\n      /**\n       * @type {typeof import(\"globby\").globby}\n       */\n\n      let globby;\n      compilation.hooks.processAssets.tapAsync({\n        name: \"copy-webpack-plugin\",\n        stage: compiler.webpack.Compilation.PROCESS_ASSETS_STAGE_ADDITIONAL\n      }, async (unusedAssets, callback) => {\n        if (typeof globby === \"undefined\") {\n          try {\n            // @ts-ignore\n            ({\n              globby\n            } = await import(\"globby\"));\n          } catch (error) {\n            callback(\n            /** @type {Error} */\n            error);\n            return;\n          }\n        }\n\n        logger.log(\"starting to add additional assets...\");\n        const copiedResultMap = new Map();\n        /**\n         * @type {(() => Promise<void>)[]}\n         */\n\n        const scheduledTasks = [];\n        this.patterns.map(\n        /**\n         * @param {Pattern} item\n         * @param {number} index\n         * @return {number}\n         */\n        (item, index) => scheduledTasks.push(async () => {\n          /**\n           * @type {ObjectPattern}\n           */\n          const normalizedPattern = typeof item === \"string\" ? {\n            from: item\n          } : { ...item\n          };\n          const context = typeof normalizedPattern.context === \"undefined\" ? compiler.context : path.isAbsolute(normalizedPattern.context) ? normalizedPattern.context : path.join(compiler.context, normalizedPattern.context);\n          normalizedPattern.context = context;\n          /**\n           * @type {Array<CopiedResult | undefined> | undefined}\n           */\n\n          let copiedResult;\n\n          try {\n            copiedResult = await CopyPlugin.runPattern(globby, compiler, compilation, logger, cache,\n            /** @type {ObjectPattern & { context: string }} */\n            normalizedPattern, index);\n          } catch (error) {\n            compilation.errors.push(\n            /** @type {WebpackError} */\n            error);\n            return;\n          }\n\n          if (!copiedResult) {\n            return;\n          }\n          /**\n           * @type {Array<CopiedResult>}\n           */\n\n\n          let filteredCopiedResult = copiedResult.filter(\n          /**\n           * @param {CopiedResult | undefined} result\n           * @returns {result is CopiedResult}\n           */\n          result => Boolean(result));\n\n          if (typeof normalizedPattern.transformAll !== \"undefined\") {\n            if (typeof normalizedPattern.to === \"undefined\") {\n              compilation.errors.push(\n              /** @type {WebpackError} */\n              new Error(`Invalid \"pattern.to\" for the \"pattern.from\": \"${normalizedPattern.from}\" and \"pattern.transformAll\" function. The \"to\" option must be specified.`));\n              return;\n            }\n\n            filteredCopiedResult.sort((a, b) => a.absoluteFilename > b.absoluteFilename ? 1 : a.absoluteFilename < b.absoluteFilename ? -1 : 0);\n            const mergedEtag = filteredCopiedResult.length === 1 ? cache.getLazyHashedEtag(filteredCopiedResult[0].source) : filteredCopiedResult.reduce(\n            /**\n             * @param {Etag} accumulator\n             * @param {CopiedResult} asset\n             * @param {number} i\n             * @return {Etag}\n             */\n            // @ts-ignore\n            (accumulator, asset, i) => {\n              // eslint-disable-next-line no-param-reassign\n              accumulator = cache.mergeEtags(i === 1 ? cache.getLazyHashedEtag(\n              /** @type {CopiedResult}*/\n              accumulator.source) : accumulator, cache.getLazyHashedEtag(asset.source));\n              return accumulator;\n            });\n            const cacheItem = cache.getItemCache(`transformAll|${serialize({\n              version,\n              from: normalizedPattern.from,\n              to: normalizedPattern.to,\n              transformAll: normalizedPattern.transformAll\n            })}`, mergedEtag);\n            let transformedAsset = await cacheItem.getPromise();\n\n            if (!transformedAsset) {\n              transformedAsset = {\n                filename: normalizedPattern.to\n              };\n\n              try {\n                transformedAsset.data = await normalizedPattern.transformAll(filteredCopiedResult.map(asset => {\n                  return {\n                    data: asset.source.buffer(),\n                    sourceFilename: asset.sourceFilename,\n                    absoluteFilename: asset.absoluteFilename\n                  };\n                }));\n              } catch (error) {\n                compilation.errors.push(\n                /** @type {WebpackError} */\n                error);\n                return;\n              }\n\n              const filename = typeof normalizedPattern.to === \"function\" ? await normalizedPattern.to({\n                context\n              }) : normalizedPattern.to;\n\n              if (template.test(filename)) {\n                const contentHash = CopyPlugin.getContentHash(compiler, compilation, transformedAsset.data);\n                const {\n                  path: interpolatedFilename,\n                  info: assetInfo\n                } = compilation.getPathWithInfo(normalizePath(filename), {\n                  contentHash,\n                  chunk: {\n                    id: \"unknown-copied-asset\",\n                    hash: contentHash\n                  }\n                });\n                transformedAsset.filename = interpolatedFilename;\n                transformedAsset.info = assetInfo;\n              }\n\n              const {\n                RawSource\n              } = compiler.webpack.sources;\n              transformedAsset.source = new RawSource(transformedAsset.data);\n              transformedAsset.force = normalizedPattern.force;\n              await cacheItem.storePromise(transformedAsset);\n            }\n\n            filteredCopiedResult = [transformedAsset];\n          }\n\n          const priority = normalizedPattern.priority || 0;\n\n          if (!copiedResultMap.has(priority)) {\n            copiedResultMap.set(priority, []);\n          }\n\n          copiedResultMap.get(priority).push(...filteredCopiedResult);\n        }));\n        await throttleAll(this.options.concurrency || 100, scheduledTasks);\n        const copiedResult = [...copiedResultMap.entries()].sort((a, b) => a[0] - b[0]); // Avoid writing assets inside `p-limit`, because it creates concurrency.\n        // It could potentially lead to an error - 'Multiple assets emit different content to the same filename'\n\n        copiedResult.reduce((acc, val) => acc.concat(val[1]), []).filter(Boolean).forEach(\n        /**\n         * @param {CopiedResult} result\n         * @returns {void}\n         */\n        result => {\n          const {\n            absoluteFilename,\n            sourceFilename,\n            filename,\n            source,\n            force\n          } = result;\n          const existingAsset = compilation.getAsset(filename);\n\n          if (existingAsset) {\n            if (force) {\n              const info = {\n                copied: true,\n                sourceFilename\n              };\n              logger.log(`force updating '${filename}' from '${absoluteFilename}' to compilation assets, because it already exists...`);\n              compilation.updateAsset(filename, source, { ...info,\n                ...result.info\n              });\n              logger.log(`force updated '${filename}' from '${absoluteFilename}' to compilation assets, because it already exists`);\n              return;\n            }\n\n            logger.log(`skip adding '${filename}' from '${absoluteFilename}' to compilation assets, because it already exists`);\n            return;\n          }\n\n          const info = {\n            copied: true,\n            sourceFilename\n          };\n          logger.log(`writing '${filename}' from '${absoluteFilename}' to compilation assets...`);\n          compilation.emitAsset(filename, source, { ...info,\n            ...result.info\n          });\n          logger.log(`written '${filename}' from '${absoluteFilename}' to compilation assets`);\n        });\n        logger.log(\"finished to adding additional assets\");\n        callback();\n      });\n\n      if (compilation.hooks.statsPrinter) {\n        compilation.hooks.statsPrinter.tap(pluginName, stats => {\n          stats.hooks.print.for(\"asset.info.copied\").tap(\"copy-webpack-plugin\", (copied, {\n            green,\n            formatFlag\n          }) => copied ?\n          /** @type {Function} */\n          green(\n          /** @type {Function} */\n          formatFlag(\"copied\")) : \"\");\n        });\n      }\n    });\n  }\n\n}\n\nmodule.exports = CopyPlugin;"],"mappings":"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"},"metadata":{},"sourceType":"script"}