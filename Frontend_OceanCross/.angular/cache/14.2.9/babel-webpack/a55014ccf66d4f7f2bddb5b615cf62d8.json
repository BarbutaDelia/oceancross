{"ast":null,"code":"\"use strict\";\n/**\n * Copyright (c) 2015-present, Waysact Pty Ltd\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getChunkToManifestMap = exports.buildTopologicallySortedChunkGraph = exports.generateSriHashPlaceholders = exports.notNil = exports.findChunks = exports.makePlaceholder = exports.computeIntegrity = exports.placeholderPrefix = exports.normalizePath = exports.getTagSrc = exports.assert = exports.sriHashVariableReference = void 0;\n\nconst crypto_1 = require(\"crypto\");\n\nconst path_1 = require(\"path\");\n\nexports.sriHashVariableReference = \"__webpack_require__.sriHashes\";\n\nfunction assert(value, message) {\n  if (!value) {\n    throw new Error(message);\n  }\n}\n\nexports.assert = assert;\n\nfunction getTagSrc(tag) {\n  if (![\"script\", \"link\"].includes(tag.tagName) || !tag.attributes) {\n    return undefined;\n  }\n\n  if (typeof tag.attributes.href === \"string\") {\n    return tag.attributes.href;\n  }\n\n  if (typeof tag.attributes.src === \"string\") {\n    return tag.attributes.src;\n  }\n\n  return undefined;\n}\n\nexports.getTagSrc = getTagSrc;\n\nconst normalizePath = p => p.replace(/\\?.*$/, \"\").split(path_1.sep).join(\"/\");\n\nexports.normalizePath = normalizePath;\nexports.placeholderPrefix = \"*-*-*-CHUNK-SRI-HASH-\";\n\nconst computeIntegrity = (hashFuncNames, source) => {\n  const result = hashFuncNames.map(hashFuncName => hashFuncName + \"-\" + crypto_1.createHash(hashFuncName).update(typeof source === \"string\" ? Buffer.from(source, \"utf-8\") : source).digest(\"base64\")).join(\" \");\n  return result;\n};\n\nexports.computeIntegrity = computeIntegrity;\n\nconst makePlaceholder = (hashFuncNames, id) => {\n  const placeholder = `${exports.placeholderPrefix}${id}`;\n  const filler = exports.computeIntegrity(hashFuncNames, placeholder);\n  return exports.placeholderPrefix + filler.substring(exports.placeholderPrefix.length);\n};\n\nexports.makePlaceholder = makePlaceholder;\n\nfunction findChunks(chunk) {\n  const allChunks = new Set();\n  const groupsVisited = new Set();\n\n  function addIfNotExist(set, item) {\n    if (set.has(item)) return true;\n    set.add(item);\n    return false;\n  }\n\n  (function recurseChunk(childChunk) {\n    function recurseGroup(group) {\n      if (addIfNotExist(groupsVisited, group.id)) return;\n      group.chunks.forEach(recurseChunk);\n      group.childrenIterable.forEach(recurseGroup);\n    }\n\n    if (addIfNotExist(allChunks, childChunk)) return;\n    Array.from(childChunk.groupsIterable).forEach(recurseGroup);\n  })(chunk);\n\n  return allChunks;\n}\n\nexports.findChunks = findChunks;\n\nfunction notNil(value) {\n  return value !== null && value !== undefined;\n}\n\nexports.notNil = notNil;\n\nfunction generateSriHashPlaceholders(chunks, hashFuncNames) {\n  return Array.from(chunks).reduce((sriHashes, depChunk) => {\n    if (depChunk.id) {\n      sriHashes[depChunk.id] = exports.makePlaceholder(hashFuncNames, depChunk.id);\n    }\n\n    return sriHashes;\n  }, {});\n}\n\nexports.generateSriHashPlaceholders = generateSriHashPlaceholders;\n\nfunction* intersect(sets) {\n  const {\n    value: initialSet\n  } = sets[Symbol.iterator]().next();\n\n  if (!initialSet) {\n    return;\n  }\n\n  initialSetLoop: for (const item of initialSet) {\n    for (const set of sets) {\n      if (!set.has(item)) {\n        continue initialSetLoop;\n      }\n    }\n\n    yield item;\n  }\n}\n\nfunction* map(items, fn) {\n  for (const item of items) {\n    yield fn(item);\n  }\n}\n\nfunction* flatMap(collections, fn) {\n  for (const item of collections) {\n    for (const result of fn(item)) {\n      yield result;\n    }\n  }\n}\n/**\n * Tarjan's strongly connected components algorithm\n * https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm\n */\n\n\nfunction createDAGfromGraph({\n  vertices,\n  edges\n}) {\n  var _a;\n\n  let index = 0;\n  const stack = [];\n  const vertexMetadata = new Map(map(vertices, vertex => [vertex, {}]));\n  const stronglyConnectedComponents = new Set();\n\n  function strongConnect(vertex) {\n    var _a, _b; // Set the depth index for v to the smallest unused index\n\n\n    const vertexData = vertexMetadata.get(vertex);\n    assert(vertexData, \"Vertex metadata missing\");\n    vertexData.index = index;\n    vertexData.lowlink = index;\n    index++;\n    stack.push(vertex);\n    vertexData.onstack = true;\n\n    for (const child of (_a = edges.get(vertex)) !== null && _a !== void 0 ? _a : []) {\n      const childData = vertexMetadata.get(child);\n      assert(childData, \"Child vertex metadata missing\");\n\n      if (childData.index === undefined) {\n        // Child has not yet been visited; recurse on it\n        strongConnect(child);\n        vertexData.lowlink = Math.min(vertexData.lowlink, (_b = childData.lowlink) !== null && _b !== void 0 ? _b : Infinity);\n      } else if (childData.onstack) {\n        // Child is in stack and hence in the current SCC\n        // If child is not on stack, then (vertex, child) is an edge pointing to an SCC already found and must be ignored\n        // Note: The next line may look odd - but is correct.\n        // It says childData.index not childData.lowlink; that is deliberate and from the original paper\n        vertexData.lowlink = Math.min(vertexData.lowlink, childData.index);\n      }\n    } // If vertex is a root node, pop the stack and generate an SCC\n\n\n    if (vertexData.index === vertexData.lowlink) {\n      const newStronglyConnectedComponent = {\n        nodes: new Set()\n      };\n      let currentNode;\n\n      do {\n        currentNode = stack.pop();\n        assert(currentNode, \"Working stack was empty\");\n        const metadata = vertexMetadata.get(currentNode);\n        assert(metadata, \"All nodes on stack should have metadata\");\n        metadata.onstack = false;\n        newStronglyConnectedComponent.nodes.add(currentNode);\n      } while (currentNode !== vertex);\n\n      stronglyConnectedComponents.add(newStronglyConnectedComponent);\n    }\n  }\n\n  for (const vertex of vertices) {\n    const data = vertexMetadata.get(vertex);\n    assert(data, \"Vertex metadata not found\");\n\n    if (data.index === undefined) {\n      strongConnect(vertex);\n    }\n  } // Now that all SCCs have been identified, rebuild the graph\n\n\n  const vertexToSCCMap = new Map();\n  const sccEdges = new Map();\n\n  for (const scc of stronglyConnectedComponents) {\n    for (const vertex of scc.nodes) {\n      vertexToSCCMap.set(vertex, scc);\n    }\n  }\n\n  for (const scc of stronglyConnectedComponents) {\n    const childSCCNodes = new Set();\n\n    for (const vertex of scc.nodes) {\n      for (const childVertex of (_a = edges.get(vertex)) !== null && _a !== void 0 ? _a : []) {\n        const childScc = vertexToSCCMap.get(childVertex);\n\n        if (childScc && childScc !== scc) {\n          childSCCNodes.add(childScc);\n        }\n      }\n    }\n\n    sccEdges.set(scc, childSCCNodes);\n  }\n\n  return {\n    vertices: stronglyConnectedComponents,\n    edges: sccEdges\n  };\n} // This implementation assumes a directed acyclic graph (such as one produced by createDAGfromGraph),\n// and does not attempt to detect cycles\n\n\nfunction topologicalSort({\n  vertices,\n  edges\n}) {\n  const sortedItems = [];\n  const seenNodes = new Set();\n\n  function visit(node) {\n    var _a;\n\n    if (seenNodes.has(node)) {\n      return;\n    }\n\n    seenNodes.add(node);\n\n    for (const child of (_a = edges.get(node)) !== null && _a !== void 0 ? _a : []) {\n      visit(child);\n    }\n\n    sortedItems.push(node);\n  }\n\n  for (const vertex of vertices) {\n    visit(vertex);\n  }\n\n  return sortedItems;\n}\n\nfunction buildTopologicallySortedChunkGraph(chunks) {\n  var _a;\n\n  const vertices = new Set();\n  const edges = new Map(); // Chunks should have *all* chunks, not simply entry chunks\n\n  for (const vertex of chunks) {\n    if (vertices.has(vertex)) {\n      continue;\n    }\n\n    vertices.add(vertex);\n    edges.set(vertex, new Set());\n\n    for (const vertexGroup of vertex.groupsIterable) {\n      for (const childGroup of vertexGroup.childrenIterable) {\n        for (const childChunk of childGroup.chunks) {\n          (_a = edges.get(vertex)) === null || _a === void 0 ? void 0 : _a.add(childChunk);\n        }\n      }\n    }\n  }\n\n  const dag = createDAGfromGraph({\n    vertices,\n    edges\n  });\n  const sortedVertices = topologicalSort(dag);\n  const chunkToSccMap = new Map(flatMap(dag.vertices, scc => map(scc.nodes, chunk => [chunk, scc])));\n  return [sortedVertices, dag, chunkToSccMap];\n}\n\nexports.buildTopologicallySortedChunkGraph = buildTopologicallySortedChunkGraph;\n\nfunction getChunkToManifestMap(chunks) {\n  var _a;\n\n  const [sortedVertices,, chunkToSccMap] = buildTopologicallySortedChunkGraph(chunks); // This map tracks which hashes a chunk group has in its manifest and the intersection\n  // of all its parents (and intersection of all their parents, etc.)\n  // This is meant as a guarantee that the hash for a given chunk is handled by a chunk group\n  // or its parents regardless of the tree traversal used from the roots\n\n  const hashesByChunkGroupAndParents = new Map(); // A map of what child chunks a given chunk should contain hashes for\n\n  const chunkManifest = new Map();\n\n  function intersectSets(setsToIntersect) {\n    return new Set(intersect(setsToIntersect));\n  }\n\n  function findIntersectionOfParentSets(chunk) {\n    var _a;\n\n    const setsToIntersect = [];\n\n    for (const group of chunk.groupsIterable) {\n      for (const parent of group.parentsIterable) {\n        setsToIntersect.push((_a = hashesByChunkGroupAndParents.get(parent)) !== null && _a !== void 0 ? _a : new Set());\n      }\n    }\n\n    return intersectSets(setsToIntersect);\n  }\n\n  function getChildChunksToAddToChunkManifest(chunk) {\n    var _a;\n\n    const childChunks = new Set();\n    const chunkSCC = chunkToSccMap.get(chunk);\n\n    for (const chunkGroup of chunk.groupsIterable) {\n      if (chunkGroup.chunks[chunkGroup.chunks.length - 1] !== chunk) {\n        // Only add sri hashes for one chunk per chunk group,\n        // where the last chunk in the group is the primary chunk\n        continue;\n      }\n\n      for (const childGroup of chunkGroup.childrenIterable) {\n        for (const childChunk of childGroup.chunks) {\n          const childChunkSCC = chunkToSccMap.get(childChunk);\n\n          if (childChunkSCC === chunkSCC) {\n            // Don't include your own SCC.\n            // Your parent will have the hashes for your SCC siblings\n            continue;\n          }\n\n          for (const childChunkSccNode of (_a = childChunkSCC === null || childChunkSCC === void 0 ? void 0 : childChunkSCC.nodes) !== null && _a !== void 0 ? _a : []) {\n            childChunks.add(childChunkSccNode);\n          }\n        }\n      }\n    }\n\n    const parentManifest = findIntersectionOfParentSets(chunk);\n\n    for (const manifestEntry of parentManifest) {\n      childChunks.delete(manifestEntry);\n    }\n\n    return childChunks;\n  } // We want to walk from the root nodes down to the leaves\n\n\n  for (let i = sortedVertices.length - 1; i >= 0; i--) {\n    const scc = sortedVertices[i];\n\n    for (const chunk of scc.nodes) {\n      const manifest = getChildChunksToAddToChunkManifest(chunk);\n      const combinedParentManifest = findIntersectionOfParentSets(chunk);\n\n      for (const chunk of manifest) {\n        if (combinedParentManifest.has(chunk)) {\n          manifest.delete(chunk);\n        } else {\n          combinedParentManifest.add(chunk);\n        }\n      }\n\n      chunkManifest.set(chunk, manifest);\n\n      for (const group of chunk.groupsIterable) {\n        // Get intersection of all parent manifests\n        const groupCombinedManifest = intersectSets(map(group.parentsIterable, parent => {\n          var _a;\n\n          return (_a = hashesByChunkGroupAndParents.get(parent)) !== null && _a !== void 0 ? _a : new Set();\n        })); // Add this chunk's manifest\n\n        for (const chunk of manifest) {\n          groupCombinedManifest.add(chunk);\n        } // Add any existing manifests part of the group\n\n\n        for (const chunk of (_a = hashesByChunkGroupAndParents.get(group)) !== null && _a !== void 0 ? _a : new Set()) {\n          groupCombinedManifest.add(chunk);\n        }\n\n        hashesByChunkGroupAndParents.set(group, groupCombinedManifest);\n      }\n    }\n  }\n\n  return [sortedVertices, chunkManifest];\n}\n\nexports.getChunkToManifestMap = getChunkToManifestMap;","map":{"version":3,"names":["Object","defineProperty","exports","value","getChunkToManifestMap","buildTopologicallySortedChunkGraph","generateSriHashPlaceholders","notNil","findChunks","makePlaceholder","computeIntegrity","placeholderPrefix","normalizePath","getTagSrc","assert","sriHashVariableReference","crypto_1","require","path_1","message","Error","tag","includes","tagName","attributes","undefined","href","src","p","replace","split","sep","join","hashFuncNames","source","result","map","hashFuncName","createHash","update","Buffer","from","digest","id","placeholder","filler","substring","length","chunk","allChunks","Set","groupsVisited","addIfNotExist","set","item","has","add","recurseChunk","childChunk","recurseGroup","group","chunks","forEach","childrenIterable","Array","groupsIterable","reduce","sriHashes","depChunk","intersect","sets","initialSet","Symbol","iterator","next","initialSetLoop","items","fn","flatMap","collections","createDAGfromGraph","vertices","edges","_a","index","stack","vertexMetadata","Map","vertex","stronglyConnectedComponents","strongConnect","_b","vertexData","get","lowlink","push","onstack","child","childData","Math","min","Infinity","newStronglyConnectedComponent","nodes","currentNode","pop","metadata","data","vertexToSCCMap","sccEdges","scc","childSCCNodes","childVertex","childScc","topologicalSort","sortedItems","seenNodes","visit","node","vertexGroup","childGroup","dag","sortedVertices","chunkToSccMap","hashesByChunkGroupAndParents","chunkManifest","intersectSets","setsToIntersect","findIntersectionOfParentSets","parent","parentsIterable","getChildChunksToAddToChunkManifest","childChunks","chunkSCC","chunkGroup","childChunkSCC","childChunkSccNode","parentManifest","manifestEntry","delete","i","manifest","combinedParentManifest","groupCombinedManifest"],"sources":["/Users/deliabarbuta/Documents/An4Sem1/PAW/Proiect/proiect-paw-tadam/Frontend_OceanCross/node_modules/webpack-subresource-integrity/util.js"],"sourcesContent":["\"use strict\";\n/**\n * Copyright (c) 2015-present, Waysact Pty Ltd\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getChunkToManifestMap = exports.buildTopologicallySortedChunkGraph = exports.generateSriHashPlaceholders = exports.notNil = exports.findChunks = exports.makePlaceholder = exports.computeIntegrity = exports.placeholderPrefix = exports.normalizePath = exports.getTagSrc = exports.assert = exports.sriHashVariableReference = void 0;\nconst crypto_1 = require(\"crypto\");\nconst path_1 = require(\"path\");\nexports.sriHashVariableReference = \"__webpack_require__.sriHashes\";\nfunction assert(value, message) {\n    if (!value) {\n        throw new Error(message);\n    }\n}\nexports.assert = assert;\nfunction getTagSrc(tag) {\n    if (![\"script\", \"link\"].includes(tag.tagName) || !tag.attributes) {\n        return undefined;\n    }\n    if (typeof tag.attributes.href === \"string\") {\n        return tag.attributes.href;\n    }\n    if (typeof tag.attributes.src === \"string\") {\n        return tag.attributes.src;\n    }\n    return undefined;\n}\nexports.getTagSrc = getTagSrc;\nconst normalizePath = (p) => p.replace(/\\?.*$/, \"\").split(path_1.sep).join(\"/\");\nexports.normalizePath = normalizePath;\nexports.placeholderPrefix = \"*-*-*-CHUNK-SRI-HASH-\";\nconst computeIntegrity = (hashFuncNames, source) => {\n    const result = hashFuncNames\n        .map((hashFuncName) => hashFuncName +\n        \"-\" +\n        crypto_1.createHash(hashFuncName)\n            .update(typeof source === \"string\" ? Buffer.from(source, \"utf-8\") : source)\n            .digest(\"base64\"))\n        .join(\" \");\n    return result;\n};\nexports.computeIntegrity = computeIntegrity;\nconst makePlaceholder = (hashFuncNames, id) => {\n    const placeholder = `${exports.placeholderPrefix}${id}`;\n    const filler = exports.computeIntegrity(hashFuncNames, placeholder);\n    return exports.placeholderPrefix + filler.substring(exports.placeholderPrefix.length);\n};\nexports.makePlaceholder = makePlaceholder;\nfunction findChunks(chunk) {\n    const allChunks = new Set();\n    const groupsVisited = new Set();\n    function addIfNotExist(set, item) {\n        if (set.has(item))\n            return true;\n        set.add(item);\n        return false;\n    }\n    (function recurseChunk(childChunk) {\n        function recurseGroup(group) {\n            if (addIfNotExist(groupsVisited, group.id))\n                return;\n            group.chunks.forEach(recurseChunk);\n            group.childrenIterable.forEach(recurseGroup);\n        }\n        if (addIfNotExist(allChunks, childChunk))\n            return;\n        Array.from(childChunk.groupsIterable).forEach(recurseGroup);\n    })(chunk);\n    return allChunks;\n}\nexports.findChunks = findChunks;\nfunction notNil(value) {\n    return value !== null && value !== undefined;\n}\nexports.notNil = notNil;\nfunction generateSriHashPlaceholders(chunks, hashFuncNames) {\n    return Array.from(chunks).reduce((sriHashes, depChunk) => {\n        if (depChunk.id) {\n            sriHashes[depChunk.id] = exports.makePlaceholder(hashFuncNames, depChunk.id);\n        }\n        return sriHashes;\n    }, {});\n}\nexports.generateSriHashPlaceholders = generateSriHashPlaceholders;\nfunction* intersect(sets) {\n    const { value: initialSet } = sets[Symbol.iterator]().next();\n    if (!initialSet) {\n        return;\n    }\n    initialSetLoop: for (const item of initialSet) {\n        for (const set of sets) {\n            if (!set.has(item)) {\n                continue initialSetLoop;\n            }\n        }\n        yield item;\n    }\n}\nfunction* map(items, fn) {\n    for (const item of items) {\n        yield fn(item);\n    }\n}\nfunction* flatMap(collections, fn) {\n    for (const item of collections) {\n        for (const result of fn(item)) {\n            yield result;\n        }\n    }\n}\n/**\n * Tarjan's strongly connected components algorithm\n * https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm\n */\nfunction createDAGfromGraph({ vertices, edges, }) {\n    var _a;\n    let index = 0;\n    const stack = [];\n    const vertexMetadata = new Map(map(vertices, (vertex) => [vertex, {}]));\n    const stronglyConnectedComponents = new Set();\n    function strongConnect(vertex) {\n        var _a, _b;\n        // Set the depth index for v to the smallest unused index\n        const vertexData = vertexMetadata.get(vertex);\n        assert(vertexData, \"Vertex metadata missing\");\n        vertexData.index = index;\n        vertexData.lowlink = index;\n        index++;\n        stack.push(vertex);\n        vertexData.onstack = true;\n        for (const child of (_a = edges.get(vertex)) !== null && _a !== void 0 ? _a : []) {\n            const childData = vertexMetadata.get(child);\n            assert(childData, \"Child vertex metadata missing\");\n            if (childData.index === undefined) {\n                // Child has not yet been visited; recurse on it\n                strongConnect(child);\n                vertexData.lowlink = Math.min(vertexData.lowlink, (_b = childData.lowlink) !== null && _b !== void 0 ? _b : Infinity);\n            }\n            else if (childData.onstack) {\n                // Child is in stack and hence in the current SCC\n                // If child is not on stack, then (vertex, child) is an edge pointing to an SCC already found and must be ignored\n                // Note: The next line may look odd - but is correct.\n                // It says childData.index not childData.lowlink; that is deliberate and from the original paper\n                vertexData.lowlink = Math.min(vertexData.lowlink, childData.index);\n            }\n        }\n        // If vertex is a root node, pop the stack and generate an SCC\n        if (vertexData.index === vertexData.lowlink) {\n            const newStronglyConnectedComponent = { nodes: new Set() };\n            let currentNode;\n            do {\n                currentNode = stack.pop();\n                assert(currentNode, \"Working stack was empty\");\n                const metadata = vertexMetadata.get(currentNode);\n                assert(metadata, \"All nodes on stack should have metadata\");\n                metadata.onstack = false;\n                newStronglyConnectedComponent.nodes.add(currentNode);\n            } while (currentNode !== vertex);\n            stronglyConnectedComponents.add(newStronglyConnectedComponent);\n        }\n    }\n    for (const vertex of vertices) {\n        const data = vertexMetadata.get(vertex);\n        assert(data, \"Vertex metadata not found\");\n        if (data.index === undefined) {\n            strongConnect(vertex);\n        }\n    }\n    // Now that all SCCs have been identified, rebuild the graph\n    const vertexToSCCMap = new Map();\n    const sccEdges = new Map();\n    for (const scc of stronglyConnectedComponents) {\n        for (const vertex of scc.nodes) {\n            vertexToSCCMap.set(vertex, scc);\n        }\n    }\n    for (const scc of stronglyConnectedComponents) {\n        const childSCCNodes = new Set();\n        for (const vertex of scc.nodes) {\n            for (const childVertex of (_a = edges.get(vertex)) !== null && _a !== void 0 ? _a : []) {\n                const childScc = vertexToSCCMap.get(childVertex);\n                if (childScc && childScc !== scc) {\n                    childSCCNodes.add(childScc);\n                }\n            }\n        }\n        sccEdges.set(scc, childSCCNodes);\n    }\n    return { vertices: stronglyConnectedComponents, edges: sccEdges };\n}\n// This implementation assumes a directed acyclic graph (such as one produced by createDAGfromGraph),\n// and does not attempt to detect cycles\nfunction topologicalSort({ vertices, edges }) {\n    const sortedItems = [];\n    const seenNodes = new Set();\n    function visit(node) {\n        var _a;\n        if (seenNodes.has(node)) {\n            return;\n        }\n        seenNodes.add(node);\n        for (const child of (_a = edges.get(node)) !== null && _a !== void 0 ? _a : []) {\n            visit(child);\n        }\n        sortedItems.push(node);\n    }\n    for (const vertex of vertices) {\n        visit(vertex);\n    }\n    return sortedItems;\n}\nfunction buildTopologicallySortedChunkGraph(chunks) {\n    var _a;\n    const vertices = new Set();\n    const edges = new Map();\n    // Chunks should have *all* chunks, not simply entry chunks\n    for (const vertex of chunks) {\n        if (vertices.has(vertex)) {\n            continue;\n        }\n        vertices.add(vertex);\n        edges.set(vertex, new Set());\n        for (const vertexGroup of vertex.groupsIterable) {\n            for (const childGroup of vertexGroup.childrenIterable) {\n                for (const childChunk of childGroup.chunks) {\n                    (_a = edges.get(vertex)) === null || _a === void 0 ? void 0 : _a.add(childChunk);\n                }\n            }\n        }\n    }\n    const dag = createDAGfromGraph({ vertices, edges });\n    const sortedVertices = topologicalSort(dag);\n    const chunkToSccMap = new Map(flatMap(dag.vertices, (scc) => map(scc.nodes, (chunk) => [chunk, scc])));\n    return [sortedVertices, dag, chunkToSccMap];\n}\nexports.buildTopologicallySortedChunkGraph = buildTopologicallySortedChunkGraph;\nfunction getChunkToManifestMap(chunks) {\n    var _a;\n    const [sortedVertices, , chunkToSccMap] = buildTopologicallySortedChunkGraph(chunks);\n    // This map tracks which hashes a chunk group has in its manifest and the intersection\n    // of all its parents (and intersection of all their parents, etc.)\n    // This is meant as a guarantee that the hash for a given chunk is handled by a chunk group\n    // or its parents regardless of the tree traversal used from the roots\n    const hashesByChunkGroupAndParents = new Map();\n    // A map of what child chunks a given chunk should contain hashes for\n    const chunkManifest = new Map();\n    function intersectSets(setsToIntersect) {\n        return new Set(intersect(setsToIntersect));\n    }\n    function findIntersectionOfParentSets(chunk) {\n        var _a;\n        const setsToIntersect = [];\n        for (const group of chunk.groupsIterable) {\n            for (const parent of group.parentsIterable) {\n                setsToIntersect.push((_a = hashesByChunkGroupAndParents.get(parent)) !== null && _a !== void 0 ? _a : new Set());\n            }\n        }\n        return intersectSets(setsToIntersect);\n    }\n    function getChildChunksToAddToChunkManifest(chunk) {\n        var _a;\n        const childChunks = new Set();\n        const chunkSCC = chunkToSccMap.get(chunk);\n        for (const chunkGroup of chunk.groupsIterable) {\n            if (chunkGroup.chunks[chunkGroup.chunks.length - 1] !== chunk) {\n                // Only add sri hashes for one chunk per chunk group,\n                // where the last chunk in the group is the primary chunk\n                continue;\n            }\n            for (const childGroup of chunkGroup.childrenIterable) {\n                for (const childChunk of childGroup.chunks) {\n                    const childChunkSCC = chunkToSccMap.get(childChunk);\n                    if (childChunkSCC === chunkSCC) {\n                        // Don't include your own SCC.\n                        // Your parent will have the hashes for your SCC siblings\n                        continue;\n                    }\n                    for (const childChunkSccNode of (_a = childChunkSCC === null || childChunkSCC === void 0 ? void 0 : childChunkSCC.nodes) !== null && _a !== void 0 ? _a : []) {\n                        childChunks.add(childChunkSccNode);\n                    }\n                }\n            }\n        }\n        const parentManifest = findIntersectionOfParentSets(chunk);\n        for (const manifestEntry of parentManifest) {\n            childChunks.delete(manifestEntry);\n        }\n        return childChunks;\n    }\n    // We want to walk from the root nodes down to the leaves\n    for (let i = sortedVertices.length - 1; i >= 0; i--) {\n        const scc = sortedVertices[i];\n        for (const chunk of scc.nodes) {\n            const manifest = getChildChunksToAddToChunkManifest(chunk);\n            const combinedParentManifest = findIntersectionOfParentSets(chunk);\n            for (const chunk of manifest) {\n                if (combinedParentManifest.has(chunk)) {\n                    manifest.delete(chunk);\n                }\n                else {\n                    combinedParentManifest.add(chunk);\n                }\n            }\n            chunkManifest.set(chunk, manifest);\n            for (const group of chunk.groupsIterable) {\n                // Get intersection of all parent manifests\n                const groupCombinedManifest = intersectSets(map(group.parentsIterable, (parent) => { var _a; return (_a = hashesByChunkGroupAndParents.get(parent)) !== null && _a !== void 0 ? _a : new Set(); }));\n                // Add this chunk's manifest\n                for (const chunk of manifest) {\n                    groupCombinedManifest.add(chunk);\n                }\n                // Add any existing manifests part of the group\n                for (const chunk of (_a = hashesByChunkGroupAndParents.get(group)) !== null && _a !== void 0 ? _a : new Set()) {\n                    groupCombinedManifest.add(chunk);\n                }\n                hashesByChunkGroupAndParents.set(group, groupCombinedManifest);\n            }\n        }\n    }\n    return [sortedVertices, chunkManifest];\n}\nexports.getChunkToManifestMap = getChunkToManifestMap;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;EAAEC,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,qBAAR,GAAgCF,OAAO,CAACG,kCAAR,GAA6CH,OAAO,CAACI,2BAAR,GAAsCJ,OAAO,CAACK,MAAR,GAAiBL,OAAO,CAACM,UAAR,GAAqBN,OAAO,CAACO,eAAR,GAA0BP,OAAO,CAACQ,gBAAR,GAA2BR,OAAO,CAACS,iBAAR,GAA4BT,OAAO,CAACU,aAAR,GAAwBV,OAAO,CAACW,SAAR,GAAoBX,OAAO,CAACY,MAAR,GAAiBZ,OAAO,CAACa,wBAAR,GAAmC,KAAK,CAA/U;;AACA,MAAMC,QAAQ,GAAGC,OAAO,CAAC,QAAD,CAAxB;;AACA,MAAMC,MAAM,GAAGD,OAAO,CAAC,MAAD,CAAtB;;AACAf,OAAO,CAACa,wBAAR,GAAmC,+BAAnC;;AACA,SAASD,MAAT,CAAgBX,KAAhB,EAAuBgB,OAAvB,EAAgC;EAC5B,IAAI,CAAChB,KAAL,EAAY;IACR,MAAM,IAAIiB,KAAJ,CAAUD,OAAV,CAAN;EACH;AACJ;;AACDjB,OAAO,CAACY,MAAR,GAAiBA,MAAjB;;AACA,SAASD,SAAT,CAAmBQ,GAAnB,EAAwB;EACpB,IAAI,CAAC,CAAC,QAAD,EAAW,MAAX,EAAmBC,QAAnB,CAA4BD,GAAG,CAACE,OAAhC,CAAD,IAA6C,CAACF,GAAG,CAACG,UAAtD,EAAkE;IAC9D,OAAOC,SAAP;EACH;;EACD,IAAI,OAAOJ,GAAG,CAACG,UAAJ,CAAeE,IAAtB,KAA+B,QAAnC,EAA6C;IACzC,OAAOL,GAAG,CAACG,UAAJ,CAAeE,IAAtB;EACH;;EACD,IAAI,OAAOL,GAAG,CAACG,UAAJ,CAAeG,GAAtB,KAA8B,QAAlC,EAA4C;IACxC,OAAON,GAAG,CAACG,UAAJ,CAAeG,GAAtB;EACH;;EACD,OAAOF,SAAP;AACH;;AACDvB,OAAO,CAACW,SAAR,GAAoBA,SAApB;;AACA,MAAMD,aAAa,GAAIgB,CAAD,IAAOA,CAAC,CAACC,OAAF,CAAU,OAAV,EAAmB,EAAnB,EAAuBC,KAAvB,CAA6BZ,MAAM,CAACa,GAApC,EAAyCC,IAAzC,CAA8C,GAA9C,CAA7B;;AACA9B,OAAO,CAACU,aAAR,GAAwBA,aAAxB;AACAV,OAAO,CAACS,iBAAR,GAA4B,uBAA5B;;AACA,MAAMD,gBAAgB,GAAG,CAACuB,aAAD,EAAgBC,MAAhB,KAA2B;EAChD,MAAMC,MAAM,GAAGF,aAAa,CACvBG,GADU,CACLC,YAAD,IAAkBA,YAAY,GACnC,GADuB,GAEvBrB,QAAQ,CAACsB,UAAT,CAAoBD,YAApB,EACKE,MADL,CACY,OAAOL,MAAP,KAAkB,QAAlB,GAA6BM,MAAM,CAACC,IAAP,CAAYP,MAAZ,EAAoB,OAApB,CAA7B,GAA4DA,MADxE,EAEKQ,MAFL,CAEY,QAFZ,CAHW,EAMVV,IANU,CAML,GANK,CAAf;EAOA,OAAOG,MAAP;AACH,CATD;;AAUAjC,OAAO,CAACQ,gBAAR,GAA2BA,gBAA3B;;AACA,MAAMD,eAAe,GAAG,CAACwB,aAAD,EAAgBU,EAAhB,KAAuB;EAC3C,MAAMC,WAAW,GAAI,GAAE1C,OAAO,CAACS,iBAAkB,GAAEgC,EAAG,EAAtD;EACA,MAAME,MAAM,GAAG3C,OAAO,CAACQ,gBAAR,CAAyBuB,aAAzB,EAAwCW,WAAxC,CAAf;EACA,OAAO1C,OAAO,CAACS,iBAAR,GAA4BkC,MAAM,CAACC,SAAP,CAAiB5C,OAAO,CAACS,iBAAR,CAA0BoC,MAA3C,CAAnC;AACH,CAJD;;AAKA7C,OAAO,CAACO,eAAR,GAA0BA,eAA1B;;AACA,SAASD,UAAT,CAAoBwC,KAApB,EAA2B;EACvB,MAAMC,SAAS,GAAG,IAAIC,GAAJ,EAAlB;EACA,MAAMC,aAAa,GAAG,IAAID,GAAJ,EAAtB;;EACA,SAASE,aAAT,CAAuBC,GAAvB,EAA4BC,IAA5B,EAAkC;IAC9B,IAAID,GAAG,CAACE,GAAJ,CAAQD,IAAR,CAAJ,EACI,OAAO,IAAP;IACJD,GAAG,CAACG,GAAJ,CAAQF,IAAR;IACA,OAAO,KAAP;EACH;;EACD,CAAC,SAASG,YAAT,CAAsBC,UAAtB,EAAkC;IAC/B,SAASC,YAAT,CAAsBC,KAAtB,EAA6B;MACzB,IAAIR,aAAa,CAACD,aAAD,EAAgBS,KAAK,CAACjB,EAAtB,CAAjB,EACI;MACJiB,KAAK,CAACC,MAAN,CAAaC,OAAb,CAAqBL,YAArB;MACAG,KAAK,CAACG,gBAAN,CAAuBD,OAAvB,CAA+BH,YAA/B;IACH;;IACD,IAAIP,aAAa,CAACH,SAAD,EAAYS,UAAZ,CAAjB,EACI;IACJM,KAAK,CAACvB,IAAN,CAAWiB,UAAU,CAACO,cAAtB,EAAsCH,OAAtC,CAA8CH,YAA9C;EACH,CAVD,EAUGX,KAVH;;EAWA,OAAOC,SAAP;AACH;;AACD/C,OAAO,CAACM,UAAR,GAAqBA,UAArB;;AACA,SAASD,MAAT,CAAgBJ,KAAhB,EAAuB;EACnB,OAAOA,KAAK,KAAK,IAAV,IAAkBA,KAAK,KAAKsB,SAAnC;AACH;;AACDvB,OAAO,CAACK,MAAR,GAAiBA,MAAjB;;AACA,SAASD,2BAAT,CAAqCuD,MAArC,EAA6C5B,aAA7C,EAA4D;EACxD,OAAO+B,KAAK,CAACvB,IAAN,CAAWoB,MAAX,EAAmBK,MAAnB,CAA0B,CAACC,SAAD,EAAYC,QAAZ,KAAyB;IACtD,IAAIA,QAAQ,CAACzB,EAAb,EAAiB;MACbwB,SAAS,CAACC,QAAQ,CAACzB,EAAV,CAAT,GAAyBzC,OAAO,CAACO,eAAR,CAAwBwB,aAAxB,EAAuCmC,QAAQ,CAACzB,EAAhD,CAAzB;IACH;;IACD,OAAOwB,SAAP;EACH,CALM,EAKJ,EALI,CAAP;AAMH;;AACDjE,OAAO,CAACI,2BAAR,GAAsCA,2BAAtC;;AACA,UAAU+D,SAAV,CAAoBC,IAApB,EAA0B;EACtB,MAAM;IAAEnE,KAAK,EAAEoE;EAAT,IAAwBD,IAAI,CAACE,MAAM,CAACC,QAAR,CAAJ,GAAwBC,IAAxB,EAA9B;;EACA,IAAI,CAACH,UAAL,EAAiB;IACb;EACH;;EACDI,cAAc,EAAE,KAAK,MAAMrB,IAAX,IAAmBiB,UAAnB,EAA+B;IAC3C,KAAK,MAAMlB,GAAX,IAAkBiB,IAAlB,EAAwB;MACpB,IAAI,CAACjB,GAAG,CAACE,GAAJ,CAAQD,IAAR,CAAL,EAAoB;QAChB,SAASqB,cAAT;MACH;IACJ;;IACD,MAAMrB,IAAN;EACH;AACJ;;AACD,UAAUlB,GAAV,CAAcwC,KAAd,EAAqBC,EAArB,EAAyB;EACrB,KAAK,MAAMvB,IAAX,IAAmBsB,KAAnB,EAA0B;IACtB,MAAMC,EAAE,CAACvB,IAAD,CAAR;EACH;AACJ;;AACD,UAAUwB,OAAV,CAAkBC,WAAlB,EAA+BF,EAA/B,EAAmC;EAC/B,KAAK,MAAMvB,IAAX,IAAmByB,WAAnB,EAAgC;IAC5B,KAAK,MAAM5C,MAAX,IAAqB0C,EAAE,CAACvB,IAAD,CAAvB,EAA+B;MAC3B,MAAMnB,MAAN;IACH;EACJ;AACJ;AACD;AACA;AACA;AACA;;;AACA,SAAS6C,kBAAT,CAA4B;EAAEC,QAAF;EAAYC;AAAZ,CAA5B,EAAkD;EAC9C,IAAIC,EAAJ;;EACA,IAAIC,KAAK,GAAG,CAAZ;EACA,MAAMC,KAAK,GAAG,EAAd;EACA,MAAMC,cAAc,GAAG,IAAIC,GAAJ,CAAQnD,GAAG,CAAC6C,QAAD,EAAYO,MAAD,IAAY,CAACA,MAAD,EAAS,EAAT,CAAvB,CAAX,CAAvB;EACA,MAAMC,2BAA2B,GAAG,IAAIvC,GAAJ,EAApC;;EACA,SAASwC,aAAT,CAAuBF,MAAvB,EAA+B;IAC3B,IAAIL,EAAJ,EAAQQ,EAAR,CAD2B,CAE3B;;;IACA,MAAMC,UAAU,GAAGN,cAAc,CAACO,GAAf,CAAmBL,MAAnB,CAAnB;IACA1E,MAAM,CAAC8E,UAAD,EAAa,yBAAb,CAAN;IACAA,UAAU,CAACR,KAAX,GAAmBA,KAAnB;IACAQ,UAAU,CAACE,OAAX,GAAqBV,KAArB;IACAA,KAAK;IACLC,KAAK,CAACU,IAAN,CAAWP,MAAX;IACAI,UAAU,CAACI,OAAX,GAAqB,IAArB;;IACA,KAAK,MAAMC,KAAX,IAAoB,CAACd,EAAE,GAAGD,KAAK,CAACW,GAAN,CAAUL,MAAV,CAAN,MAA6B,IAA7B,IAAqCL,EAAE,KAAK,KAAK,CAAjD,GAAqDA,EAArD,GAA0D,EAA9E,EAAkF;MAC9E,MAAMe,SAAS,GAAGZ,cAAc,CAACO,GAAf,CAAmBI,KAAnB,CAAlB;MACAnF,MAAM,CAACoF,SAAD,EAAY,+BAAZ,CAAN;;MACA,IAAIA,SAAS,CAACd,KAAV,KAAoB3D,SAAxB,EAAmC;QAC/B;QACAiE,aAAa,CAACO,KAAD,CAAb;QACAL,UAAU,CAACE,OAAX,GAAqBK,IAAI,CAACC,GAAL,CAASR,UAAU,CAACE,OAApB,EAA6B,CAACH,EAAE,GAAGO,SAAS,CAACJ,OAAhB,MAA6B,IAA7B,IAAqCH,EAAE,KAAK,KAAK,CAAjD,GAAqDA,EAArD,GAA0DU,QAAvF,CAArB;MACH,CAJD,MAKK,IAAIH,SAAS,CAACF,OAAd,EAAuB;QACxB;QACA;QACA;QACA;QACAJ,UAAU,CAACE,OAAX,GAAqBK,IAAI,CAACC,GAAL,CAASR,UAAU,CAACE,OAApB,EAA6BI,SAAS,CAACd,KAAvC,CAArB;MACH;IACJ,CAzB0B,CA0B3B;;;IACA,IAAIQ,UAAU,CAACR,KAAX,KAAqBQ,UAAU,CAACE,OAApC,EAA6C;MACzC,MAAMQ,6BAA6B,GAAG;QAAEC,KAAK,EAAE,IAAIrD,GAAJ;MAAT,CAAtC;MACA,IAAIsD,WAAJ;;MACA,GAAG;QACCA,WAAW,GAAGnB,KAAK,CAACoB,GAAN,EAAd;QACA3F,MAAM,CAAC0F,WAAD,EAAc,yBAAd,CAAN;QACA,MAAME,QAAQ,GAAGpB,cAAc,CAACO,GAAf,CAAmBW,WAAnB,CAAjB;QACA1F,MAAM,CAAC4F,QAAD,EAAW,yCAAX,CAAN;QACAA,QAAQ,CAACV,OAAT,GAAmB,KAAnB;QACAM,6BAA6B,CAACC,KAA9B,CAAoC/C,GAApC,CAAwCgD,WAAxC;MACH,CAPD,QAOSA,WAAW,KAAKhB,MAPzB;;MAQAC,2BAA2B,CAACjC,GAA5B,CAAgC8C,6BAAhC;IACH;EACJ;;EACD,KAAK,MAAMd,MAAX,IAAqBP,QAArB,EAA+B;IAC3B,MAAM0B,IAAI,GAAGrB,cAAc,CAACO,GAAf,CAAmBL,MAAnB,CAAb;IACA1E,MAAM,CAAC6F,IAAD,EAAO,2BAAP,CAAN;;IACA,IAAIA,IAAI,CAACvB,KAAL,KAAe3D,SAAnB,EAA8B;MAC1BiE,aAAa,CAACF,MAAD,CAAb;IACH;EACJ,CArD6C,CAsD9C;;;EACA,MAAMoB,cAAc,GAAG,IAAIrB,GAAJ,EAAvB;EACA,MAAMsB,QAAQ,GAAG,IAAItB,GAAJ,EAAjB;;EACA,KAAK,MAAMuB,GAAX,IAAkBrB,2BAAlB,EAA+C;IAC3C,KAAK,MAAMD,MAAX,IAAqBsB,GAAG,CAACP,KAAzB,EAAgC;MAC5BK,cAAc,CAACvD,GAAf,CAAmBmC,MAAnB,EAA2BsB,GAA3B;IACH;EACJ;;EACD,KAAK,MAAMA,GAAX,IAAkBrB,2BAAlB,EAA+C;IAC3C,MAAMsB,aAAa,GAAG,IAAI7D,GAAJ,EAAtB;;IACA,KAAK,MAAMsC,MAAX,IAAqBsB,GAAG,CAACP,KAAzB,EAAgC;MAC5B,KAAK,MAAMS,WAAX,IAA0B,CAAC7B,EAAE,GAAGD,KAAK,CAACW,GAAN,CAAUL,MAAV,CAAN,MAA6B,IAA7B,IAAqCL,EAAE,KAAK,KAAK,CAAjD,GAAqDA,EAArD,GAA0D,EAApF,EAAwF;QACpF,MAAM8B,QAAQ,GAAGL,cAAc,CAACf,GAAf,CAAmBmB,WAAnB,CAAjB;;QACA,IAAIC,QAAQ,IAAIA,QAAQ,KAAKH,GAA7B,EAAkC;UAC9BC,aAAa,CAACvD,GAAd,CAAkByD,QAAlB;QACH;MACJ;IACJ;;IACDJ,QAAQ,CAACxD,GAAT,CAAayD,GAAb,EAAkBC,aAAlB;EACH;;EACD,OAAO;IAAE9B,QAAQ,EAAEQ,2BAAZ;IAAyCP,KAAK,EAAE2B;EAAhD,CAAP;AACH,C,CACD;AACA;;;AACA,SAASK,eAAT,CAAyB;EAAEjC,QAAF;EAAYC;AAAZ,CAAzB,EAA8C;EAC1C,MAAMiC,WAAW,GAAG,EAApB;EACA,MAAMC,SAAS,GAAG,IAAIlE,GAAJ,EAAlB;;EACA,SAASmE,KAAT,CAAeC,IAAf,EAAqB;IACjB,IAAInC,EAAJ;;IACA,IAAIiC,SAAS,CAAC7D,GAAV,CAAc+D,IAAd,CAAJ,EAAyB;MACrB;IACH;;IACDF,SAAS,CAAC5D,GAAV,CAAc8D,IAAd;;IACA,KAAK,MAAMrB,KAAX,IAAoB,CAACd,EAAE,GAAGD,KAAK,CAACW,GAAN,CAAUyB,IAAV,CAAN,MAA2B,IAA3B,IAAmCnC,EAAE,KAAK,KAAK,CAA/C,GAAmDA,EAAnD,GAAwD,EAA5E,EAAgF;MAC5EkC,KAAK,CAACpB,KAAD,CAAL;IACH;;IACDkB,WAAW,CAACpB,IAAZ,CAAiBuB,IAAjB;EACH;;EACD,KAAK,MAAM9B,MAAX,IAAqBP,QAArB,EAA+B;IAC3BoC,KAAK,CAAC7B,MAAD,CAAL;EACH;;EACD,OAAO2B,WAAP;AACH;;AACD,SAAS9G,kCAAT,CAA4CwD,MAA5C,EAAoD;EAChD,IAAIsB,EAAJ;;EACA,MAAMF,QAAQ,GAAG,IAAI/B,GAAJ,EAAjB;EACA,MAAMgC,KAAK,GAAG,IAAIK,GAAJ,EAAd,CAHgD,CAIhD;;EACA,KAAK,MAAMC,MAAX,IAAqB3B,MAArB,EAA6B;IACzB,IAAIoB,QAAQ,CAAC1B,GAAT,CAAaiC,MAAb,CAAJ,EAA0B;MACtB;IACH;;IACDP,QAAQ,CAACzB,GAAT,CAAagC,MAAb;IACAN,KAAK,CAAC7B,GAAN,CAAUmC,MAAV,EAAkB,IAAItC,GAAJ,EAAlB;;IACA,KAAK,MAAMqE,WAAX,IAA0B/B,MAAM,CAACvB,cAAjC,EAAiD;MAC7C,KAAK,MAAMuD,UAAX,IAAyBD,WAAW,CAACxD,gBAArC,EAAuD;QACnD,KAAK,MAAML,UAAX,IAAyB8D,UAAU,CAAC3D,MAApC,EAA4C;UACxC,CAACsB,EAAE,GAAGD,KAAK,CAACW,GAAN,CAAUL,MAAV,CAAN,MAA6B,IAA7B,IAAqCL,EAAE,KAAK,KAAK,CAAjD,GAAqD,KAAK,CAA1D,GAA8DA,EAAE,CAAC3B,GAAH,CAAOE,UAAP,CAA9D;QACH;MACJ;IACJ;EACJ;;EACD,MAAM+D,GAAG,GAAGzC,kBAAkB,CAAC;IAAEC,QAAF;IAAYC;EAAZ,CAAD,CAA9B;EACA,MAAMwC,cAAc,GAAGR,eAAe,CAACO,GAAD,CAAtC;EACA,MAAME,aAAa,GAAG,IAAIpC,GAAJ,CAAQT,OAAO,CAAC2C,GAAG,CAACxC,QAAL,EAAgB6B,GAAD,IAAS1E,GAAG,CAAC0E,GAAG,CAACP,KAAL,EAAavD,KAAD,IAAW,CAACA,KAAD,EAAQ8D,GAAR,CAAvB,CAA3B,CAAf,CAAtB;EACA,OAAO,CAACY,cAAD,EAAiBD,GAAjB,EAAsBE,aAAtB,CAAP;AACH;;AACDzH,OAAO,CAACG,kCAAR,GAA6CA,kCAA7C;;AACA,SAASD,qBAAT,CAA+ByD,MAA/B,EAAuC;EACnC,IAAIsB,EAAJ;;EACA,MAAM,CAACuC,cAAD,GAAmBC,aAAnB,IAAoCtH,kCAAkC,CAACwD,MAAD,CAA5E,CAFmC,CAGnC;EACA;EACA;EACA;;EACA,MAAM+D,4BAA4B,GAAG,IAAIrC,GAAJ,EAArC,CAPmC,CAQnC;;EACA,MAAMsC,aAAa,GAAG,IAAItC,GAAJ,EAAtB;;EACA,SAASuC,aAAT,CAAuBC,eAAvB,EAAwC;IACpC,OAAO,IAAI7E,GAAJ,CAAQmB,SAAS,CAAC0D,eAAD,CAAjB,CAAP;EACH;;EACD,SAASC,4BAAT,CAAsChF,KAAtC,EAA6C;IACzC,IAAImC,EAAJ;;IACA,MAAM4C,eAAe,GAAG,EAAxB;;IACA,KAAK,MAAMnE,KAAX,IAAoBZ,KAAK,CAACiB,cAA1B,EAA0C;MACtC,KAAK,MAAMgE,MAAX,IAAqBrE,KAAK,CAACsE,eAA3B,EAA4C;QACxCH,eAAe,CAAChC,IAAhB,CAAqB,CAACZ,EAAE,GAAGyC,4BAA4B,CAAC/B,GAA7B,CAAiCoC,MAAjC,CAAN,MAAoD,IAApD,IAA4D9C,EAAE,KAAK,KAAK,CAAxE,GAA4EA,EAA5E,GAAiF,IAAIjC,GAAJ,EAAtG;MACH;IACJ;;IACD,OAAO4E,aAAa,CAACC,eAAD,CAApB;EACH;;EACD,SAASI,kCAAT,CAA4CnF,KAA5C,EAAmD;IAC/C,IAAImC,EAAJ;;IACA,MAAMiD,WAAW,GAAG,IAAIlF,GAAJ,EAApB;IACA,MAAMmF,QAAQ,GAAGV,aAAa,CAAC9B,GAAd,CAAkB7C,KAAlB,CAAjB;;IACA,KAAK,MAAMsF,UAAX,IAAyBtF,KAAK,CAACiB,cAA/B,EAA+C;MAC3C,IAAIqE,UAAU,CAACzE,MAAX,CAAkByE,UAAU,CAACzE,MAAX,CAAkBd,MAAlB,GAA2B,CAA7C,MAAoDC,KAAxD,EAA+D;QAC3D;QACA;QACA;MACH;;MACD,KAAK,MAAMwE,UAAX,IAAyBc,UAAU,CAACvE,gBAApC,EAAsD;QAClD,KAAK,MAAML,UAAX,IAAyB8D,UAAU,CAAC3D,MAApC,EAA4C;UACxC,MAAM0E,aAAa,GAAGZ,aAAa,CAAC9B,GAAd,CAAkBnC,UAAlB,CAAtB;;UACA,IAAI6E,aAAa,KAAKF,QAAtB,EAAgC;YAC5B;YACA;YACA;UACH;;UACD,KAAK,MAAMG,iBAAX,IAAgC,CAACrD,EAAE,GAAGoD,aAAa,KAAK,IAAlB,IAA0BA,aAAa,KAAK,KAAK,CAAjD,GAAqD,KAAK,CAA1D,GAA8DA,aAAa,CAAChC,KAAlF,MAA6F,IAA7F,IAAqGpB,EAAE,KAAK,KAAK,CAAjH,GAAqHA,EAArH,GAA0H,EAA1J,EAA8J;YAC1JiD,WAAW,CAAC5E,GAAZ,CAAgBgF,iBAAhB;UACH;QACJ;MACJ;IACJ;;IACD,MAAMC,cAAc,GAAGT,4BAA4B,CAAChF,KAAD,CAAnD;;IACA,KAAK,MAAM0F,aAAX,IAA4BD,cAA5B,EAA4C;MACxCL,WAAW,CAACO,MAAZ,CAAmBD,aAAnB;IACH;;IACD,OAAON,WAAP;EACH,CApDkC,CAqDnC;;;EACA,KAAK,IAAIQ,CAAC,GAAGlB,cAAc,CAAC3E,MAAf,GAAwB,CAArC,EAAwC6F,CAAC,IAAI,CAA7C,EAAgDA,CAAC,EAAjD,EAAqD;IACjD,MAAM9B,GAAG,GAAGY,cAAc,CAACkB,CAAD,CAA1B;;IACA,KAAK,MAAM5F,KAAX,IAAoB8D,GAAG,CAACP,KAAxB,EAA+B;MAC3B,MAAMsC,QAAQ,GAAGV,kCAAkC,CAACnF,KAAD,CAAnD;MACA,MAAM8F,sBAAsB,GAAGd,4BAA4B,CAAChF,KAAD,CAA3D;;MACA,KAAK,MAAMA,KAAX,IAAoB6F,QAApB,EAA8B;QAC1B,IAAIC,sBAAsB,CAACvF,GAAvB,CAA2BP,KAA3B,CAAJ,EAAuC;UACnC6F,QAAQ,CAACF,MAAT,CAAgB3F,KAAhB;QACH,CAFD,MAGK;UACD8F,sBAAsB,CAACtF,GAAvB,CAA2BR,KAA3B;QACH;MACJ;;MACD6E,aAAa,CAACxE,GAAd,CAAkBL,KAAlB,EAAyB6F,QAAzB;;MACA,KAAK,MAAMjF,KAAX,IAAoBZ,KAAK,CAACiB,cAA1B,EAA0C;QACtC;QACA,MAAM8E,qBAAqB,GAAGjB,aAAa,CAAC1F,GAAG,CAACwB,KAAK,CAACsE,eAAP,EAAyBD,MAAD,IAAY;UAAE,IAAI9C,EAAJ;;UAAQ,OAAO,CAACA,EAAE,GAAGyC,4BAA4B,CAAC/B,GAA7B,CAAiCoC,MAAjC,CAAN,MAAoD,IAApD,IAA4D9C,EAAE,KAAK,KAAK,CAAxE,GAA4EA,EAA5E,GAAiF,IAAIjC,GAAJ,EAAxF;QAAoG,CAAlJ,CAAJ,CAA3C,CAFsC,CAGtC;;QACA,KAAK,MAAMF,KAAX,IAAoB6F,QAApB,EAA8B;UAC1BE,qBAAqB,CAACvF,GAAtB,CAA0BR,KAA1B;QACH,CANqC,CAOtC;;;QACA,KAAK,MAAMA,KAAX,IAAoB,CAACmC,EAAE,GAAGyC,4BAA4B,CAAC/B,GAA7B,CAAiCjC,KAAjC,CAAN,MAAmD,IAAnD,IAA2DuB,EAAE,KAAK,KAAK,CAAvE,GAA2EA,EAA3E,GAAgF,IAAIjC,GAAJ,EAApG,EAA+G;UAC3G6F,qBAAqB,CAACvF,GAAtB,CAA0BR,KAA1B;QACH;;QACD4E,4BAA4B,CAACvE,GAA7B,CAAiCO,KAAjC,EAAwCmF,qBAAxC;MACH;IACJ;EACJ;;EACD,OAAO,CAACrB,cAAD,EAAiBG,aAAjB,CAAP;AACH;;AACD3H,OAAO,CAACE,qBAAR,GAAgCA,qBAAhC"},"metadata":{},"sourceType":"script"}