{"ast":null,"code":"'use strict';\n\nconst EventEmitter = require('events').EventEmitter;\n\nconst helper = require('./helper');\n\nfunction bufferEvents(emitter, eventsToBuffer) {\n  const listeners = [];\n  const eventsToReply = [];\n\n  function genericListener() {\n    eventsToReply.push(Array.from(arguments));\n  }\n\n  eventsToBuffer.forEach(eventName => {\n    const listener = genericListener.bind(null, eventName);\n    listeners.push(listener);\n    emitter.on(eventName, listener);\n  });\n  return function () {\n    listeners.forEach((listener, i) => {\n      emitter.removeListener(eventsToBuffer[i], listener);\n    });\n    eventsToReply.forEach(args => {\n      EventEmitter.prototype.emit.apply(emitter, args);\n    });\n    listeners.length = 0;\n    eventsToReply.length = 0;\n  };\n}\n\nclass KarmaEventEmitter extends EventEmitter {\n  bind(object) {\n    for (const method in object) {\n      if (method.startsWith('on') && helper.isFunction(object[method])) {\n        this.on(helper.camelToSnake(method.slice(2)), function () {\n          // We do not use an arrow function here, to supply the caller as this.\n          object[method].apply(object, Array.from(arguments).concat(this));\n        });\n      }\n    }\n  }\n\n  emitAsync(name) {\n    // TODO(vojta): allow passing args\n    // TODO(vojta): ignore/throw if listener call done() multiple times\n    let pending = this.listeners(name).length;\n    const deferred = helper.defer();\n    this.emit(name, () => {\n      if (! --pending) {\n        deferred.resolve();\n      }\n    });\n\n    if (!pending) {\n      deferred.resolve();\n    }\n\n    return deferred.promise;\n  }\n\n}\n\nexports.EventEmitter = KarmaEventEmitter;\nexports.bufferEvents = bufferEvents;","map":{"version":3,"names":["EventEmitter","require","helper","bufferEvents","emitter","eventsToBuffer","listeners","eventsToReply","genericListener","push","Array","from","arguments","forEach","eventName","listener","bind","on","i","removeListener","args","prototype","emit","apply","length","KarmaEventEmitter","object","method","startsWith","isFunction","camelToSnake","slice","concat","emitAsync","name","pending","deferred","defer","resolve","promise","exports"],"sources":["/Users/deliabarbuta/Documents/An4Sem1/PAW/Proiect/proiect-paw-tadam/Frontend_OceanCross/node_modules/karma/lib/events.js"],"sourcesContent":["'use strict'\n\nconst EventEmitter = require('events').EventEmitter\nconst helper = require('./helper')\n\nfunction bufferEvents (emitter, eventsToBuffer) {\n  const listeners = []\n  const eventsToReply = []\n\n  function genericListener () {\n    eventsToReply.push(Array.from(arguments))\n  }\n\n  eventsToBuffer.forEach((eventName) => {\n    const listener = genericListener.bind(null, eventName)\n    listeners.push(listener)\n    emitter.on(eventName, listener)\n  })\n\n  return function () {\n    listeners.forEach((listener, i) => {\n      emitter.removeListener(eventsToBuffer[i], listener)\n    })\n\n    eventsToReply.forEach((args) => {\n      EventEmitter.prototype.emit.apply(emitter, args)\n    })\n\n    listeners.length = 0\n    eventsToReply.length = 0\n  }\n}\n\nclass KarmaEventEmitter extends EventEmitter {\n  bind (object) {\n    for (const method in object) {\n      if (method.startsWith('on') && helper.isFunction(object[method])) {\n        this.on(helper.camelToSnake(method.slice(2)), function () {\n          // We do not use an arrow function here, to supply the caller as this.\n          object[method].apply(object, Array.from(arguments).concat(this))\n        })\n      }\n    }\n  }\n\n  emitAsync (name) {\n    // TODO(vojta): allow passing args\n    // TODO(vojta): ignore/throw if listener call done() multiple times\n    let pending = this.listeners(name).length\n    const deferred = helper.defer()\n\n    this.emit(name, () => {\n      if (!--pending) {\n        deferred.resolve()\n      }\n    })\n\n    if (!pending) {\n      deferred.resolve()\n    }\n\n    return deferred.promise\n  }\n}\n\nexports.EventEmitter = KarmaEventEmitter\nexports.bufferEvents = bufferEvents\n"],"mappings":"AAAA;;AAEA,MAAMA,YAAY,GAAGC,OAAO,CAAC,QAAD,CAAP,CAAkBD,YAAvC;;AACA,MAAME,MAAM,GAAGD,OAAO,CAAC,UAAD,CAAtB;;AAEA,SAASE,YAAT,CAAuBC,OAAvB,EAAgCC,cAAhC,EAAgD;EAC9C,MAAMC,SAAS,GAAG,EAAlB;EACA,MAAMC,aAAa,GAAG,EAAtB;;EAEA,SAASC,eAAT,GAA4B;IAC1BD,aAAa,CAACE,IAAd,CAAmBC,KAAK,CAACC,IAAN,CAAWC,SAAX,CAAnB;EACD;;EAEDP,cAAc,CAACQ,OAAf,CAAwBC,SAAD,IAAe;IACpC,MAAMC,QAAQ,GAAGP,eAAe,CAACQ,IAAhB,CAAqB,IAArB,EAA2BF,SAA3B,CAAjB;IACAR,SAAS,CAACG,IAAV,CAAeM,QAAf;IACAX,OAAO,CAACa,EAAR,CAAWH,SAAX,EAAsBC,QAAtB;EACD,CAJD;EAMA,OAAO,YAAY;IACjBT,SAAS,CAACO,OAAV,CAAkB,CAACE,QAAD,EAAWG,CAAX,KAAiB;MACjCd,OAAO,CAACe,cAAR,CAAuBd,cAAc,CAACa,CAAD,CAArC,EAA0CH,QAA1C;IACD,CAFD;IAIAR,aAAa,CAACM,OAAd,CAAuBO,IAAD,IAAU;MAC9BpB,YAAY,CAACqB,SAAb,CAAuBC,IAAvB,CAA4BC,KAA5B,CAAkCnB,OAAlC,EAA2CgB,IAA3C;IACD,CAFD;IAIAd,SAAS,CAACkB,MAAV,GAAmB,CAAnB;IACAjB,aAAa,CAACiB,MAAd,GAAuB,CAAvB;EACD,CAXD;AAYD;;AAED,MAAMC,iBAAN,SAAgCzB,YAAhC,CAA6C;EAC3CgB,IAAI,CAAEU,MAAF,EAAU;IACZ,KAAK,MAAMC,MAAX,IAAqBD,MAArB,EAA6B;MAC3B,IAAIC,MAAM,CAACC,UAAP,CAAkB,IAAlB,KAA2B1B,MAAM,CAAC2B,UAAP,CAAkBH,MAAM,CAACC,MAAD,CAAxB,CAA/B,EAAkE;QAChE,KAAKV,EAAL,CAAQf,MAAM,CAAC4B,YAAP,CAAoBH,MAAM,CAACI,KAAP,CAAa,CAAb,CAApB,CAAR,EAA8C,YAAY;UACxD;UACAL,MAAM,CAACC,MAAD,CAAN,CAAeJ,KAAf,CAAqBG,MAArB,EAA6BhB,KAAK,CAACC,IAAN,CAAWC,SAAX,EAAsBoB,MAAtB,CAA6B,IAA7B,CAA7B;QACD,CAHD;MAID;IACF;EACF;;EAEDC,SAAS,CAAEC,IAAF,EAAQ;IACf;IACA;IACA,IAAIC,OAAO,GAAG,KAAK7B,SAAL,CAAe4B,IAAf,EAAqBV,MAAnC;IACA,MAAMY,QAAQ,GAAGlC,MAAM,CAACmC,KAAP,EAAjB;IAEA,KAAKf,IAAL,CAAUY,IAAV,EAAgB,MAAM;MACpB,IAAI,CAAC,GAAEC,OAAP,EAAgB;QACdC,QAAQ,CAACE,OAAT;MACD;IACF,CAJD;;IAMA,IAAI,CAACH,OAAL,EAAc;MACZC,QAAQ,CAACE,OAAT;IACD;;IAED,OAAOF,QAAQ,CAACG,OAAhB;EACD;;AA7B0C;;AAgC7CC,OAAO,CAACxC,YAAR,GAAuByB,iBAAvB;AACAe,OAAO,CAACrC,YAAR,GAAuBA,YAAvB"},"metadata":{},"sourceType":"script"}