{"ast":null,"code":"'use strict';\n\nconst log = require('./logger').create();\n\nclass Executor {\n  constructor(capturedBrowsers, config, emitter) {\n    this.capturedBrowsers = capturedBrowsers;\n    this.config = config;\n    this.emitter = emitter;\n    this.executionScheduled = false;\n    this.errorsScheduled = [];\n    this.pendingCount = 0;\n    this.runningBrowsers = null;\n    this.emitter.on('run_complete', () => this.onRunComplete());\n    this.emitter.on('browser_complete', () => this.onBrowserComplete());\n  }\n\n  schedule() {\n    if (this.capturedBrowsers.length === 0) {\n      log.warn(`No captured browser, open ${this.config.protocol}//${this.config.hostname}:${this.config.port}${this.config.urlRoot}`);\n      return false;\n    } else if (this.capturedBrowsers.areAllReady()) {\n      log.debug('All browsers are ready, executing');\n      log.debug(`Captured ${this.capturedBrowsers.length} browsers`);\n      this.executionScheduled = false;\n      this.capturedBrowsers.clearResults();\n      this.pendingCount = this.capturedBrowsers.length;\n      this.runningBrowsers = this.capturedBrowsers.clone();\n      this.emitter.emit('run_start', this.runningBrowsers);\n      this.socketIoSockets.emit('execute', this.config.client);\n      return true;\n    } else {\n      log.info('Delaying execution, these browsers are not ready: ' + this.capturedBrowsers.getNonReady().join(', '));\n      this.executionScheduled = true;\n      return false;\n    }\n  }\n  /**\n   * Schedule an error to be reported\n   * @param {string} errorMessage\n   * @returns {boolean} a boolean indicating whether or not the error was handled synchronously\n   */\n\n\n  scheduleError(errorMessage) {\n    // We don't want to interfere with any running test.\n    // Verify that no test is running before reporting the error.\n    if (this.capturedBrowsers.areAllReady()) {\n      log.warn(errorMessage);\n      const errorResult = {\n        success: 0,\n        failed: 0,\n        skipped: 0,\n        error: errorMessage,\n        exitCode: 1\n      };\n      const noBrowsersStartedTests = [];\n      this.emitter.emit('run_start', noBrowsersStartedTests); // A run cannot complete without being started\n\n      this.emitter.emit('run_complete', noBrowsersStartedTests, errorResult);\n      return true;\n    } else {\n      this.errorsScheduled.push(errorMessage);\n      return false;\n    }\n  }\n\n  onRunComplete() {\n    if (this.executionScheduled) {\n      this.schedule();\n    }\n\n    if (this.errorsScheduled.length) {\n      const errorsToReport = this.errorsScheduled;\n      this.errorsScheduled = [];\n      errorsToReport.forEach(error => this.scheduleError(error));\n    }\n  }\n\n  onBrowserComplete() {\n    this.pendingCount--;\n\n    if (!this.pendingCount) {\n      // Ensure run_complete is emitted in the next tick\n      // so it is never emitted before browser_complete\n      setTimeout(() => {\n        this.emitter.emit('run_complete', this.runningBrowsers, this.runningBrowsers.getResults());\n      });\n    }\n  }\n\n}\n\nExecutor.factory = function (capturedBrowsers, config, emitter) {\n  return new Executor(capturedBrowsers, config, emitter);\n};\n\nmodule.exports = Executor;","map":{"version":3,"names":["log","require","create","Executor","constructor","capturedBrowsers","config","emitter","executionScheduled","errorsScheduled","pendingCount","runningBrowsers","on","onRunComplete","onBrowserComplete","schedule","length","warn","protocol","hostname","port","urlRoot","areAllReady","debug","clearResults","clone","emit","socketIoSockets","client","info","getNonReady","join","scheduleError","errorMessage","errorResult","success","failed","skipped","error","exitCode","noBrowsersStartedTests","push","errorsToReport","forEach","setTimeout","getResults","factory","module","exports"],"sources":["/Users/deliabarbuta/Documents/An4Sem1/PAW/Proiect/proiect-paw-tadam/Frontend_OceanCross/node_modules/karma/lib/executor.js"],"sourcesContent":["'use strict'\n\nconst log = require('./logger').create()\n\nclass Executor {\n  constructor (capturedBrowsers, config, emitter) {\n    this.capturedBrowsers = capturedBrowsers\n    this.config = config\n    this.emitter = emitter\n\n    this.executionScheduled = false\n    this.errorsScheduled = []\n    this.pendingCount = 0\n    this.runningBrowsers = null\n\n    this.emitter.on('run_complete', () => this.onRunComplete())\n    this.emitter.on('browser_complete', () => this.onBrowserComplete())\n  }\n\n  schedule () {\n    if (this.capturedBrowsers.length === 0) {\n      log.warn(`No captured browser, open ${this.config.protocol}//${this.config.hostname}:${this.config.port}${this.config.urlRoot}`)\n      return false\n    } else if (this.capturedBrowsers.areAllReady()) {\n      log.debug('All browsers are ready, executing')\n      log.debug(`Captured ${this.capturedBrowsers.length} browsers`)\n      this.executionScheduled = false\n      this.capturedBrowsers.clearResults()\n      this.pendingCount = this.capturedBrowsers.length\n      this.runningBrowsers = this.capturedBrowsers.clone()\n      this.emitter.emit('run_start', this.runningBrowsers)\n      this.socketIoSockets.emit('execute', this.config.client)\n      return true\n    } else {\n      log.info('Delaying execution, these browsers are not ready: ' + this.capturedBrowsers.getNonReady().join(', '))\n      this.executionScheduled = true\n      return false\n    }\n  }\n\n  /**\n   * Schedule an error to be reported\n   * @param {string} errorMessage\n   * @returns {boolean} a boolean indicating whether or not the error was handled synchronously\n   */\n  scheduleError (errorMessage) {\n    // We don't want to interfere with any running test.\n    // Verify that no test is running before reporting the error.\n    if (this.capturedBrowsers.areAllReady()) {\n      log.warn(errorMessage)\n      const errorResult = {\n        success: 0,\n        failed: 0,\n        skipped: 0,\n        error: errorMessage,\n        exitCode: 1\n      }\n      const noBrowsersStartedTests = []\n      this.emitter.emit('run_start', noBrowsersStartedTests) // A run cannot complete without being started\n      this.emitter.emit('run_complete', noBrowsersStartedTests, errorResult)\n      return true\n    } else {\n      this.errorsScheduled.push(errorMessage)\n      return false\n    }\n  }\n\n  onRunComplete () {\n    if (this.executionScheduled) {\n      this.schedule()\n    }\n    if (this.errorsScheduled.length) {\n      const errorsToReport = this.errorsScheduled\n      this.errorsScheduled = []\n      errorsToReport.forEach((error) => this.scheduleError(error))\n    }\n  }\n\n  onBrowserComplete () {\n    this.pendingCount--\n\n    if (!this.pendingCount) {\n      // Ensure run_complete is emitted in the next tick\n      // so it is never emitted before browser_complete\n      setTimeout(() => {\n        this.emitter.emit('run_complete', this.runningBrowsers, this.runningBrowsers.getResults())\n      })\n    }\n  }\n}\n\nExecutor.factory = function (capturedBrowsers, config, emitter) {\n  return new Executor(capturedBrowsers, config, emitter)\n}\n\nmodule.exports = Executor\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}