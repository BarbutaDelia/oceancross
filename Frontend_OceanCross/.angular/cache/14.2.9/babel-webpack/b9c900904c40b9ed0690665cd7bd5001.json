{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getKeywords = void 0;\n\nconst core_1 = require(\"@babel/core\");\n\nconst helper_annotate_as_pure_1 = __importDefault(require(\"@babel/helper-annotate-as-pure\"));\n/**\n * Provides one or more keywords that if found within the content of a source file indicate\n * that this plugin should be used with a source file.\n *\n * @returns An a string iterable containing one or more keywords.\n */\n\n\nfunction getKeywords() {\n  return ['var'];\n}\n\nexports.getKeywords = getKeywords;\n/**\n * A babel plugin factory function for adjusting TypeScript emitted enums.\n *\n * @returns A babel plugin object instance.\n */\n\nfunction default_1() {\n  return {\n    visitor: {\n      VariableDeclaration(path, state) {\n        const {\n          parentPath,\n          node\n        } = path;\n        const {\n          loose\n        } = state.opts;\n\n        if (node.kind !== 'var' || node.declarations.length !== 1) {\n          return;\n        }\n\n        const declaration = path.get('declarations')[0];\n\n        if (declaration.node.init) {\n          return;\n        }\n\n        const declarationId = declaration.node.id;\n\n        if (!core_1.types.isIdentifier(declarationId)) {\n          return;\n        }\n\n        const hasExport = parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration();\n        const origin = hasExport ? parentPath : path;\n        const nextStatement = origin.getSibling(+origin.key + 1);\n\n        if (!nextStatement.isExpressionStatement()) {\n          return;\n        }\n\n        const nextExpression = nextStatement.get('expression');\n\n        if (!nextExpression.isCallExpression() || nextExpression.node.arguments.length !== 1) {\n          return;\n        }\n\n        const enumCallArgument = nextExpression.node.arguments[0];\n\n        if (!core_1.types.isLogicalExpression(enumCallArgument, {\n          operator: '||'\n        })) {\n          return;\n        } // Check if identifiers match var declaration\n\n\n        if (!core_1.types.isIdentifier(enumCallArgument.left) || !nextExpression.scope.bindingIdentifierEquals(enumCallArgument.left.name, declarationId)) {\n          return;\n        }\n\n        const enumCallee = nextExpression.get('callee');\n\n        if (!enumCallee.isFunctionExpression() || enumCallee.node.params.length !== 1) {\n          return;\n        }\n\n        const enumCalleeParam = enumCallee.node.params[0];\n        const isEnumCalleeMatching = core_1.types.isIdentifier(enumCalleeParam) && enumCalleeParam.name === declarationId.name; // Loose mode rewrites the enum to a shorter but less TypeScript-like form\n        // Note: We only can apply the `loose` mode transformation if the callee parameter matches\n        // with the declaration identifier name. This is necessary in case the the declaration id has\n        // been renamed to avoid collisions, as the loose transform would then break the enum assignments\n        // which rely on the differently-named callee identifier name.\n\n        let enumAssignments;\n\n        if (loose && isEnumCalleeMatching) {\n          enumAssignments = [];\n        } // Check if all enum member values are pure.\n        // If not, leave as-is due to potential side efects\n\n\n        let hasElements = false;\n\n        for (const enumStatement of enumCallee.get('body').get('body')) {\n          if (!enumStatement.isExpressionStatement()) {\n            return;\n          }\n\n          const enumValueAssignment = enumStatement.get('expression');\n\n          if (!enumValueAssignment.isAssignmentExpression() || !enumValueAssignment.get('right').isPure()) {\n            return;\n          }\n\n          hasElements = true;\n          enumAssignments === null || enumAssignments === void 0 ? void 0 : enumAssignments.push(enumStatement.node);\n        } // If there are no enum elements then there is nothing to wrap\n\n\n        if (!hasElements) {\n          return;\n        } // Remove existing enum initializer\n\n\n        const enumInitializer = nextExpression.node;\n        nextExpression.remove(); // Create IIFE block contents\n\n        let blockContents;\n\n        if (enumAssignments) {\n          // Loose mode\n          blockContents = [core_1.types.expressionStatement(core_1.types.assignmentExpression('=', core_1.types.cloneNode(declarationId), core_1.types.logicalExpression('||', core_1.types.cloneNode(declarationId), core_1.types.objectExpression([])))), ...enumAssignments];\n        } else {\n          blockContents = [core_1.types.expressionStatement(enumInitializer)];\n        } // Wrap existing enum initializer in a pure annotated IIFE\n\n\n        const container = core_1.types.arrowFunctionExpression([], core_1.types.blockStatement([...blockContents, core_1.types.returnStatement(core_1.types.cloneNode(declarationId))]));\n        const replacementInitializer = core_1.types.callExpression(core_1.types.parenthesizedExpression(container), []);\n        (0, helper_annotate_as_pure_1.default)(replacementInitializer); // Add the wrapped enum initializer directly to the variable declaration\n\n        declaration.get('init').replaceWith(replacementInitializer);\n      }\n\n    }\n  };\n}\n\nexports.default = default_1;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","getKeywords","core_1","require","helper_annotate_as_pure_1","default_1","visitor","VariableDeclaration","path","state","parentPath","node","loose","opts","kind","declarations","length","declaration","get","init","declarationId","id","types","isIdentifier","hasExport","isExportNamedDeclaration","isExportDefaultDeclaration","origin","nextStatement","getSibling","key","isExpressionStatement","nextExpression","isCallExpression","arguments","enumCallArgument","isLogicalExpression","operator","left","scope","bindingIdentifierEquals","name","enumCallee","isFunctionExpression","params","enumCalleeParam","isEnumCalleeMatching","enumAssignments","hasElements","enumStatement","enumValueAssignment","isAssignmentExpression","isPure","push","enumInitializer","remove","blockContents","expressionStatement","assignmentExpression","cloneNode","logicalExpression","objectExpression","container","arrowFunctionExpression","blockStatement","returnStatement","replacementInitializer","callExpression","parenthesizedExpression","default","replaceWith"],"sources":["/Users/deliabarbuta/Documents/An4Sem1/PAW/Proiect/proiect-paw-tadam/Frontend_OceanCross/node_modules/@angular-devkit/build-angular/src/babel/plugins/adjust-typescript-enums.js"],"sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getKeywords = void 0;\nconst core_1 = require(\"@babel/core\");\nconst helper_annotate_as_pure_1 = __importDefault(require(\"@babel/helper-annotate-as-pure\"));\n/**\n * Provides one or more keywords that if found within the content of a source file indicate\n * that this plugin should be used with a source file.\n *\n * @returns An a string iterable containing one or more keywords.\n */\nfunction getKeywords() {\n    return ['var'];\n}\nexports.getKeywords = getKeywords;\n/**\n * A babel plugin factory function for adjusting TypeScript emitted enums.\n *\n * @returns A babel plugin object instance.\n */\nfunction default_1() {\n    return {\n        visitor: {\n            VariableDeclaration(path, state) {\n                const { parentPath, node } = path;\n                const { loose } = state.opts;\n                if (node.kind !== 'var' || node.declarations.length !== 1) {\n                    return;\n                }\n                const declaration = path.get('declarations')[0];\n                if (declaration.node.init) {\n                    return;\n                }\n                const declarationId = declaration.node.id;\n                if (!core_1.types.isIdentifier(declarationId)) {\n                    return;\n                }\n                const hasExport = parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration();\n                const origin = hasExport ? parentPath : path;\n                const nextStatement = origin.getSibling(+origin.key + 1);\n                if (!nextStatement.isExpressionStatement()) {\n                    return;\n                }\n                const nextExpression = nextStatement.get('expression');\n                if (!nextExpression.isCallExpression() || nextExpression.node.arguments.length !== 1) {\n                    return;\n                }\n                const enumCallArgument = nextExpression.node.arguments[0];\n                if (!core_1.types.isLogicalExpression(enumCallArgument, { operator: '||' })) {\n                    return;\n                }\n                // Check if identifiers match var declaration\n                if (!core_1.types.isIdentifier(enumCallArgument.left) ||\n                    !nextExpression.scope.bindingIdentifierEquals(enumCallArgument.left.name, declarationId)) {\n                    return;\n                }\n                const enumCallee = nextExpression.get('callee');\n                if (!enumCallee.isFunctionExpression() || enumCallee.node.params.length !== 1) {\n                    return;\n                }\n                const enumCalleeParam = enumCallee.node.params[0];\n                const isEnumCalleeMatching = core_1.types.isIdentifier(enumCalleeParam) && enumCalleeParam.name === declarationId.name;\n                // Loose mode rewrites the enum to a shorter but less TypeScript-like form\n                // Note: We only can apply the `loose` mode transformation if the callee parameter matches\n                // with the declaration identifier name. This is necessary in case the the declaration id has\n                // been renamed to avoid collisions, as the loose transform would then break the enum assignments\n                // which rely on the differently-named callee identifier name.\n                let enumAssignments;\n                if (loose && isEnumCalleeMatching) {\n                    enumAssignments = [];\n                }\n                // Check if all enum member values are pure.\n                // If not, leave as-is due to potential side efects\n                let hasElements = false;\n                for (const enumStatement of enumCallee.get('body').get('body')) {\n                    if (!enumStatement.isExpressionStatement()) {\n                        return;\n                    }\n                    const enumValueAssignment = enumStatement.get('expression');\n                    if (!enumValueAssignment.isAssignmentExpression() ||\n                        !enumValueAssignment.get('right').isPure()) {\n                        return;\n                    }\n                    hasElements = true;\n                    enumAssignments === null || enumAssignments === void 0 ? void 0 : enumAssignments.push(enumStatement.node);\n                }\n                // If there are no enum elements then there is nothing to wrap\n                if (!hasElements) {\n                    return;\n                }\n                // Remove existing enum initializer\n                const enumInitializer = nextExpression.node;\n                nextExpression.remove();\n                // Create IIFE block contents\n                let blockContents;\n                if (enumAssignments) {\n                    // Loose mode\n                    blockContents = [\n                        core_1.types.expressionStatement(core_1.types.assignmentExpression('=', core_1.types.cloneNode(declarationId), core_1.types.logicalExpression('||', core_1.types.cloneNode(declarationId), core_1.types.objectExpression([])))),\n                        ...enumAssignments,\n                    ];\n                }\n                else {\n                    blockContents = [core_1.types.expressionStatement(enumInitializer)];\n                }\n                // Wrap existing enum initializer in a pure annotated IIFE\n                const container = core_1.types.arrowFunctionExpression([], core_1.types.blockStatement([\n                    ...blockContents,\n                    core_1.types.returnStatement(core_1.types.cloneNode(declarationId)),\n                ]));\n                const replacementInitializer = core_1.types.callExpression(core_1.types.parenthesizedExpression(container), []);\n                (0, helper_annotate_as_pure_1.default)(replacementInitializer);\n                // Add the wrapped enum initializer directly to the variable declaration\n                declaration.get('init').replaceWith(replacementInitializer);\n            },\n        },\n    };\n}\nexports.default = default_1;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}