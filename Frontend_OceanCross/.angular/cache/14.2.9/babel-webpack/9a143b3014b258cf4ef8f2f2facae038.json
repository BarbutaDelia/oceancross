{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@jridgewell/sourcemap-codec'), require('@jridgewell/resolve-uri')) : typeof define === 'function' && define.amd ? define(['exports', '@jridgewell/sourcemap-codec', '@jridgewell/resolve-uri'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.traceMapping = {}, global.sourcemapCodec, global.resolveURI));\n})(this, function (exports, sourcemapCodec, resolveUri) {\n  'use strict';\n\n  function _interopDefaultLegacy(e) {\n    return e && typeof e === 'object' && 'default' in e ? e : {\n      'default': e\n    };\n  }\n\n  var resolveUri__default = /*#__PURE__*/_interopDefaultLegacy(resolveUri);\n\n  function resolve(input, base) {\n    // The base is always treated as a directory, if it's not empty.\n    // https://github.com/mozilla/source-map/blob/8cb3ee57/lib/util.js#L327\n    // https://github.com/chromium/chromium/blob/da4adbb3/third_party/blink/renderer/devtools/front_end/sdk/SourceMap.js#L400-L401\n    if (base && !base.endsWith('/')) base += '/';\n    return resolveUri__default[\"default\"](input, base);\n  }\n  /**\n   * Removes everything after the last \"/\", but leaves the slash.\n   */\n\n\n  function stripFilename(path) {\n    if (!path) return '';\n    const index = path.lastIndexOf('/');\n    return path.slice(0, index + 1);\n  }\n\n  const COLUMN = 0;\n  const SOURCES_INDEX = 1;\n  const SOURCE_LINE = 2;\n  const SOURCE_COLUMN = 3;\n  const NAMES_INDEX = 4;\n  const REV_GENERATED_LINE = 1;\n  const REV_GENERATED_COLUMN = 2;\n\n  function maybeSort(mappings, owned) {\n    const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);\n    if (unsortedIndex === mappings.length) return mappings; // If we own the array (meaning we parsed it from JSON), then we're free to directly mutate it. If\n    // not, we do not want to modify the consumer's input array.\n\n    if (!owned) mappings = mappings.slice();\n\n    for (let i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1)) {\n      mappings[i] = sortSegments(mappings[i], owned);\n    }\n\n    return mappings;\n  }\n\n  function nextUnsortedSegmentLine(mappings, start) {\n    for (let i = start; i < mappings.length; i++) {\n      if (!isSorted(mappings[i])) return i;\n    }\n\n    return mappings.length;\n  }\n\n  function isSorted(line) {\n    for (let j = 1; j < line.length; j++) {\n      if (line[j][COLUMN] < line[j - 1][COLUMN]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  function sortSegments(line, owned) {\n    if (!owned) line = line.slice();\n    return line.sort(sortComparator);\n  }\n\n  function sortComparator(a, b) {\n    return a[COLUMN] - b[COLUMN];\n  }\n\n  let found = false;\n  /**\n   * A binary search implementation that returns the index if a match is found.\n   * If no match is found, then the left-index (the index associated with the item that comes just\n   * before the desired index) is returned. To maintain proper sort order, a splice would happen at\n   * the next index:\n   *\n   * ```js\n   * const array = [1, 3];\n   * const needle = 2;\n   * const index = binarySearch(array, needle, (item, needle) => item - needle);\n   *\n   * assert.equal(index, 0);\n   * array.splice(index + 1, 0, needle);\n   * assert.deepEqual(array, [1, 2, 3]);\n   * ```\n   */\n\n  function binarySearch(haystack, needle, low, high) {\n    while (low <= high) {\n      const mid = low + (high - low >> 1);\n      const cmp = haystack[mid][COLUMN] - needle;\n\n      if (cmp === 0) {\n        found = true;\n        return mid;\n      }\n\n      if (cmp < 0) {\n        low = mid + 1;\n      } else {\n        high = mid - 1;\n      }\n    }\n\n    found = false;\n    return low - 1;\n  }\n\n  function upperBound(haystack, needle, index) {\n    for (let i = index + 1; i < haystack.length; index = i++) {\n      if (haystack[i][COLUMN] !== needle) break;\n    }\n\n    return index;\n  }\n\n  function lowerBound(haystack, needle, index) {\n    for (let i = index - 1; i >= 0; index = i--) {\n      if (haystack[i][COLUMN] !== needle) break;\n    }\n\n    return index;\n  }\n\n  function memoizedState() {\n    return {\n      lastKey: -1,\n      lastNeedle: -1,\n      lastIndex: -1\n    };\n  }\n  /**\n   * This overly complicated beast is just to record the last tested line/column and the resulting\n   * index, allowing us to skip a few tests if mappings are monotonically increasing.\n   */\n\n\n  function memoizedBinarySearch(haystack, needle, state, key) {\n    const {\n      lastKey,\n      lastNeedle,\n      lastIndex\n    } = state;\n    let low = 0;\n    let high = haystack.length - 1;\n\n    if (key === lastKey) {\n      if (needle === lastNeedle) {\n        found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle;\n        return lastIndex;\n      }\n\n      if (needle >= lastNeedle) {\n        // lastIndex may be -1 if the previous needle was not found.\n        low = lastIndex === -1 ? 0 : lastIndex;\n      } else {\n        high = lastIndex;\n      }\n    }\n\n    state.lastKey = key;\n    state.lastNeedle = needle;\n    return state.lastIndex = binarySearch(haystack, needle, low, high);\n  } // Rebuilds the original source files, with mappings that are ordered by source line/column instead\n  // of generated line/column.\n\n\n  function buildBySources(decoded, memos) {\n    const sources = memos.map(buildNullArray);\n\n    for (let i = 0; i < decoded.length; i++) {\n      const line = decoded[i];\n\n      for (let j = 0; j < line.length; j++) {\n        const seg = line[j];\n        if (seg.length === 1) continue;\n        const sourceIndex = seg[SOURCES_INDEX];\n        const sourceLine = seg[SOURCE_LINE];\n        const sourceColumn = seg[SOURCE_COLUMN];\n        const originalSource = sources[sourceIndex];\n        const originalLine = originalSource[sourceLine] || (originalSource[sourceLine] = []);\n        const memo = memos[sourceIndex]; // The binary search either found a match, or it found the left-index just before where the\n        // segment should go. Either way, we want to insert after that. And there may be multiple\n        // generated segments associated with an original location, so there may need to move several\n        // indexes before we find where we need to insert.\n\n        const index = upperBound(originalLine, sourceColumn, memoizedBinarySearch(originalLine, sourceColumn, memo, sourceLine));\n        insert(originalLine, memo.lastIndex = index + 1, [sourceColumn, i, seg[COLUMN]]);\n      }\n    }\n\n    return sources;\n  }\n\n  function insert(array, index, value) {\n    for (let i = array.length; i > index; i--) {\n      array[i] = array[i - 1];\n    }\n\n    array[index] = value;\n  } // Null arrays allow us to use ordered index keys without actually allocating contiguous memory like\n  // a real array. We use a null-prototype object to avoid prototype pollution and deoptimizations.\n  // Numeric properties on objects are magically sorted in ascending order by the engine regardless of\n  // the insertion order. So, by setting any numeric keys, even out of order, we'll get ascending\n  // order when iterating with for-in.\n\n\n  function buildNullArray() {\n    return {\n      __proto__: null\n    };\n  }\n\n  const AnyMap = function (map, mapUrl) {\n    const parsed = typeof map === 'string' ? JSON.parse(map) : map;\n    if (!('sections' in parsed)) return new TraceMap(parsed, mapUrl);\n    const mappings = [];\n    const sources = [];\n    const sourcesContent = [];\n    const names = [];\n    recurse(parsed, mapUrl, mappings, sources, sourcesContent, names, 0, 0, Infinity, Infinity);\n    const joined = {\n      version: 3,\n      file: parsed.file,\n      names,\n      sources,\n      sourcesContent,\n      mappings\n    };\n    return exports.presortedDecodedMap(joined);\n  };\n\n  function recurse(input, mapUrl, mappings, sources, sourcesContent, names, lineOffset, columnOffset, stopLine, stopColumn) {\n    const {\n      sections\n    } = input;\n\n    for (let i = 0; i < sections.length; i++) {\n      const {\n        map,\n        offset\n      } = sections[i];\n      let sl = stopLine;\n      let sc = stopColumn;\n\n      if (i + 1 < sections.length) {\n        const nextOffset = sections[i + 1].offset;\n        sl = Math.min(stopLine, lineOffset + nextOffset.line);\n\n        if (sl === stopLine) {\n          sc = Math.min(stopColumn, columnOffset + nextOffset.column);\n        } else if (sl < stopLine) {\n          sc = columnOffset + nextOffset.column;\n        }\n      }\n\n      addSection(map, mapUrl, mappings, sources, sourcesContent, names, lineOffset + offset.line, columnOffset + offset.column, sl, sc);\n    }\n  }\n\n  function addSection(input, mapUrl, mappings, sources, sourcesContent, names, lineOffset, columnOffset, stopLine, stopColumn) {\n    if ('sections' in input) return recurse(...arguments);\n    const map = new TraceMap(input, mapUrl);\n    const sourcesOffset = sources.length;\n    const namesOffset = names.length;\n    const decoded = exports.decodedMappings(map);\n    const {\n      resolvedSources,\n      sourcesContent: contents\n    } = map;\n    append(sources, resolvedSources);\n    append(names, map.names);\n    if (contents) append(sourcesContent, contents);else for (let i = 0; i < resolvedSources.length; i++) sourcesContent.push(null);\n\n    for (let i = 0; i < decoded.length; i++) {\n      const lineI = lineOffset + i; // We can only add so many lines before we step into the range that the next section's map\n      // controls. When we get to the last line, then we'll start checking the segments to see if\n      // they've crossed into the column range. But it may not have any columns that overstep, so we\n      // still need to check that we don't overstep lines, too.\n\n      if (lineI > stopLine) return; // The out line may already exist in mappings (if we're continuing the line started by a\n      // previous section). Or, we may have jumped ahead several lines to start this section.\n\n      const out = getLine(mappings, lineI); // On the 0th loop, the section's column offset shifts us forward. On all other lines (since the\n      // map can be multiple lines), it doesn't.\n\n      const cOffset = i === 0 ? columnOffset : 0;\n      const line = decoded[i];\n\n      for (let j = 0; j < line.length; j++) {\n        const seg = line[j];\n        const column = cOffset + seg[COLUMN]; // If this segment steps into the column range that the next section's map controls, we need\n        // to stop early.\n\n        if (lineI === stopLine && column >= stopColumn) return;\n\n        if (seg.length === 1) {\n          out.push([column]);\n          continue;\n        }\n\n        const sourcesIndex = sourcesOffset + seg[SOURCES_INDEX];\n        const sourceLine = seg[SOURCE_LINE];\n        const sourceColumn = seg[SOURCE_COLUMN];\n        out.push(seg.length === 4 ? [column, sourcesIndex, sourceLine, sourceColumn] : [column, sourcesIndex, sourceLine, sourceColumn, namesOffset + seg[NAMES_INDEX]]);\n      }\n    }\n  }\n\n  function append(arr, other) {\n    for (let i = 0; i < other.length; i++) arr.push(other[i]);\n  }\n\n  function getLine(arr, index) {\n    for (let i = arr.length; i <= index; i++) arr[i] = [];\n\n    return arr[index];\n  }\n\n  const LINE_GTR_ZERO = '`line` must be greater than 0 (lines start at line 1)';\n  const COL_GTR_EQ_ZERO = '`column` must be greater than or equal to 0 (columns start at column 0)';\n  const LEAST_UPPER_BOUND = -1;\n  const GREATEST_LOWER_BOUND = 1;\n  /**\n   * Returns the encoded (VLQ string) form of the SourceMap's mappings field.\n   */\n\n  exports.encodedMappings = void 0;\n  /**\n   * Returns the decoded (array of lines of segments) form of the SourceMap's mappings field.\n   */\n\n  exports.decodedMappings = void 0;\n  /**\n   * A low-level API to find the segment associated with a generated line/column (think, from a\n   * stack trace). Line and column here are 0-based, unlike `originalPositionFor`.\n   */\n\n  exports.traceSegment = void 0;\n  /**\n   * A higher-level API to find the source/line/column associated with a generated line/column\n   * (think, from a stack trace). Line is 1-based, but column is 0-based, due to legacy behavior in\n   * `source-map` library.\n   */\n\n  exports.originalPositionFor = void 0;\n  /**\n   * Finds the generated line/column position of the provided source/line/column source position.\n   */\n\n  exports.generatedPositionFor = void 0;\n  /**\n   * Finds all generated line/column positions of the provided source/line/column source position.\n   */\n\n  exports.allGeneratedPositionsFor = void 0;\n  /**\n   * Iterates each mapping in generated position order.\n   */\n\n  exports.eachMapping = void 0;\n  /**\n   * Retrieves the source content for a particular source, if its found. Returns null if not.\n   */\n\n  exports.sourceContentFor = void 0;\n  /**\n   * A helper that skips sorting of the input map's mappings array, which can be expensive for larger\n   * maps.\n   */\n\n  exports.presortedDecodedMap = void 0;\n  /**\n   * Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects\n   * a sourcemap, or to JSON.stringify.\n   */\n\n  exports.decodedMap = void 0;\n  /**\n   * Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects\n   * a sourcemap, or to JSON.stringify.\n   */\n\n  exports.encodedMap = void 0;\n\n  class TraceMap {\n    constructor(map, mapUrl) {\n      const isString = typeof map === 'string';\n      if (!isString && map._decodedMemo) return map;\n      const parsed = isString ? JSON.parse(map) : map;\n      const {\n        version,\n        file,\n        names,\n        sourceRoot,\n        sources,\n        sourcesContent\n      } = parsed;\n      this.version = version;\n      this.file = file;\n      this.names = names;\n      this.sourceRoot = sourceRoot;\n      this.sources = sources;\n      this.sourcesContent = sourcesContent;\n      const from = resolve(sourceRoot || '', stripFilename(mapUrl));\n      this.resolvedSources = sources.map(s => resolve(s || '', from));\n      const {\n        mappings\n      } = parsed;\n\n      if (typeof mappings === 'string') {\n        this._encoded = mappings;\n        this._decoded = undefined;\n      } else {\n        this._encoded = undefined;\n        this._decoded = maybeSort(mappings, isString);\n      }\n\n      this._decodedMemo = memoizedState();\n      this._bySources = undefined;\n      this._bySourceMemos = undefined;\n    }\n\n  }\n\n  (() => {\n    exports.encodedMappings = map => {\n      var _a;\n\n      return (_a = map._encoded) !== null && _a !== void 0 ? _a : map._encoded = sourcemapCodec.encode(map._decoded);\n    };\n\n    exports.decodedMappings = map => {\n      return map._decoded || (map._decoded = sourcemapCodec.decode(map._encoded));\n    };\n\n    exports.traceSegment = (map, line, column) => {\n      const decoded = exports.decodedMappings(map); // It's common for parent source maps to have pointers to lines that have no\n      // mapping (like a \"//# sourceMappingURL=\") at the end of the child file.\n\n      if (line >= decoded.length) return null;\n      const segments = decoded[line];\n      const index = traceSegmentInternal(segments, map._decodedMemo, line, column, GREATEST_LOWER_BOUND);\n      return index === -1 ? null : segments[index];\n    };\n\n    exports.originalPositionFor = (map, {\n      line,\n      column,\n      bias\n    }) => {\n      line--;\n      if (line < 0) throw new Error(LINE_GTR_ZERO);\n      if (column < 0) throw new Error(COL_GTR_EQ_ZERO);\n      const decoded = exports.decodedMappings(map); // It's common for parent source maps to have pointers to lines that have no\n      // mapping (like a \"//# sourceMappingURL=\") at the end of the child file.\n\n      if (line >= decoded.length) return OMapping(null, null, null, null);\n      const segments = decoded[line];\n      const index = traceSegmentInternal(segments, map._decodedMemo, line, column, bias || GREATEST_LOWER_BOUND);\n      if (index === -1) return OMapping(null, null, null, null);\n      const segment = segments[index];\n      if (segment.length === 1) return OMapping(null, null, null, null);\n      const {\n        names,\n        resolvedSources\n      } = map;\n      return OMapping(resolvedSources[segment[SOURCES_INDEX]], segment[SOURCE_LINE] + 1, segment[SOURCE_COLUMN], segment.length === 5 ? names[segment[NAMES_INDEX]] : null);\n    };\n\n    exports.allGeneratedPositionsFor = (map, {\n      source,\n      line,\n      column,\n      bias\n    }) => {\n      // SourceMapConsumer uses LEAST_UPPER_BOUND for some reason, so we follow suit.\n      return generatedPosition(map, source, line, column, bias || LEAST_UPPER_BOUND, true);\n    };\n\n    exports.generatedPositionFor = (map, {\n      source,\n      line,\n      column,\n      bias\n    }) => {\n      return generatedPosition(map, source, line, column, bias || GREATEST_LOWER_BOUND, false);\n    };\n\n    exports.eachMapping = (map, cb) => {\n      const decoded = exports.decodedMappings(map);\n      const {\n        names,\n        resolvedSources\n      } = map;\n\n      for (let i = 0; i < decoded.length; i++) {\n        const line = decoded[i];\n\n        for (let j = 0; j < line.length; j++) {\n          const seg = line[j];\n          const generatedLine = i + 1;\n          const generatedColumn = seg[0];\n          let source = null;\n          let originalLine = null;\n          let originalColumn = null;\n          let name = null;\n\n          if (seg.length !== 1) {\n            source = resolvedSources[seg[1]];\n            originalLine = seg[2] + 1;\n            originalColumn = seg[3];\n          }\n\n          if (seg.length === 5) name = names[seg[4]];\n          cb({\n            generatedLine,\n            generatedColumn,\n            source,\n            originalLine,\n            originalColumn,\n            name\n          });\n        }\n      }\n    };\n\n    exports.sourceContentFor = (map, source) => {\n      const {\n        sources,\n        resolvedSources,\n        sourcesContent\n      } = map;\n      if (sourcesContent == null) return null;\n      let index = sources.indexOf(source);\n      if (index === -1) index = resolvedSources.indexOf(source);\n      return index === -1 ? null : sourcesContent[index];\n    };\n\n    exports.presortedDecodedMap = (map, mapUrl) => {\n      const tracer = new TraceMap(clone(map, []), mapUrl);\n      tracer._decoded = map.mappings;\n      return tracer;\n    };\n\n    exports.decodedMap = map => {\n      return clone(map, exports.decodedMappings(map));\n    };\n\n    exports.encodedMap = map => {\n      return clone(map, exports.encodedMappings(map));\n    };\n\n    function generatedPosition(map, source, line, column, bias, all) {\n      line--;\n      if (line < 0) throw new Error(LINE_GTR_ZERO);\n      if (column < 0) throw new Error(COL_GTR_EQ_ZERO);\n      const {\n        sources,\n        resolvedSources\n      } = map;\n      let sourceIndex = sources.indexOf(source);\n      if (sourceIndex === -1) sourceIndex = resolvedSources.indexOf(source);\n      if (sourceIndex === -1) return all ? [] : GMapping(null, null);\n      const generated = map._bySources || (map._bySources = buildBySources(exports.decodedMappings(map), map._bySourceMemos = sources.map(memoizedState)));\n      const segments = generated[sourceIndex][line];\n      if (segments == null) return all ? [] : GMapping(null, null);\n      const memo = map._bySourceMemos[sourceIndex];\n      if (all) return sliceGeneratedPositions(segments, memo, line, column, bias);\n      const index = traceSegmentInternal(segments, memo, line, column, bias);\n      if (index === -1) return GMapping(null, null);\n      const segment = segments[index];\n      return GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]);\n    }\n  })();\n\n  function clone(map, mappings) {\n    return {\n      version: map.version,\n      file: map.file,\n      names: map.names,\n      sourceRoot: map.sourceRoot,\n      sources: map.sources,\n      sourcesContent: map.sourcesContent,\n      mappings\n    };\n  }\n\n  function OMapping(source, line, column, name) {\n    return {\n      source,\n      line,\n      column,\n      name\n    };\n  }\n\n  function GMapping(line, column) {\n    return {\n      line,\n      column\n    };\n  }\n\n  function traceSegmentInternal(segments, memo, line, column, bias) {\n    let index = memoizedBinarySearch(segments, column, memo, line);\n\n    if (found) {\n      index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);\n    } else if (bias === LEAST_UPPER_BOUND) index++;\n\n    if (index === -1 || index === segments.length) return -1;\n    return index;\n  }\n\n  function sliceGeneratedPositions(segments, memo, line, column, bias) {\n    let min = traceSegmentInternal(segments, memo, line, column, GREATEST_LOWER_BOUND); // We ignored the bias when tracing the segment so that we're guarnateed to find the first (in\n    // insertion order) segment that matched. Even if we did respect the bias when tracing, we would\n    // still need to call `lowerBound()` to find the first segment, which is slower than just looking\n    // for the GREATEST_LOWER_BOUND to begin with. The only difference that matters for us is when the\n    // binary search didn't match, in which case GREATEST_LOWER_BOUND just needs to increment to\n    // match LEAST_UPPER_BOUND.\n\n    if (!found && bias === LEAST_UPPER_BOUND) min++;\n    if (min === -1 || min === segments.length) return []; // We may have found the segment that started at an earlier column. If this is the case, then we\n    // need to slice all generated segments that match _that_ column, because all such segments span\n    // to our desired column.\n\n    const matchedColumn = found ? column : segments[min][COLUMN]; // The binary search is not guaranteed to find the lower bound when a match wasn't found.\n\n    if (!found) min = lowerBound(segments, matchedColumn, min);\n    const max = upperBound(segments, matchedColumn, min);\n    const result = [];\n\n    for (; min <= max; min++) {\n      const segment = segments[min];\n      result.push(GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]));\n    }\n\n    return result;\n  }\n\n  exports.AnyMap = AnyMap;\n  exports.GREATEST_LOWER_BOUND = GREATEST_LOWER_BOUND;\n  exports.LEAST_UPPER_BOUND = LEAST_UPPER_BOUND;\n  exports.TraceMap = TraceMap;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":{"version":3,"names":["global","factory","exports","module","require","define","amd","globalThis","self","traceMapping","sourcemapCodec","resolveURI","resolveUri","_interopDefaultLegacy","e","resolveUri__default","resolve","input","base","endsWith","stripFilename","path","index","lastIndexOf","slice","COLUMN","SOURCES_INDEX","SOURCE_LINE","SOURCE_COLUMN","NAMES_INDEX","REV_GENERATED_LINE","REV_GENERATED_COLUMN","maybeSort","mappings","owned","unsortedIndex","nextUnsortedSegmentLine","length","i","sortSegments","start","isSorted","line","j","sort","sortComparator","a","b","found","binarySearch","haystack","needle","low","high","mid","cmp","upperBound","lowerBound","memoizedState","lastKey","lastNeedle","lastIndex","memoizedBinarySearch","state","key","buildBySources","decoded","memos","sources","map","buildNullArray","seg","sourceIndex","sourceLine","sourceColumn","originalSource","originalLine","memo","insert","array","value","__proto__","AnyMap","mapUrl","parsed","JSON","parse","TraceMap","sourcesContent","names","recurse","Infinity","joined","version","file","presortedDecodedMap","lineOffset","columnOffset","stopLine","stopColumn","sections","offset","sl","sc","nextOffset","Math","min","column","addSection","arguments","sourcesOffset","namesOffset","decodedMappings","resolvedSources","contents","append","push","lineI","out","getLine","cOffset","sourcesIndex","arr","other","LINE_GTR_ZERO","COL_GTR_EQ_ZERO","LEAST_UPPER_BOUND","GREATEST_LOWER_BOUND","encodedMappings","traceSegment","originalPositionFor","generatedPositionFor","allGeneratedPositionsFor","eachMapping","sourceContentFor","decodedMap","encodedMap","constructor","isString","_decodedMemo","sourceRoot","from","s","_encoded","_decoded","undefined","_bySources","_bySourceMemos","_a","encode","decode","segments","traceSegmentInternal","bias","Error","OMapping","segment","source","generatedPosition","cb","generatedLine","generatedColumn","originalColumn","name","indexOf","tracer","clone","all","GMapping","generated","sliceGeneratedPositions","matchedColumn","max","result","Object","defineProperty"],"sources":["/Users/deliabarbuta/Documents/An4Sem1/PAW/Proiect/proiect-paw-tadam/Frontend_OceanCross/node_modules/@jridgewell/trace-mapping/dist/trace-mapping.umd.js"],"sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@jridgewell/sourcemap-codec'), require('@jridgewell/resolve-uri')) :\n    typeof define === 'function' && define.amd ? define(['exports', '@jridgewell/sourcemap-codec', '@jridgewell/resolve-uri'], factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.traceMapping = {}, global.sourcemapCodec, global.resolveURI));\n})(this, (function (exports, sourcemapCodec, resolveUri) { 'use strict';\n\n    function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\n    var resolveUri__default = /*#__PURE__*/_interopDefaultLegacy(resolveUri);\n\n    function resolve(input, base) {\n        // The base is always treated as a directory, if it's not empty.\n        // https://github.com/mozilla/source-map/blob/8cb3ee57/lib/util.js#L327\n        // https://github.com/chromium/chromium/blob/da4adbb3/third_party/blink/renderer/devtools/front_end/sdk/SourceMap.js#L400-L401\n        if (base && !base.endsWith('/'))\n            base += '/';\n        return resolveUri__default[\"default\"](input, base);\n    }\n\n    /**\n     * Removes everything after the last \"/\", but leaves the slash.\n     */\n    function stripFilename(path) {\n        if (!path)\n            return '';\n        const index = path.lastIndexOf('/');\n        return path.slice(0, index + 1);\n    }\n\n    const COLUMN = 0;\n    const SOURCES_INDEX = 1;\n    const SOURCE_LINE = 2;\n    const SOURCE_COLUMN = 3;\n    const NAMES_INDEX = 4;\n    const REV_GENERATED_LINE = 1;\n    const REV_GENERATED_COLUMN = 2;\n\n    function maybeSort(mappings, owned) {\n        const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);\n        if (unsortedIndex === mappings.length)\n            return mappings;\n        // If we own the array (meaning we parsed it from JSON), then we're free to directly mutate it. If\n        // not, we do not want to modify the consumer's input array.\n        if (!owned)\n            mappings = mappings.slice();\n        for (let i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1)) {\n            mappings[i] = sortSegments(mappings[i], owned);\n        }\n        return mappings;\n    }\n    function nextUnsortedSegmentLine(mappings, start) {\n        for (let i = start; i < mappings.length; i++) {\n            if (!isSorted(mappings[i]))\n                return i;\n        }\n        return mappings.length;\n    }\n    function isSorted(line) {\n        for (let j = 1; j < line.length; j++) {\n            if (line[j][COLUMN] < line[j - 1][COLUMN]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    function sortSegments(line, owned) {\n        if (!owned)\n            line = line.slice();\n        return line.sort(sortComparator);\n    }\n    function sortComparator(a, b) {\n        return a[COLUMN] - b[COLUMN];\n    }\n\n    let found = false;\n    /**\n     * A binary search implementation that returns the index if a match is found.\n     * If no match is found, then the left-index (the index associated with the item that comes just\n     * before the desired index) is returned. To maintain proper sort order, a splice would happen at\n     * the next index:\n     *\n     * ```js\n     * const array = [1, 3];\n     * const needle = 2;\n     * const index = binarySearch(array, needle, (item, needle) => item - needle);\n     *\n     * assert.equal(index, 0);\n     * array.splice(index + 1, 0, needle);\n     * assert.deepEqual(array, [1, 2, 3]);\n     * ```\n     */\n    function binarySearch(haystack, needle, low, high) {\n        while (low <= high) {\n            const mid = low + ((high - low) >> 1);\n            const cmp = haystack[mid][COLUMN] - needle;\n            if (cmp === 0) {\n                found = true;\n                return mid;\n            }\n            if (cmp < 0) {\n                low = mid + 1;\n            }\n            else {\n                high = mid - 1;\n            }\n        }\n        found = false;\n        return low - 1;\n    }\n    function upperBound(haystack, needle, index) {\n        for (let i = index + 1; i < haystack.length; index = i++) {\n            if (haystack[i][COLUMN] !== needle)\n                break;\n        }\n        return index;\n    }\n    function lowerBound(haystack, needle, index) {\n        for (let i = index - 1; i >= 0; index = i--) {\n            if (haystack[i][COLUMN] !== needle)\n                break;\n        }\n        return index;\n    }\n    function memoizedState() {\n        return {\n            lastKey: -1,\n            lastNeedle: -1,\n            lastIndex: -1,\n        };\n    }\n    /**\n     * This overly complicated beast is just to record the last tested line/column and the resulting\n     * index, allowing us to skip a few tests if mappings are monotonically increasing.\n     */\n    function memoizedBinarySearch(haystack, needle, state, key) {\n        const { lastKey, lastNeedle, lastIndex } = state;\n        let low = 0;\n        let high = haystack.length - 1;\n        if (key === lastKey) {\n            if (needle === lastNeedle) {\n                found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle;\n                return lastIndex;\n            }\n            if (needle >= lastNeedle) {\n                // lastIndex may be -1 if the previous needle was not found.\n                low = lastIndex === -1 ? 0 : lastIndex;\n            }\n            else {\n                high = lastIndex;\n            }\n        }\n        state.lastKey = key;\n        state.lastNeedle = needle;\n        return (state.lastIndex = binarySearch(haystack, needle, low, high));\n    }\n\n    // Rebuilds the original source files, with mappings that are ordered by source line/column instead\n    // of generated line/column.\n    function buildBySources(decoded, memos) {\n        const sources = memos.map(buildNullArray);\n        for (let i = 0; i < decoded.length; i++) {\n            const line = decoded[i];\n            for (let j = 0; j < line.length; j++) {\n                const seg = line[j];\n                if (seg.length === 1)\n                    continue;\n                const sourceIndex = seg[SOURCES_INDEX];\n                const sourceLine = seg[SOURCE_LINE];\n                const sourceColumn = seg[SOURCE_COLUMN];\n                const originalSource = sources[sourceIndex];\n                const originalLine = (originalSource[sourceLine] || (originalSource[sourceLine] = []));\n                const memo = memos[sourceIndex];\n                // The binary search either found a match, or it found the left-index just before where the\n                // segment should go. Either way, we want to insert after that. And there may be multiple\n                // generated segments associated with an original location, so there may need to move several\n                // indexes before we find where we need to insert.\n                const index = upperBound(originalLine, sourceColumn, memoizedBinarySearch(originalLine, sourceColumn, memo, sourceLine));\n                insert(originalLine, (memo.lastIndex = index + 1), [sourceColumn, i, seg[COLUMN]]);\n            }\n        }\n        return sources;\n    }\n    function insert(array, index, value) {\n        for (let i = array.length; i > index; i--) {\n            array[i] = array[i - 1];\n        }\n        array[index] = value;\n    }\n    // Null arrays allow us to use ordered index keys without actually allocating contiguous memory like\n    // a real array. We use a null-prototype object to avoid prototype pollution and deoptimizations.\n    // Numeric properties on objects are magically sorted in ascending order by the engine regardless of\n    // the insertion order. So, by setting any numeric keys, even out of order, we'll get ascending\n    // order when iterating with for-in.\n    function buildNullArray() {\n        return { __proto__: null };\n    }\n\n    const AnyMap = function (map, mapUrl) {\n        const parsed = typeof map === 'string' ? JSON.parse(map) : map;\n        if (!('sections' in parsed))\n            return new TraceMap(parsed, mapUrl);\n        const mappings = [];\n        const sources = [];\n        const sourcesContent = [];\n        const names = [];\n        recurse(parsed, mapUrl, mappings, sources, sourcesContent, names, 0, 0, Infinity, Infinity);\n        const joined = {\n            version: 3,\n            file: parsed.file,\n            names,\n            sources,\n            sourcesContent,\n            mappings,\n        };\n        return exports.presortedDecodedMap(joined);\n    };\n    function recurse(input, mapUrl, mappings, sources, sourcesContent, names, lineOffset, columnOffset, stopLine, stopColumn) {\n        const { sections } = input;\n        for (let i = 0; i < sections.length; i++) {\n            const { map, offset } = sections[i];\n            let sl = stopLine;\n            let sc = stopColumn;\n            if (i + 1 < sections.length) {\n                const nextOffset = sections[i + 1].offset;\n                sl = Math.min(stopLine, lineOffset + nextOffset.line);\n                if (sl === stopLine) {\n                    sc = Math.min(stopColumn, columnOffset + nextOffset.column);\n                }\n                else if (sl < stopLine) {\n                    sc = columnOffset + nextOffset.column;\n                }\n            }\n            addSection(map, mapUrl, mappings, sources, sourcesContent, names, lineOffset + offset.line, columnOffset + offset.column, sl, sc);\n        }\n    }\n    function addSection(input, mapUrl, mappings, sources, sourcesContent, names, lineOffset, columnOffset, stopLine, stopColumn) {\n        if ('sections' in input)\n            return recurse(...arguments);\n        const map = new TraceMap(input, mapUrl);\n        const sourcesOffset = sources.length;\n        const namesOffset = names.length;\n        const decoded = exports.decodedMappings(map);\n        const { resolvedSources, sourcesContent: contents } = map;\n        append(sources, resolvedSources);\n        append(names, map.names);\n        if (contents)\n            append(sourcesContent, contents);\n        else\n            for (let i = 0; i < resolvedSources.length; i++)\n                sourcesContent.push(null);\n        for (let i = 0; i < decoded.length; i++) {\n            const lineI = lineOffset + i;\n            // We can only add so many lines before we step into the range that the next section's map\n            // controls. When we get to the last line, then we'll start checking the segments to see if\n            // they've crossed into the column range. But it may not have any columns that overstep, so we\n            // still need to check that we don't overstep lines, too.\n            if (lineI > stopLine)\n                return;\n            // The out line may already exist in mappings (if we're continuing the line started by a\n            // previous section). Or, we may have jumped ahead several lines to start this section.\n            const out = getLine(mappings, lineI);\n            // On the 0th loop, the section's column offset shifts us forward. On all other lines (since the\n            // map can be multiple lines), it doesn't.\n            const cOffset = i === 0 ? columnOffset : 0;\n            const line = decoded[i];\n            for (let j = 0; j < line.length; j++) {\n                const seg = line[j];\n                const column = cOffset + seg[COLUMN];\n                // If this segment steps into the column range that the next section's map controls, we need\n                // to stop early.\n                if (lineI === stopLine && column >= stopColumn)\n                    return;\n                if (seg.length === 1) {\n                    out.push([column]);\n                    continue;\n                }\n                const sourcesIndex = sourcesOffset + seg[SOURCES_INDEX];\n                const sourceLine = seg[SOURCE_LINE];\n                const sourceColumn = seg[SOURCE_COLUMN];\n                out.push(seg.length === 4\n                    ? [column, sourcesIndex, sourceLine, sourceColumn]\n                    : [column, sourcesIndex, sourceLine, sourceColumn, namesOffset + seg[NAMES_INDEX]]);\n            }\n        }\n    }\n    function append(arr, other) {\n        for (let i = 0; i < other.length; i++)\n            arr.push(other[i]);\n    }\n    function getLine(arr, index) {\n        for (let i = arr.length; i <= index; i++)\n            arr[i] = [];\n        return arr[index];\n    }\n\n    const LINE_GTR_ZERO = '`line` must be greater than 0 (lines start at line 1)';\n    const COL_GTR_EQ_ZERO = '`column` must be greater than or equal to 0 (columns start at column 0)';\n    const LEAST_UPPER_BOUND = -1;\n    const GREATEST_LOWER_BOUND = 1;\n    /**\n     * Returns the encoded (VLQ string) form of the SourceMap's mappings field.\n     */\n    exports.encodedMappings = void 0;\n    /**\n     * Returns the decoded (array of lines of segments) form of the SourceMap's mappings field.\n     */\n    exports.decodedMappings = void 0;\n    /**\n     * A low-level API to find the segment associated with a generated line/column (think, from a\n     * stack trace). Line and column here are 0-based, unlike `originalPositionFor`.\n     */\n    exports.traceSegment = void 0;\n    /**\n     * A higher-level API to find the source/line/column associated with a generated line/column\n     * (think, from a stack trace). Line is 1-based, but column is 0-based, due to legacy behavior in\n     * `source-map` library.\n     */\n    exports.originalPositionFor = void 0;\n    /**\n     * Finds the generated line/column position of the provided source/line/column source position.\n     */\n    exports.generatedPositionFor = void 0;\n    /**\n     * Finds all generated line/column positions of the provided source/line/column source position.\n     */\n    exports.allGeneratedPositionsFor = void 0;\n    /**\n     * Iterates each mapping in generated position order.\n     */\n    exports.eachMapping = void 0;\n    /**\n     * Retrieves the source content for a particular source, if its found. Returns null if not.\n     */\n    exports.sourceContentFor = void 0;\n    /**\n     * A helper that skips sorting of the input map's mappings array, which can be expensive for larger\n     * maps.\n     */\n    exports.presortedDecodedMap = void 0;\n    /**\n     * Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects\n     * a sourcemap, or to JSON.stringify.\n     */\n    exports.decodedMap = void 0;\n    /**\n     * Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects\n     * a sourcemap, or to JSON.stringify.\n     */\n    exports.encodedMap = void 0;\n    class TraceMap {\n        constructor(map, mapUrl) {\n            const isString = typeof map === 'string';\n            if (!isString && map._decodedMemo)\n                return map;\n            const parsed = (isString ? JSON.parse(map) : map);\n            const { version, file, names, sourceRoot, sources, sourcesContent } = parsed;\n            this.version = version;\n            this.file = file;\n            this.names = names;\n            this.sourceRoot = sourceRoot;\n            this.sources = sources;\n            this.sourcesContent = sourcesContent;\n            const from = resolve(sourceRoot || '', stripFilename(mapUrl));\n            this.resolvedSources = sources.map((s) => resolve(s || '', from));\n            const { mappings } = parsed;\n            if (typeof mappings === 'string') {\n                this._encoded = mappings;\n                this._decoded = undefined;\n            }\n            else {\n                this._encoded = undefined;\n                this._decoded = maybeSort(mappings, isString);\n            }\n            this._decodedMemo = memoizedState();\n            this._bySources = undefined;\n            this._bySourceMemos = undefined;\n        }\n    }\n    (() => {\n        exports.encodedMappings = (map) => {\n            var _a;\n            return ((_a = map._encoded) !== null && _a !== void 0 ? _a : (map._encoded = sourcemapCodec.encode(map._decoded)));\n        };\n        exports.decodedMappings = (map) => {\n            return (map._decoded || (map._decoded = sourcemapCodec.decode(map._encoded)));\n        };\n        exports.traceSegment = (map, line, column) => {\n            const decoded = exports.decodedMappings(map);\n            // It's common for parent source maps to have pointers to lines that have no\n            // mapping (like a \"//# sourceMappingURL=\") at the end of the child file.\n            if (line >= decoded.length)\n                return null;\n            const segments = decoded[line];\n            const index = traceSegmentInternal(segments, map._decodedMemo, line, column, GREATEST_LOWER_BOUND);\n            return index === -1 ? null : segments[index];\n        };\n        exports.originalPositionFor = (map, { line, column, bias }) => {\n            line--;\n            if (line < 0)\n                throw new Error(LINE_GTR_ZERO);\n            if (column < 0)\n                throw new Error(COL_GTR_EQ_ZERO);\n            const decoded = exports.decodedMappings(map);\n            // It's common for parent source maps to have pointers to lines that have no\n            // mapping (like a \"//# sourceMappingURL=\") at the end of the child file.\n            if (line >= decoded.length)\n                return OMapping(null, null, null, null);\n            const segments = decoded[line];\n            const index = traceSegmentInternal(segments, map._decodedMemo, line, column, bias || GREATEST_LOWER_BOUND);\n            if (index === -1)\n                return OMapping(null, null, null, null);\n            const segment = segments[index];\n            if (segment.length === 1)\n                return OMapping(null, null, null, null);\n            const { names, resolvedSources } = map;\n            return OMapping(resolvedSources[segment[SOURCES_INDEX]], segment[SOURCE_LINE] + 1, segment[SOURCE_COLUMN], segment.length === 5 ? names[segment[NAMES_INDEX]] : null);\n        };\n        exports.allGeneratedPositionsFor = (map, { source, line, column, bias }) => {\n            // SourceMapConsumer uses LEAST_UPPER_BOUND for some reason, so we follow suit.\n            return generatedPosition(map, source, line, column, bias || LEAST_UPPER_BOUND, true);\n        };\n        exports.generatedPositionFor = (map, { source, line, column, bias }) => {\n            return generatedPosition(map, source, line, column, bias || GREATEST_LOWER_BOUND, false);\n        };\n        exports.eachMapping = (map, cb) => {\n            const decoded = exports.decodedMappings(map);\n            const { names, resolvedSources } = map;\n            for (let i = 0; i < decoded.length; i++) {\n                const line = decoded[i];\n                for (let j = 0; j < line.length; j++) {\n                    const seg = line[j];\n                    const generatedLine = i + 1;\n                    const generatedColumn = seg[0];\n                    let source = null;\n                    let originalLine = null;\n                    let originalColumn = null;\n                    let name = null;\n                    if (seg.length !== 1) {\n                        source = resolvedSources[seg[1]];\n                        originalLine = seg[2] + 1;\n                        originalColumn = seg[3];\n                    }\n                    if (seg.length === 5)\n                        name = names[seg[4]];\n                    cb({\n                        generatedLine,\n                        generatedColumn,\n                        source,\n                        originalLine,\n                        originalColumn,\n                        name,\n                    });\n                }\n            }\n        };\n        exports.sourceContentFor = (map, source) => {\n            const { sources, resolvedSources, sourcesContent } = map;\n            if (sourcesContent == null)\n                return null;\n            let index = sources.indexOf(source);\n            if (index === -1)\n                index = resolvedSources.indexOf(source);\n            return index === -1 ? null : sourcesContent[index];\n        };\n        exports.presortedDecodedMap = (map, mapUrl) => {\n            const tracer = new TraceMap(clone(map, []), mapUrl);\n            tracer._decoded = map.mappings;\n            return tracer;\n        };\n        exports.decodedMap = (map) => {\n            return clone(map, exports.decodedMappings(map));\n        };\n        exports.encodedMap = (map) => {\n            return clone(map, exports.encodedMappings(map));\n        };\n        function generatedPosition(map, source, line, column, bias, all) {\n            line--;\n            if (line < 0)\n                throw new Error(LINE_GTR_ZERO);\n            if (column < 0)\n                throw new Error(COL_GTR_EQ_ZERO);\n            const { sources, resolvedSources } = map;\n            let sourceIndex = sources.indexOf(source);\n            if (sourceIndex === -1)\n                sourceIndex = resolvedSources.indexOf(source);\n            if (sourceIndex === -1)\n                return all ? [] : GMapping(null, null);\n            const generated = (map._bySources || (map._bySources = buildBySources(exports.decodedMappings(map), (map._bySourceMemos = sources.map(memoizedState)))));\n            const segments = generated[sourceIndex][line];\n            if (segments == null)\n                return all ? [] : GMapping(null, null);\n            const memo = map._bySourceMemos[sourceIndex];\n            if (all)\n                return sliceGeneratedPositions(segments, memo, line, column, bias);\n            const index = traceSegmentInternal(segments, memo, line, column, bias);\n            if (index === -1)\n                return GMapping(null, null);\n            const segment = segments[index];\n            return GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]);\n        }\n    })();\n    function clone(map, mappings) {\n        return {\n            version: map.version,\n            file: map.file,\n            names: map.names,\n            sourceRoot: map.sourceRoot,\n            sources: map.sources,\n            sourcesContent: map.sourcesContent,\n            mappings,\n        };\n    }\n    function OMapping(source, line, column, name) {\n        return { source, line, column, name };\n    }\n    function GMapping(line, column) {\n        return { line, column };\n    }\n    function traceSegmentInternal(segments, memo, line, column, bias) {\n        let index = memoizedBinarySearch(segments, column, memo, line);\n        if (found) {\n            index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);\n        }\n        else if (bias === LEAST_UPPER_BOUND)\n            index++;\n        if (index === -1 || index === segments.length)\n            return -1;\n        return index;\n    }\n    function sliceGeneratedPositions(segments, memo, line, column, bias) {\n        let min = traceSegmentInternal(segments, memo, line, column, GREATEST_LOWER_BOUND);\n        // We ignored the bias when tracing the segment so that we're guarnateed to find the first (in\n        // insertion order) segment that matched. Even if we did respect the bias when tracing, we would\n        // still need to call `lowerBound()` to find the first segment, which is slower than just looking\n        // for the GREATEST_LOWER_BOUND to begin with. The only difference that matters for us is when the\n        // binary search didn't match, in which case GREATEST_LOWER_BOUND just needs to increment to\n        // match LEAST_UPPER_BOUND.\n        if (!found && bias === LEAST_UPPER_BOUND)\n            min++;\n        if (min === -1 || min === segments.length)\n            return [];\n        // We may have found the segment that started at an earlier column. If this is the case, then we\n        // need to slice all generated segments that match _that_ column, because all such segments span\n        // to our desired column.\n        const matchedColumn = found ? column : segments[min][COLUMN];\n        // The binary search is not guaranteed to find the lower bound when a match wasn't found.\n        if (!found)\n            min = lowerBound(segments, matchedColumn, min);\n        const max = upperBound(segments, matchedColumn, min);\n        const result = [];\n        for (; min <= max; min++) {\n            const segment = segments[min];\n            result.push(GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]));\n        }\n        return result;\n    }\n\n    exports.AnyMap = AnyMap;\n    exports.GREATEST_LOWER_BOUND = GREATEST_LOWER_BOUND;\n    exports.LEAST_UPPER_BOUND = LEAST_UPPER_BOUND;\n    exports.TraceMap = TraceMap;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}