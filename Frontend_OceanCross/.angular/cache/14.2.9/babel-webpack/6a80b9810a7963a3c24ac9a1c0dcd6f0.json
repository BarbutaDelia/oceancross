{"ast":null,"code":"const debug = require('debug')('log4js:fileSync');\n\nconst path = require('path');\n\nconst fs = require('fs');\n\nconst os = require('os');\n\nconst eol = os.EOL;\n\nfunction touchFile(file, options) {\n  // attempt to create the directory\n  const mkdir = dir => {\n    try {\n      return fs.mkdirSync(dir, {\n        recursive: true\n      });\n    } catch (e) {\n      // backward-compatible fs.mkdirSync for nodejs pre-10.12.0 (without recursive option)\n      // recursive creation of parent first\n      if (e.code === 'ENOENT') {\n        mkdir(path.dirname(dir));\n        return mkdir(dir);\n      } // throw error for all except EEXIST and EROFS (read-only filesystem)\n\n\n      if (e.code !== 'EEXIST' && e.code !== 'EROFS') {\n        throw e;\n      } // EEXIST: throw if file and not directory\n      // EROFS : throw if directory not found\n      else {\n        try {\n          if (fs.statSync(dir).isDirectory()) {\n            return dir;\n          }\n\n          throw e;\n        } catch (err) {\n          throw e;\n        }\n      }\n    }\n  };\n\n  mkdir(path.dirname(file)); // try to throw EISDIR, EROFS, EACCES\n\n  fs.appendFileSync(file, '', {\n    mode: options.mode,\n    flag: options.flags\n  });\n}\n\nclass RollingFileSync {\n  constructor(filename, maxLogSize, backups, options) {\n    debug('In RollingFileStream');\n\n    if (maxLogSize < 0) {\n      throw new Error(`maxLogSize (${maxLogSize}) should be > 0`);\n    }\n\n    this.filename = filename;\n    this.size = maxLogSize;\n    this.backups = backups;\n    this.options = options;\n    this.currentSize = 0;\n\n    function currentFileSize(file) {\n      let fileSize = 0;\n\n      try {\n        fileSize = fs.statSync(file).size;\n      } catch (e) {\n        // file does not exist\n        touchFile(file, options);\n      }\n\n      return fileSize;\n    }\n\n    this.currentSize = currentFileSize(this.filename);\n  }\n\n  shouldRoll() {\n    debug('should roll with current size %d, and max size %d', this.currentSize, this.size);\n    return this.currentSize >= this.size;\n  }\n\n  roll(filename) {\n    const that = this;\n    const nameMatcher = new RegExp(`^${path.basename(filename)}`);\n\n    function justTheseFiles(item) {\n      return nameMatcher.test(item);\n    }\n\n    function index(filename_) {\n      return parseInt(filename_.slice(`${path.basename(filename)}.`.length), 10) || 0;\n    }\n\n    function byIndex(a, b) {\n      return index(a) - index(b);\n    }\n\n    function increaseFileIndex(fileToRename) {\n      const idx = index(fileToRename);\n      debug(`Index of ${fileToRename} is ${idx}`);\n\n      if (that.backups === 0) {\n        fs.truncateSync(filename, 0);\n      } else if (idx < that.backups) {\n        // on windows, you can get a EEXIST error if you rename a file to an existing file\n        // so, we'll try to delete the file we're renaming to first\n        try {\n          fs.unlinkSync(`${filename}.${idx + 1}`);\n        } catch (e) {// ignore err: if we could not delete, it's most likely that it doesn't exist\n        }\n\n        debug(`Renaming ${fileToRename} -> ${filename}.${idx + 1}`);\n        fs.renameSync(path.join(path.dirname(filename), fileToRename), `${filename}.${idx + 1}`);\n      }\n    }\n\n    function renameTheFiles() {\n      // roll the backups (rename file.n to file.n+1, where n <= numBackups)\n      debug('Renaming the old files');\n      const files = fs.readdirSync(path.dirname(filename));\n      files.filter(justTheseFiles).sort(byIndex).reverse().forEach(increaseFileIndex);\n    }\n\n    debug('Rolling, rolling, rolling');\n    renameTheFiles();\n  } // eslint-disable-next-line no-unused-vars\n\n\n  write(chunk, encoding) {\n    const that = this;\n\n    function writeTheChunk() {\n      debug('writing the chunk to the file');\n      that.currentSize += chunk.length;\n      fs.appendFileSync(that.filename, chunk);\n    }\n\n    debug('in write');\n\n    if (this.shouldRoll()) {\n      this.currentSize = 0;\n      this.roll(this.filename);\n    }\n\n    writeTheChunk();\n  }\n\n}\n/**\n * File Appender writing the logs to a text file. Supports rolling of logs by size.\n *\n * @param file the file log messages will be written to\n * @param layout a function that takes a logevent and returns a string\n *   (defaults to basicLayout).\n * @param logSize - the maximum size (in bytes) for a log file,\n *   if not provided then logs won't be rotated.\n * @param numBackups - the number of log files to keep after logSize\n *   has been reached (default 5)\n * @param options - options to be passed to the underlying stream\n * @param timezoneOffset - optional timezone offset in minutes (default system local)\n */\n\n\nfunction fileAppender(file, layout, logSize, numBackups, options, timezoneOffset) {\n  if (typeof file !== 'string' || file.length === 0) {\n    throw new Error(`Invalid filename: ${file}`);\n  } else if (file.endsWith(path.sep)) {\n    throw new Error(`Filename is a directory: ${file}`);\n  } else {\n    // handle ~ expansion: https://github.com/nodejs/node/issues/684\n    // exclude ~ and ~filename as these can be valid files\n    file = file.replace(new RegExp(`^~(?=${path.sep}.+)`), os.homedir());\n  }\n\n  file = path.normalize(file);\n  numBackups = !numBackups && numBackups !== 0 ? 5 : numBackups;\n  debug('Creating fileSync appender (', file, ', ', logSize, ', ', numBackups, ', ', options, ', ', timezoneOffset, ')');\n\n  function openTheStream(filePath, fileSize, numFiles) {\n    let stream;\n\n    if (fileSize) {\n      stream = new RollingFileSync(filePath, fileSize, numFiles, options);\n    } else {\n      stream = (f => {\n        // touch the file to apply flags (like w to truncate the file)\n        touchFile(f, options);\n        return {\n          write(data) {\n            fs.appendFileSync(f, data);\n          }\n\n        };\n      })(filePath);\n    }\n\n    return stream;\n  }\n\n  const logFile = openTheStream(file, logSize, numBackups);\n  return loggingEvent => {\n    logFile.write(layout(loggingEvent, timezoneOffset) + eol);\n  };\n}\n\nfunction configure(config, layouts) {\n  let layout = layouts.basicLayout;\n\n  if (config.layout) {\n    layout = layouts.layout(config.layout.type, config.layout);\n  }\n\n  const options = {\n    flags: config.flags || 'a',\n    encoding: config.encoding || 'utf8',\n    mode: config.mode || 0o600\n  };\n  return fileAppender(config.filename, layout, config.maxLogSize, config.backups, options, config.timezoneOffset);\n}\n\nmodule.exports.configure = configure;","map":{"version":3,"names":["debug","require","path","fs","os","eol","EOL","touchFile","file","options","mkdir","dir","mkdirSync","recursive","e","code","dirname","statSync","isDirectory","err","appendFileSync","mode","flag","flags","RollingFileSync","constructor","filename","maxLogSize","backups","Error","size","currentSize","currentFileSize","fileSize","shouldRoll","roll","that","nameMatcher","RegExp","basename","justTheseFiles","item","test","index","filename_","parseInt","slice","length","byIndex","a","b","increaseFileIndex","fileToRename","idx","truncateSync","unlinkSync","renameSync","join","renameTheFiles","files","readdirSync","filter","sort","reverse","forEach","write","chunk","encoding","writeTheChunk","fileAppender","layout","logSize","numBackups","timezoneOffset","endsWith","sep","replace","homedir","normalize","openTheStream","filePath","numFiles","stream","f","data","logFile","loggingEvent","configure","config","layouts","basicLayout","type","module","exports"],"sources":["/Users/deliabarbuta/Documents/An4Sem1/PAW/Proiect/proiect-paw-tadam/Frontend_OceanCross/node_modules/log4js/lib/appenders/fileSync.js"],"sourcesContent":["const debug = require('debug')('log4js:fileSync');\nconst path = require('path');\nconst fs = require('fs');\nconst os = require('os');\n\nconst eol = os.EOL;\n\nfunction touchFile(file, options) {\n  // attempt to create the directory\n  const mkdir = (dir) => {\n    try {\n      return fs.mkdirSync(dir, { recursive: true });\n    } catch (e) {\n      // backward-compatible fs.mkdirSync for nodejs pre-10.12.0 (without recursive option)\n      // recursive creation of parent first\n      if (e.code === 'ENOENT') {\n        mkdir(path.dirname(dir));\n        return mkdir(dir);\n      }\n\n      // throw error for all except EEXIST and EROFS (read-only filesystem)\n      if (e.code !== 'EEXIST' && e.code !== 'EROFS') {\n        throw e;\n      }\n\n      // EEXIST: throw if file and not directory\n      // EROFS : throw if directory not found\n      else {\n        try {\n          if (fs.statSync(dir).isDirectory()) {\n            return dir;\n          }\n          throw e;\n        } catch (err) {\n          throw e;\n        }\n      }\n    }\n  };\n  mkdir(path.dirname(file));\n\n  // try to throw EISDIR, EROFS, EACCES\n  fs.appendFileSync(file, '', { mode: options.mode, flag: options.flags });\n}\n\nclass RollingFileSync {\n  constructor(filename, maxLogSize, backups, options) {\n    debug('In RollingFileStream');\n\n    if (maxLogSize < 0) {\n      throw new Error(`maxLogSize (${maxLogSize}) should be > 0`);\n    }\n\n    this.filename = filename;\n    this.size = maxLogSize;\n    this.backups = backups;\n    this.options = options;\n    this.currentSize = 0;\n\n    function currentFileSize(file) {\n      let fileSize = 0;\n\n      try {\n        fileSize = fs.statSync(file).size;\n      } catch (e) {\n        // file does not exist\n        touchFile(file, options);\n      }\n      return fileSize;\n    }\n\n    this.currentSize = currentFileSize(this.filename);\n  }\n\n  shouldRoll() {\n    debug(\n      'should roll with current size %d, and max size %d',\n      this.currentSize,\n      this.size\n    );\n    return this.currentSize >= this.size;\n  }\n\n  roll(filename) {\n    const that = this;\n    const nameMatcher = new RegExp(`^${path.basename(filename)}`);\n\n    function justTheseFiles(item) {\n      return nameMatcher.test(item);\n    }\n\n    function index(filename_) {\n      return (\n        parseInt(filename_.slice(`${path.basename(filename)}.`.length), 10) || 0\n      );\n    }\n\n    function byIndex(a, b) {\n      return index(a) - index(b);\n    }\n\n    function increaseFileIndex(fileToRename) {\n      const idx = index(fileToRename);\n      debug(`Index of ${fileToRename} is ${idx}`);\n      if (that.backups === 0) {\n        fs.truncateSync(filename, 0);\n      } else if (idx < that.backups) {\n        // on windows, you can get a EEXIST error if you rename a file to an existing file\n        // so, we'll try to delete the file we're renaming to first\n        try {\n          fs.unlinkSync(`${filename}.${idx + 1}`);\n        } catch (e) {\n          // ignore err: if we could not delete, it's most likely that it doesn't exist\n        }\n\n        debug(`Renaming ${fileToRename} -> ${filename}.${idx + 1}`);\n        fs.renameSync(\n          path.join(path.dirname(filename), fileToRename),\n          `${filename}.${idx + 1}`\n        );\n      }\n    }\n\n    function renameTheFiles() {\n      // roll the backups (rename file.n to file.n+1, where n <= numBackups)\n      debug('Renaming the old files');\n\n      const files = fs.readdirSync(path.dirname(filename));\n      files\n        .filter(justTheseFiles)\n        .sort(byIndex)\n        .reverse()\n        .forEach(increaseFileIndex);\n    }\n\n    debug('Rolling, rolling, rolling');\n    renameTheFiles();\n  }\n\n  // eslint-disable-next-line no-unused-vars\n  write(chunk, encoding) {\n    const that = this;\n\n    function writeTheChunk() {\n      debug('writing the chunk to the file');\n      that.currentSize += chunk.length;\n      fs.appendFileSync(that.filename, chunk);\n    }\n\n    debug('in write');\n\n    if (this.shouldRoll()) {\n      this.currentSize = 0;\n      this.roll(this.filename);\n    }\n\n    writeTheChunk();\n  }\n}\n\n/**\n * File Appender writing the logs to a text file. Supports rolling of logs by size.\n *\n * @param file the file log messages will be written to\n * @param layout a function that takes a logevent and returns a string\n *   (defaults to basicLayout).\n * @param logSize - the maximum size (in bytes) for a log file,\n *   if not provided then logs won't be rotated.\n * @param numBackups - the number of log files to keep after logSize\n *   has been reached (default 5)\n * @param options - options to be passed to the underlying stream\n * @param timezoneOffset - optional timezone offset in minutes (default system local)\n */\nfunction fileAppender(\n  file,\n  layout,\n  logSize,\n  numBackups,\n  options,\n  timezoneOffset\n) {\n  if (typeof file !== 'string' || file.length === 0) {\n    throw new Error(`Invalid filename: ${file}`);\n  } else if (file.endsWith(path.sep)) {\n    throw new Error(`Filename is a directory: ${file}`);\n  } else {\n    // handle ~ expansion: https://github.com/nodejs/node/issues/684\n    // exclude ~ and ~filename as these can be valid files\n    file = file.replace(new RegExp(`^~(?=${path.sep}.+)`), os.homedir());\n  }\n  file = path.normalize(file);\n  numBackups = !numBackups && numBackups !== 0 ? 5 : numBackups;\n\n  debug(\n    'Creating fileSync appender (',\n    file,\n    ', ',\n    logSize,\n    ', ',\n    numBackups,\n    ', ',\n    options,\n    ', ',\n    timezoneOffset,\n    ')'\n  );\n\n  function openTheStream(filePath, fileSize, numFiles) {\n    let stream;\n\n    if (fileSize) {\n      stream = new RollingFileSync(filePath, fileSize, numFiles, options);\n    } else {\n      stream = ((f) => {\n        // touch the file to apply flags (like w to truncate the file)\n        touchFile(f, options);\n\n        return {\n          write(data) {\n            fs.appendFileSync(f, data);\n          },\n        };\n      })(filePath);\n    }\n\n    return stream;\n  }\n\n  const logFile = openTheStream(file, logSize, numBackups);\n\n  return (loggingEvent) => {\n    logFile.write(layout(loggingEvent, timezoneOffset) + eol);\n  };\n}\n\nfunction configure(config, layouts) {\n  let layout = layouts.basicLayout;\n  if (config.layout) {\n    layout = layouts.layout(config.layout.type, config.layout);\n  }\n\n  const options = {\n    flags: config.flags || 'a',\n    encoding: config.encoding || 'utf8',\n    mode: config.mode || 0o600,\n  };\n\n  return fileAppender(\n    config.filename,\n    layout,\n    config.maxLogSize,\n    config.backups,\n    options,\n    config.timezoneOffset\n  );\n}\n\nmodule.exports.configure = configure;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}