{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/deliabarbuta/Documents/An4Sem1/PAW/Proiect/proiect-paw-tadam/Frontend_OceanCross/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nconst {\n  promisify\n} = require('util');\n\nconst mm = require('minimatch');\n\nconst Glob = require('glob').Glob;\n\nconst fs = require('graceful-fs');\n\nconst statAsync = promisify(fs.stat.bind(fs));\n\nconst pathLib = require('path');\n\nconst _ = require('lodash');\n\nconst File = require('./file');\n\nconst Url = require('./url');\n\nconst helper = require('./helper');\n\nconst log = require('./logger').create('filelist');\n\nconst createPatternObject = require('./config').createPatternObject;\n\nclass FileList {\n  constructor(patterns, excludes, emitter, preprocess, autoWatchBatchDelay) {\n    this._patterns = patterns || [];\n    this._excludes = excludes || [];\n    this._emitter = emitter;\n    this._preprocess = preprocess;\n    this.buckets = new Map(); // A promise that is pending if and only if we are active in this.refresh_()\n\n    this._refreshing = null;\n\n    const emit = () => {\n      this._emitter.emit('file_list_modified', this.files);\n    };\n\n    const debouncedEmit = _.debounce(emit, autoWatchBatchDelay);\n\n    this._emitModified = immediate => {\n      immediate ? emit() : debouncedEmit();\n    };\n  }\n\n  _findExcluded(path) {\n    return this._excludes.find(pattern => mm(path, pattern));\n  }\n\n  _findIncluded(path) {\n    return this._patterns.find(pattern => mm(path, pattern.pattern));\n  }\n\n  _findFile(path, pattern) {\n    if (!path || !pattern) return;\n    return this._getFilesByPattern(pattern.pattern).find(file => file.originalPath === path);\n  }\n\n  _exists(path) {\n    return !!this._patterns.find(pattern => mm(path, pattern.pattern) && this._findFile(path, pattern));\n  }\n\n  _getFilesByPattern(pattern) {\n    return this.buckets.get(pattern) || [];\n  }\n\n  _refresh() {\n    var _this = this;\n\n    const matchedFiles = new Set();\n    let lastCompletedRefresh = this._refreshing;\n    lastCompletedRefresh = Promise.all(this._patterns.map( /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(function* ({\n        pattern,\n        type,\n        nocache,\n        isBinary,\n        integrity\n      }) {\n        if (helper.isUrlAbsolute(pattern)) {\n          _this.buckets.set(pattern, [new Url(pattern, type, integrity)]);\n\n          return;\n        }\n\n        const mg = new Glob(pathLib.normalize(pattern), {\n          cwd: '/',\n          follow: true,\n          nodir: true,\n          sync: true\n        });\n        const files = mg.found.filter(path => {\n          if (_this._findExcluded(path)) {\n            log.debug(`Excluded file \"${path}\"`);\n            return false;\n          } else if (matchedFiles.has(path)) {\n            return false;\n          } else {\n            matchedFiles.add(path);\n            return true;\n          }\n        }).map(path => new File(path, mg.statCache[path].mtime, nocache, type, isBinary));\n\n        if (nocache) {\n          log.debug(`Not preprocessing \"${pattern}\" due to nocache`);\n        } else {\n          yield Promise.all(files.map(file => _this._preprocess(file)));\n        }\n\n        _this.buckets.set(pattern, files);\n\n        if (_.isEmpty(mg.found)) {\n          log.warn(`Pattern \"${pattern}\" does not match any file.`);\n        } else if (_.isEmpty(files)) {\n          log.warn(`All files matched by \"${pattern}\" were excluded or matched by prior matchers.`);\n        }\n      });\n\n      return function (_x) {\n        return _ref.apply(this, arguments);\n      };\n    }())).then(() => {\n      // When we return from this function the file processing chain will be\n      // complete. In the case of two fast refresh() calls, the second call\n      // will overwrite this._refreshing, and we want the status to reflect\n      // the second call and skip the modification event from the first call.\n      if (this._refreshing !== lastCompletedRefresh) {\n        return this._refreshing;\n      }\n\n      this._emitModified(true);\n\n      return this.files;\n    });\n    return lastCompletedRefresh;\n  }\n\n  get files() {\n    const served = [];\n    const included = {};\n    const lookup = {};\n\n    this._patterns.forEach(p => {\n      // This needs to be here sadly, as plugins are modifiying\n      // the _patterns directly resulting in elements not being\n      // instantiated properly\n      if (p.constructor.name !== 'Pattern') {\n        p = createPatternObject(p);\n      }\n\n      const files = this._getFilesByPattern(p.pattern);\n\n      files.sort((a, b) => {\n        if (a.path > b.path) return 1;\n        if (a.path < b.path) return -1;\n        return 0;\n      });\n\n      if (p.served) {\n        served.push(...files);\n      }\n\n      files.forEach(file => {\n        if (lookup[file.path] && lookup[file.path].compare(p) < 0) return;\n        lookup[file.path] = p;\n\n        if (p.included) {\n          included[file.path] = file;\n        } else {\n          delete included[file.path];\n        }\n      });\n    });\n\n    return {\n      served: _.uniq(served, 'path'),\n      included: _.values(included)\n    };\n  }\n\n  refresh() {\n    this._refreshing = this._refresh();\n    return this._refreshing;\n  }\n\n  reload(patterns, excludes) {\n    this._patterns = patterns || [];\n    this._excludes = excludes || [];\n    return this.refresh();\n  }\n\n  addFile(path) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const excluded = _this2._findExcluded(path);\n\n      if (excluded) {\n        log.debug(`Add file \"${path}\" ignored. Excluded by \"${excluded}\".`);\n        return _this2.files;\n      }\n\n      const pattern = _this2._findIncluded(path);\n\n      if (!pattern) {\n        log.debug(`Add file \"${path}\" ignored. Does not match any pattern.`);\n        return _this2.files;\n      }\n\n      if (_this2._exists(path)) {\n        log.debug(`Add file \"${path}\" ignored. Already in the list.`);\n        return _this2.files;\n      }\n\n      const file = new File(path);\n\n      _this2._getFilesByPattern(pattern.pattern).push(file);\n\n      const [stat] = yield Promise.all([statAsync(path), _this2._refreshing]);\n      file.mtime = stat.mtime;\n      yield _this2._preprocess(file);\n      log.info(`Added file \"${path}\".`);\n\n      _this2._emitModified();\n\n      return _this2.files;\n    })();\n  }\n\n  changeFile(path, force) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      const pattern = _this3._findIncluded(path);\n\n      const file = _this3._findFile(path, pattern);\n\n      if (!file) {\n        log.debug(`Changed file \"${path}\" ignored. Does not match any file in the list.`);\n        return _this3.files;\n      }\n\n      const [stat] = yield Promise.all([statAsync(path), _this3._refreshing]);\n\n      if (force || stat.mtime > file.mtime) {\n        file.mtime = stat.mtime;\n        yield _this3._preprocess(file);\n        log.info(`Changed file \"${path}\".`);\n\n        _this3._emitModified(force);\n      }\n\n      return _this3.files;\n    })();\n  }\n\n  removeFile(path) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      const pattern = _this4._findIncluded(path);\n\n      const file = _this4._findFile(path, pattern);\n\n      if (file) {\n        helper.arrayRemove(_this4._getFilesByPattern(pattern.pattern), file);\n        log.info(`Removed file \"${path}\".`);\n\n        _this4._emitModified();\n      } else {\n        log.debug(`Removed file \"${path}\" ignored. Does not match any file in the list.`);\n      }\n\n      return _this4.files;\n    })();\n  }\n\n}\n\nFileList.factory = function (config, emitter, preprocess) {\n  return new FileList(config.files, config.exclude, emitter, preprocess, config.autoWatchBatchDelay);\n};\n\nFileList.factory.$inject = ['config', 'emitter', 'preprocess'];\nmodule.exports = FileList;","map":{"version":3,"names":["promisify","require","mm","Glob","fs","statAsync","stat","bind","pathLib","_","File","Url","helper","log","create","createPatternObject","FileList","constructor","patterns","excludes","emitter","preprocess","autoWatchBatchDelay","_patterns","_excludes","_emitter","_preprocess","buckets","Map","_refreshing","emit","files","debouncedEmit","debounce","_emitModified","immediate","_findExcluded","path","find","pattern","_findIncluded","_findFile","_getFilesByPattern","file","originalPath","_exists","get","_refresh","matchedFiles","Set","lastCompletedRefresh","Promise","all","map","type","nocache","isBinary","integrity","isUrlAbsolute","set","mg","normalize","cwd","follow","nodir","sync","found","filter","debug","has","add","statCache","mtime","isEmpty","warn","then","served","included","lookup","forEach","p","name","sort","a","b","push","compare","uniq","values","refresh","reload","addFile","excluded","info","changeFile","force","removeFile","arrayRemove","factory","config","exclude","$inject","module","exports"],"sources":["/Users/deliabarbuta/Documents/An4Sem1/PAW/Proiect/proiect-paw-tadam/Frontend_OceanCross/node_modules/karma/lib/file-list.js"],"sourcesContent":["'use strict'\n\nconst { promisify } = require('util')\nconst mm = require('minimatch')\nconst Glob = require('glob').Glob\nconst fs = require('graceful-fs')\nconst statAsync = promisify(fs.stat.bind(fs))\nconst pathLib = require('path')\nconst _ = require('lodash')\n\nconst File = require('./file')\nconst Url = require('./url')\nconst helper = require('./helper')\nconst log = require('./logger').create('filelist')\nconst createPatternObject = require('./config').createPatternObject\n\nclass FileList {\n  constructor (patterns, excludes, emitter, preprocess, autoWatchBatchDelay) {\n    this._patterns = patterns || []\n    this._excludes = excludes || []\n    this._emitter = emitter\n    this._preprocess = preprocess\n\n    this.buckets = new Map()\n\n    // A promise that is pending if and only if we are active in this.refresh_()\n    this._refreshing = null\n\n    const emit = () => {\n      this._emitter.emit('file_list_modified', this.files)\n    }\n\n    const debouncedEmit = _.debounce(emit, autoWatchBatchDelay)\n    this._emitModified = (immediate) => {\n      immediate ? emit() : debouncedEmit()\n    }\n  }\n\n  _findExcluded (path) {\n    return this._excludes.find((pattern) => mm(path, pattern))\n  }\n\n  _findIncluded (path) {\n    return this._patterns.find((pattern) => mm(path, pattern.pattern))\n  }\n\n  _findFile (path, pattern) {\n    if (!path || !pattern) return\n    return this._getFilesByPattern(pattern.pattern).find((file) => file.originalPath === path)\n  }\n\n  _exists (path) {\n    return !!this._patterns.find((pattern) => mm(path, pattern.pattern) && this._findFile(path, pattern))\n  }\n\n  _getFilesByPattern (pattern) {\n    return this.buckets.get(pattern) || []\n  }\n\n  _refresh () {\n    const matchedFiles = new Set()\n\n    let lastCompletedRefresh = this._refreshing\n    lastCompletedRefresh = Promise.all(\n      this._patterns.map(async ({ pattern, type, nocache, isBinary, integrity }) => {\n        if (helper.isUrlAbsolute(pattern)) {\n          this.buckets.set(pattern, [new Url(pattern, type, integrity)])\n          return\n        }\n\n        const mg = new Glob(pathLib.normalize(pattern), { cwd: '/', follow: true, nodir: true, sync: true })\n\n        const files = mg.found\n          .filter((path) => {\n            if (this._findExcluded(path)) {\n              log.debug(`Excluded file \"${path}\"`)\n              return false\n            } else if (matchedFiles.has(path)) {\n              return false\n            } else {\n              matchedFiles.add(path)\n              return true\n            }\n          })\n          .map((path) => new File(path, mg.statCache[path].mtime, nocache, type, isBinary))\n\n        if (nocache) {\n          log.debug(`Not preprocessing \"${pattern}\" due to nocache`)\n        } else {\n          await Promise.all(files.map((file) => this._preprocess(file)))\n        }\n\n        this.buckets.set(pattern, files)\n\n        if (_.isEmpty(mg.found)) {\n          log.warn(`Pattern \"${pattern}\" does not match any file.`)\n        } else if (_.isEmpty(files)) {\n          log.warn(`All files matched by \"${pattern}\" were excluded or matched by prior matchers.`)\n        }\n      })\n    )\n      .then(() => {\n        // When we return from this function the file processing chain will be\n        // complete. In the case of two fast refresh() calls, the second call\n        // will overwrite this._refreshing, and we want the status to reflect\n        // the second call and skip the modification event from the first call.\n        if (this._refreshing !== lastCompletedRefresh) {\n          return this._refreshing\n        }\n        this._emitModified(true)\n        return this.files\n      })\n\n    return lastCompletedRefresh\n  }\n\n  get files () {\n    const served = []\n    const included = {}\n    const lookup = {}\n    this._patterns.forEach((p) => {\n      // This needs to be here sadly, as plugins are modifiying\n      // the _patterns directly resulting in elements not being\n      // instantiated properly\n      if (p.constructor.name !== 'Pattern') {\n        p = createPatternObject(p)\n      }\n\n      const files = this._getFilesByPattern(p.pattern)\n      files.sort((a, b) => {\n        if (a.path > b.path) return 1\n        if (a.path < b.path) return -1\n\n        return 0\n      })\n\n      if (p.served) {\n        served.push(...files)\n      }\n\n      files.forEach((file) => {\n        if (lookup[file.path] && lookup[file.path].compare(p) < 0) return\n\n        lookup[file.path] = p\n        if (p.included) {\n          included[file.path] = file\n        } else {\n          delete included[file.path]\n        }\n      })\n    })\n\n    return {\n      served: _.uniq(served, 'path'),\n      included: _.values(included)\n    }\n  }\n\n  refresh () {\n    this._refreshing = this._refresh()\n    return this._refreshing\n  }\n\n  reload (patterns, excludes) {\n    this._patterns = patterns || []\n    this._excludes = excludes || []\n\n    return this.refresh()\n  }\n\n  async addFile (path) {\n    const excluded = this._findExcluded(path)\n    if (excluded) {\n      log.debug(`Add file \"${path}\" ignored. Excluded by \"${excluded}\".`)\n      return this.files\n    }\n\n    const pattern = this._findIncluded(path)\n    if (!pattern) {\n      log.debug(`Add file \"${path}\" ignored. Does not match any pattern.`)\n      return this.files\n    }\n\n    if (this._exists(path)) {\n      log.debug(`Add file \"${path}\" ignored. Already in the list.`)\n      return this.files\n    }\n\n    const file = new File(path)\n    this._getFilesByPattern(pattern.pattern).push(file)\n\n    const [stat] = await Promise.all([statAsync(path), this._refreshing])\n    file.mtime = stat.mtime\n    await this._preprocess(file)\n\n    log.info(`Added file \"${path}\".`)\n    this._emitModified()\n    return this.files\n  }\n\n  async changeFile (path, force) {\n    const pattern = this._findIncluded(path)\n    const file = this._findFile(path, pattern)\n\n    if (!file) {\n      log.debug(`Changed file \"${path}\" ignored. Does not match any file in the list.`)\n      return this.files\n    }\n\n    const [stat] = await Promise.all([statAsync(path), this._refreshing])\n    if (force || stat.mtime > file.mtime) {\n      file.mtime = stat.mtime\n      await this._preprocess(file)\n      log.info(`Changed file \"${path}\".`)\n      this._emitModified(force)\n    }\n    return this.files\n  }\n\n  async removeFile (path) {\n    const pattern = this._findIncluded(path)\n    const file = this._findFile(path, pattern)\n\n    if (file) {\n      helper.arrayRemove(this._getFilesByPattern(pattern.pattern), file)\n      log.info(`Removed file \"${path}\".`)\n\n      this._emitModified()\n    } else {\n      log.debug(`Removed file \"${path}\" ignored. Does not match any file in the list.`)\n    }\n    return this.files\n  }\n}\n\nFileList.factory = function (config, emitter, preprocess) {\n  return new FileList(config.files, config.exclude, emitter, preprocess, config.autoWatchBatchDelay)\n}\n\nFileList.factory.$inject = ['config', 'emitter', 'preprocess']\n\nmodule.exports = FileList\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}