{"ast":null,"code":"var Module = require('./module');\n\nvar autoAnnotate = require('./annotation').parse;\n\nvar Injector = function (modules, parent) {\n  parent = parent || {\n    get: function (name) {\n      currentlyResolving.push(name);\n      throw error('No provider for \"' + name + '\"!');\n    }\n  };\n  var currentlyResolving = [];\n  var providers = this._providers = Object.create(parent._providers || null);\n  var instances = this._instances = Object.create(null);\n  instances.injector = this;\n\n  var error = function (msg) {\n    var stack = currentlyResolving.join(' -> ');\n    currentlyResolving.length = 0;\n    return new Error(stack ? msg + ' (Resolving: ' + stack + ')' : msg);\n  };\n\n  var get = function (name) {\n    if (!providers[name] && name.indexOf('.') !== -1) {\n      var parts = name.split('.');\n      var pivot = get(parts.shift());\n\n      while (parts.length) {\n        pivot = pivot[parts.shift()];\n      }\n\n      return pivot;\n    }\n\n    if (Object.hasOwnProperty.call(instances, name)) {\n      return instances[name];\n    }\n\n    if (Object.hasOwnProperty.call(providers, name)) {\n      if (currentlyResolving.indexOf(name) !== -1) {\n        currentlyResolving.push(name);\n        throw error('Can not resolve circular dependency!');\n      }\n\n      currentlyResolving.push(name);\n      instances[name] = providers[name][0](providers[name][1]);\n      currentlyResolving.pop();\n      return instances[name];\n    }\n\n    return parent.get(name);\n  };\n\n  var instantiate = function (Type) {\n    var instance = Object.create(Type.prototype);\n    var returned = invoke(Type, instance);\n    return typeof returned === 'object' ? returned : instance;\n  };\n\n  var invoke = function (fn, context) {\n    if (typeof fn !== 'function') {\n      throw error('Can not invoke \"' + fn + '\". Expected a function!');\n    }\n\n    var inject = fn.$inject && fn.$inject || autoAnnotate(fn);\n    var dependencies = inject.map(function (dep) {\n      return get(dep);\n    }); // TODO(vojta): optimize without apply\n\n    return fn.apply(context, dependencies);\n  };\n\n  var createChild = function (modules, providersFromParent) {\n    if (providersFromParent && providersFromParent.length) {\n      var fromParentModule = Object.create(null);\n      providersFromParent.forEach(function (name) {\n        if (!providers[name]) {\n          throw new Error('No provider for \"' + name + '\". Can not use provider from the parent!');\n        }\n\n        fromParentModule[name] = [providers[name][2], providers[name][1]];\n      });\n      modules.unshift(fromParentModule);\n    }\n\n    return new Injector(modules, this);\n  };\n\n  var factoryMap = {\n    factory: invoke,\n    type: instantiate,\n    value: function (value) {\n      return value;\n    }\n  };\n  modules.forEach(function (module) {\n    // TODO(vojta): handle wrong inputs (modules)\n    if (module instanceof Module) {\n      module.forEach(function (provider) {\n        var name = provider[0];\n        var type = provider[1];\n        var value = provider[2];\n        providers[name] = [factoryMap[type], value, type];\n      });\n    } else if (typeof module === 'object') {\n      Object.keys(module).forEach(function (name) {\n        var type = module[name][0];\n        var value = module[name][1];\n        providers[name] = [factoryMap[type], value, type];\n      });\n    }\n  }); // public API\n\n  this.get = get;\n  this.invoke = invoke;\n  this.instantiate = instantiate;\n  this.createChild = createChild;\n};\n\nmodule.exports = Injector;","map":{"version":3,"names":["Module","require","autoAnnotate","parse","Injector","modules","parent","get","name","currentlyResolving","push","error","providers","_providers","Object","create","instances","_instances","injector","msg","stack","join","length","Error","indexOf","parts","split","pivot","shift","hasOwnProperty","call","pop","instantiate","Type","instance","prototype","returned","invoke","fn","context","inject","$inject","dependencies","map","dep","apply","createChild","providersFromParent","fromParentModule","forEach","unshift","factoryMap","factory","type","value","module","provider","keys","exports"],"sources":["/Users/deliabarbuta/Documents/An4Sem1/PAW/Proiect/proiect-paw-tadam/Frontend_OceanCross/node_modules/di/lib/injector.js"],"sourcesContent":["var Module = require('./module');\nvar autoAnnotate = require('./annotation').parse;\n\n\nvar Injector = function(modules, parent) {\n  parent = parent || {\n    get: function(name) {\n      currentlyResolving.push(name);\n      throw error('No provider for \"' + name + '\"!');\n    }\n  };\n\n  var currentlyResolving = [];\n  var providers = this._providers = Object.create(parent._providers || null);\n  var instances = this._instances = Object.create(null);\n\n  instances.injector = this;\n\n  var error = function(msg) {\n    var stack = currentlyResolving.join(' -> ');\n    currentlyResolving.length = 0;\n    return new Error(stack ? msg + ' (Resolving: ' + stack + ')' : msg);\n  };\n\n  var get = function(name) {\n    if (!providers[name] && name.indexOf('.') !== -1) {\n      var parts = name.split('.');\n      var pivot = get(parts.shift());\n\n      while(parts.length) {\n        pivot = pivot[parts.shift()];\n      }\n\n      return pivot;\n    }\n\n    if (Object.hasOwnProperty.call(instances, name)) {\n      return instances[name];\n    }\n\n    if (Object.hasOwnProperty.call(providers, name)) {\n      if (currentlyResolving.indexOf(name) !== -1) {\n        currentlyResolving.push(name);\n        throw error('Can not resolve circular dependency!');\n      }\n\n      currentlyResolving.push(name);\n      instances[name] = providers[name][0](providers[name][1]);\n      currentlyResolving.pop();\n\n      return instances[name];\n    }\n\n    return parent.get(name);\n  };\n\n  var instantiate = function(Type) {\n    var instance = Object.create(Type.prototype);\n    var returned = invoke(Type, instance);\n\n    return typeof returned === 'object' ? returned : instance;\n  };\n\n  var invoke = function(fn, context) {\n    if (typeof fn !== 'function') {\n      throw error('Can not invoke \"' + fn + '\". Expected a function!');\n    }\n\n    var inject = fn.$inject && fn.$inject || autoAnnotate(fn);\n    var dependencies = inject.map(function(dep) {\n      return get(dep);\n    });\n\n    // TODO(vojta): optimize without apply\n    return fn.apply(context, dependencies);\n  };\n\n  var createChild = function(modules, providersFromParent) {\n    if (providersFromParent && providersFromParent.length) {\n      var fromParentModule = Object.create(null);\n\n      providersFromParent.forEach(function(name) {\n        if (!providers[name]) {\n          throw new Error('No provider for \"' + name + '\". Can not use provider from the parent!');\n        }\n\n        fromParentModule[name] = [providers[name][2], providers[name][1]];\n      });\n\n      modules.unshift(fromParentModule);\n    }\n\n    return new Injector(modules, this);\n  };\n\n  var factoryMap = {\n    factory: invoke,\n    type: instantiate,\n    value: function(value) {\n      return value;\n    }\n  };\n\n  modules.forEach(function(module) {\n    // TODO(vojta): handle wrong inputs (modules)\n    if (module instanceof Module) {\n      module.forEach(function(provider) {\n        var name = provider[0];\n        var type = provider[1];\n        var value = provider[2];\n\n        providers[name] = [factoryMap[type], value, type];\n      });\n    } else if (typeof module === 'object') {\n      Object.keys(module).forEach(function(name) {\n        var type = module[name][0];\n        var value = module[name][1];\n\n        providers[name] = [factoryMap[type], value, type];\n      });\n    }\n  });\n\n  // public API\n  this.get = get;\n  this.invoke = invoke;\n  this.instantiate = instantiate;\n  this.createChild = createChild;\n};\n\nmodule.exports = Injector;\n"],"mappings":"AAAA,IAAIA,MAAM,GAAGC,OAAO,CAAC,UAAD,CAApB;;AACA,IAAIC,YAAY,GAAGD,OAAO,CAAC,cAAD,CAAP,CAAwBE,KAA3C;;AAGA,IAAIC,QAAQ,GAAG,UAASC,OAAT,EAAkBC,MAAlB,EAA0B;EACvCA,MAAM,GAAGA,MAAM,IAAI;IACjBC,GAAG,EAAE,UAASC,IAAT,EAAe;MAClBC,kBAAkB,CAACC,IAAnB,CAAwBF,IAAxB;MACA,MAAMG,KAAK,CAAC,sBAAsBH,IAAtB,GAA6B,IAA9B,CAAX;IACD;EAJgB,CAAnB;EAOA,IAAIC,kBAAkB,GAAG,EAAzB;EACA,IAAIG,SAAS,GAAG,KAAKC,UAAL,GAAkBC,MAAM,CAACC,MAAP,CAAcT,MAAM,CAACO,UAAP,IAAqB,IAAnC,CAAlC;EACA,IAAIG,SAAS,GAAG,KAAKC,UAAL,GAAkBH,MAAM,CAACC,MAAP,CAAc,IAAd,CAAlC;EAEAC,SAAS,CAACE,QAAV,GAAqB,IAArB;;EAEA,IAAIP,KAAK,GAAG,UAASQ,GAAT,EAAc;IACxB,IAAIC,KAAK,GAAGX,kBAAkB,CAACY,IAAnB,CAAwB,MAAxB,CAAZ;IACAZ,kBAAkB,CAACa,MAAnB,GAA4B,CAA5B;IACA,OAAO,IAAIC,KAAJ,CAAUH,KAAK,GAAGD,GAAG,GAAG,eAAN,GAAwBC,KAAxB,GAAgC,GAAnC,GAAyCD,GAAxD,CAAP;EACD,CAJD;;EAMA,IAAIZ,GAAG,GAAG,UAASC,IAAT,EAAe;IACvB,IAAI,CAACI,SAAS,CAACJ,IAAD,CAAV,IAAoBA,IAAI,CAACgB,OAAL,CAAa,GAAb,MAAsB,CAAC,CAA/C,EAAkD;MAChD,IAAIC,KAAK,GAAGjB,IAAI,CAACkB,KAAL,CAAW,GAAX,CAAZ;MACA,IAAIC,KAAK,GAAGpB,GAAG,CAACkB,KAAK,CAACG,KAAN,EAAD,CAAf;;MAEA,OAAMH,KAAK,CAACH,MAAZ,EAAoB;QAClBK,KAAK,GAAGA,KAAK,CAACF,KAAK,CAACG,KAAN,EAAD,CAAb;MACD;;MAED,OAAOD,KAAP;IACD;;IAED,IAAIb,MAAM,CAACe,cAAP,CAAsBC,IAAtB,CAA2Bd,SAA3B,EAAsCR,IAAtC,CAAJ,EAAiD;MAC/C,OAAOQ,SAAS,CAACR,IAAD,CAAhB;IACD;;IAED,IAAIM,MAAM,CAACe,cAAP,CAAsBC,IAAtB,CAA2BlB,SAA3B,EAAsCJ,IAAtC,CAAJ,EAAiD;MAC/C,IAAIC,kBAAkB,CAACe,OAAnB,CAA2BhB,IAA3B,MAAqC,CAAC,CAA1C,EAA6C;QAC3CC,kBAAkB,CAACC,IAAnB,CAAwBF,IAAxB;QACA,MAAMG,KAAK,CAAC,sCAAD,CAAX;MACD;;MAEDF,kBAAkB,CAACC,IAAnB,CAAwBF,IAAxB;MACAQ,SAAS,CAACR,IAAD,CAAT,GAAkBI,SAAS,CAACJ,IAAD,CAAT,CAAgB,CAAhB,EAAmBI,SAAS,CAACJ,IAAD,CAAT,CAAgB,CAAhB,CAAnB,CAAlB;MACAC,kBAAkB,CAACsB,GAAnB;MAEA,OAAOf,SAAS,CAACR,IAAD,CAAhB;IACD;;IAED,OAAOF,MAAM,CAACC,GAAP,CAAWC,IAAX,CAAP;EACD,CA9BD;;EAgCA,IAAIwB,WAAW,GAAG,UAASC,IAAT,EAAe;IAC/B,IAAIC,QAAQ,GAAGpB,MAAM,CAACC,MAAP,CAAckB,IAAI,CAACE,SAAnB,CAAf;IACA,IAAIC,QAAQ,GAAGC,MAAM,CAACJ,IAAD,EAAOC,QAAP,CAArB;IAEA,OAAO,OAAOE,QAAP,KAAoB,QAApB,GAA+BA,QAA/B,GAA0CF,QAAjD;EACD,CALD;;EAOA,IAAIG,MAAM,GAAG,UAASC,EAAT,EAAaC,OAAb,EAAsB;IACjC,IAAI,OAAOD,EAAP,KAAc,UAAlB,EAA8B;MAC5B,MAAM3B,KAAK,CAAC,qBAAqB2B,EAArB,GAA0B,yBAA3B,CAAX;IACD;;IAED,IAAIE,MAAM,GAAGF,EAAE,CAACG,OAAH,IAAcH,EAAE,CAACG,OAAjB,IAA4BvC,YAAY,CAACoC,EAAD,CAArD;IACA,IAAII,YAAY,GAAGF,MAAM,CAACG,GAAP,CAAW,UAASC,GAAT,EAAc;MAC1C,OAAOrC,GAAG,CAACqC,GAAD,CAAV;IACD,CAFkB,CAAnB,CANiC,CAUjC;;IACA,OAAON,EAAE,CAACO,KAAH,CAASN,OAAT,EAAkBG,YAAlB,CAAP;EACD,CAZD;;EAcA,IAAII,WAAW,GAAG,UAASzC,OAAT,EAAkB0C,mBAAlB,EAAuC;IACvD,IAAIA,mBAAmB,IAAIA,mBAAmB,CAACzB,MAA/C,EAAuD;MACrD,IAAI0B,gBAAgB,GAAGlC,MAAM,CAACC,MAAP,CAAc,IAAd,CAAvB;MAEAgC,mBAAmB,CAACE,OAApB,CAA4B,UAASzC,IAAT,EAAe;QACzC,IAAI,CAACI,SAAS,CAACJ,IAAD,CAAd,EAAsB;UACpB,MAAM,IAAIe,KAAJ,CAAU,sBAAsBf,IAAtB,GAA6B,0CAAvC,CAAN;QACD;;QAEDwC,gBAAgB,CAACxC,IAAD,CAAhB,GAAyB,CAACI,SAAS,CAACJ,IAAD,CAAT,CAAgB,CAAhB,CAAD,EAAqBI,SAAS,CAACJ,IAAD,CAAT,CAAgB,CAAhB,CAArB,CAAzB;MACD,CAND;MAQAH,OAAO,CAAC6C,OAAR,CAAgBF,gBAAhB;IACD;;IAED,OAAO,IAAI5C,QAAJ,CAAaC,OAAb,EAAsB,IAAtB,CAAP;EACD,CAhBD;;EAkBA,IAAI8C,UAAU,GAAG;IACfC,OAAO,EAAEf,MADM;IAEfgB,IAAI,EAAErB,WAFS;IAGfsB,KAAK,EAAE,UAASA,KAAT,EAAgB;MACrB,OAAOA,KAAP;IACD;EALc,CAAjB;EAQAjD,OAAO,CAAC4C,OAAR,CAAgB,UAASM,MAAT,EAAiB;IAC/B;IACA,IAAIA,MAAM,YAAYvD,MAAtB,EAA8B;MAC5BuD,MAAM,CAACN,OAAP,CAAe,UAASO,QAAT,EAAmB;QAChC,IAAIhD,IAAI,GAAGgD,QAAQ,CAAC,CAAD,CAAnB;QACA,IAAIH,IAAI,GAAGG,QAAQ,CAAC,CAAD,CAAnB;QACA,IAAIF,KAAK,GAAGE,QAAQ,CAAC,CAAD,CAApB;QAEA5C,SAAS,CAACJ,IAAD,CAAT,GAAkB,CAAC2C,UAAU,CAACE,IAAD,CAAX,EAAmBC,KAAnB,EAA0BD,IAA1B,CAAlB;MACD,CAND;IAOD,CARD,MAQO,IAAI,OAAOE,MAAP,KAAkB,QAAtB,EAAgC;MACrCzC,MAAM,CAAC2C,IAAP,CAAYF,MAAZ,EAAoBN,OAApB,CAA4B,UAASzC,IAAT,EAAe;QACzC,IAAI6C,IAAI,GAAGE,MAAM,CAAC/C,IAAD,CAAN,CAAa,CAAb,CAAX;QACA,IAAI8C,KAAK,GAAGC,MAAM,CAAC/C,IAAD,CAAN,CAAa,CAAb,CAAZ;QAEAI,SAAS,CAACJ,IAAD,CAAT,GAAkB,CAAC2C,UAAU,CAACE,IAAD,CAAX,EAAmBC,KAAnB,EAA0BD,IAA1B,CAAlB;MACD,CALD;IAMD;EACF,CAlBD,EAnGuC,CAuHvC;;EACA,KAAK9C,GAAL,GAAWA,GAAX;EACA,KAAK8B,MAAL,GAAcA,MAAd;EACA,KAAKL,WAAL,GAAmBA,WAAnB;EACA,KAAKc,WAAL,GAAmBA,WAAnB;AACD,CA5HD;;AA8HAS,MAAM,CAACG,OAAP,GAAiBtD,QAAjB"},"metadata":{},"sourceType":"script"}