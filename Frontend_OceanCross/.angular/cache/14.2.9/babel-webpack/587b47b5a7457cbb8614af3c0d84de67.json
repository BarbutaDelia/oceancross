{"ast":null,"code":"var util = require('util');\n\nvar events = require('events').EventEmitter;\n\nvar qjob = function (options) {\n  if (false === this instanceof qjob) {\n    return new qjob(options);\n  }\n\n  this.maxConcurrency = 10;\n  this.jobsRunning = 0;\n  this.jobsDone = 0;\n  this.jobsTotal = 0;\n  this.timeStart;\n  this.jobId = 0;\n  this.jobsList = [];\n  this.paused = false;\n  this.pausedId = null;\n  this.lastPause = 0;\n  this.interval = null;\n  this.stopAdding = false;\n  this.sleeping = false;\n  this.aborting = false;\n\n  if (options) {\n    this.maxConcurrency = options.maxConcurrency || this.maxConcurrency;\n    this.interval = options.interval || this.interval;\n  }\n\n  events.call(this);\n};\n\nutil.inherits(qjob, events);\n/*\n * helper to set max concurrency\n */\n\nqjob.prototype.setConcurrency = function (max) {\n  this.maxConcurrency = max;\n};\n/*\n * helper to set delay between rafales\n */\n\n\nqjob.prototype.setInterval = function (delay) {\n  this.interval = delay;\n};\n/*\n * add some jobs in the queue\n */\n\n\nqjob.prototype.add = function (job, args) {\n  var self = this;\n  self.jobsList.push([job, args]);\n  self.jobsTotal++;\n};\n/*\n *\n */\n\n\nqjob.prototype.sleepDueToInterval = function () {\n  var self = this;\n\n  if (this.interval === null) {\n    return;\n  }\n\n  if (this.sleeping) {\n    return true;\n  }\n\n  if (this.stopAdding) {\n    if (this.jobsRunning > 0) {\n      //console.log('waiting for '+jobsRunning+' jobs to finish');\n      return true;\n    } //console.log('waiting for '+rafaleDelay+' ms');\n\n\n    this.sleeping = true;\n    self.emit('sleep');\n    setTimeout(function () {\n      this.stopAdding = false;\n      this.sleeping = false;\n      self.emit('continu');\n      self.run();\n    }.bind(self), this.interval);\n    return true;\n  }\n\n  if (this.jobsRunning + 1 == this.maxConcurrency) {\n    //console.log('max concurrent jobs reached');\n    this.stopAdding = true;\n    return true;\n  }\n};\n/*\n * run the queue\n */\n\n\nqjob.prototype.run = function () {\n  var self = this; // first launch, let's emit start event\n\n  if (this.jobsDone == 0) {\n    self.emit('start');\n    this.timeStart = Date.now();\n  }\n\n  if (self.sleepDueToInterval()) return;\n\n  if (self.aborting) {\n    this.jobsList = [];\n  } // while queue is empty and number of job running\n  // concurrently are less than max job running,\n  // then launch the next job\n\n\n  while (this.jobsList.length && this.jobsRunning < this.maxConcurrency) {\n    // get the next job and\n    // remove it from the queue\n    var job = self.jobsList.shift(); // increment number of job running\n\n    self.jobsRunning++; // fetch args for the job\n\n    var args = job[1]; // add jobId in args\n\n    args._jobId = this.jobId++; // emit jobStart event\n\n    self.emit('jobStart', args); // run the job\n\n    setTimeout(function () {\n      this.j(this.args, self.next.bind(self, this.args));\n    }.bind({\n      j: job[0],\n      args: args\n    }), 1);\n  } // all jobs done ? emit end event\n\n\n  if (this.jobsList.length == 0 && this.jobsRunning == 0) {\n    self.emit('end');\n  }\n};\n/*\n * a task has been terminated,\n * so 'next()' has been called\n */\n\n\nqjob.prototype.next = function (args) {\n  var self = this; // update counters\n\n  this.jobsRunning--;\n  this.jobsDone++; // emit 'jobEnd' event\n\n  self.emit('jobEnd', args); // if queue has been set to pause\n  // then do nothing\n\n  if (this.paused) return; // else, execute run() function\n\n  self.run();\n};\n/*\n * You can 'pause' jobs.\n * it will not pause running jobs, but\n * it will stop launching pending jobs\n * until paused = false\n */\n\n\nqjob.prototype.pause = function (status) {\n  var self = this;\n  this.paused = status;\n\n  if (!this.paused && this.pausedId) {\n    clearInterval(this.pausedId);\n    self.emit('unpause');\n    this.run();\n  }\n\n  if (this.paused && !this.pausedId) {\n    self.lastPause = Date.now();\n    this.pausedId = setInterval(function () {\n      var since = Date.now() - self.lastPause;\n      self.emit('pause', since);\n    }, 1000);\n    return;\n  }\n};\n\nqjob.prototype.stats = function () {\n  var now = Date.now();\n  var o = {};\n  o._timeStart = this.timeStart || 'N/A';\n  o._timeElapsed = now - this.timeStart || 'N/A';\n  o._jobsTotal = this.jobsTotal;\n  o._jobsRunning = this.jobsRunning;\n  o._jobsDone = this.jobsDone;\n  o._progress = Math.floor(this.jobsDone / this.jobsTotal * 100);\n  o._concurrency = this.maxConcurrency;\n\n  if (this.paused) {\n    o._status = 'Paused';\n    return o;\n  }\n\n  if (o._timeElapsed == 'N/A') {\n    o._status = 'Starting';\n    return o;\n  }\n\n  if (this.jobsTotal == this.jobsDone) {\n    o._status = 'Finished';\n    return o;\n  }\n\n  o._status = 'Running';\n  return o;\n};\n\nqjob.prototype.abort = function () {\n  this.aborting = true;\n};\n\nmodule.exports = qjob;","map":{"version":3,"names":["util","require","events","EventEmitter","qjob","options","maxConcurrency","jobsRunning","jobsDone","jobsTotal","timeStart","jobId","jobsList","paused","pausedId","lastPause","interval","stopAdding","sleeping","aborting","call","inherits","prototype","setConcurrency","max","setInterval","delay","add","job","args","self","push","sleepDueToInterval","emit","setTimeout","run","bind","Date","now","length","shift","_jobId","j","next","pause","status","clearInterval","since","stats","o","_timeStart","_timeElapsed","_jobsTotal","_jobsRunning","_jobsDone","_progress","Math","floor","_concurrency","_status","abort","module","exports"],"sources":["/Users/deliabarbuta/Documents/An4Sem1/PAW/Proiect/proiect-paw-tadam/Frontend_OceanCross/node_modules/qjobs/qjobs.js"],"sourcesContent":["var util = require('util');\nvarÂ events = require('events').EventEmitter;\n\nvar qjob = function(options) {\n\n    if(false === (this instanceof qjob)) {\n        return new qjob(options);\n    }\n\n    this.maxConcurrency  = 10;\n    this.jobsRunning = 0;\n    this.jobsDone = 0;\n    this.jobsTotal = 0;\n    this.timeStart;\n    this.jobId = 0;\n    this.jobsList = [];\n    this.paused = false;\n    this.pausedId = null;\n    this.lastPause = 0;\n\n    this.interval = null;\n    this.stopAdding = false;\n    this.sleeping = false;\n\n    this.aborting = false;\n\n    if (options) {\n        this.maxConcurrency = options.maxConcurrency || this.maxConcurrency;\n        this.interval = options.interval || this.interval;\n    }\n    events.call(this);\n};\n\nutil.inherits(qjob, events);\n\n/*\n * helper to set max concurrency\n */\nqjob.prototype.setConcurrency = function(max) {\n    this.maxConcurrency = max;\n}\n\n/*\n * helper to set delay between rafales\n */\nqjob.prototype.setInterval = function(delay) {\n    this.interval = delay;\n}\n\n/*\n * add some jobs in the queue\n */\nqjob.prototype.add = function(job,args) {\n    var self = this;\n    self.jobsList.push([job,args]);\n    self.jobsTotal++;\n}\n\n/*\n *\n */\nqjob.prototype.sleepDueToInterval = function() {\n    var self = this;\n\n    if (this.interval === null) {\n        return;\n    }\n\n    if (this.sleeping) {\n        return true;\n    }\n\n    if (this.stopAdding) {\n\n        if (this.jobsRunning > 0) {\n            //console.log('waiting for '+jobsRunning+' jobs to finish');\n            return true;\n        }\n\n        //console.log('waiting for '+rafaleDelay+' ms');\n        this.sleeping = true;\n        self.emit('sleep');\n\n        setTimeout(function() {\n            this.stopAdding = false;\n            this.sleeping = false;\n            self.emit('continu');\n            self.run();\n        }.bind(self),this.interval);\n\n        return true;\n    }\n\n    if (this.jobsRunning + 1 == this.maxConcurrency) {\n        //console.log('max concurrent jobs reached');\n        this.stopAdding = true;\n        return true;\n    }\n}\n\n/*\n * run the queue\n */\nqjob.prototype.run = function() {\n\n    var self = this;\n\n    // first launch, let's emit start event\n    if (this.jobsDone == 0) {\n        self.emit('start');\n        this.timeStart = Date.now();\n    }\n\n    if (self.sleepDueToInterval()) return;\n\n    if (self.aborting) {\n        this.jobsList = [];\n    }\n\n    // while queue is empty and number of job running\n    // concurrently are less than max job running,\n    // then launch the next job\n\n    while (this.jobsList.length && this.jobsRunning < this.maxConcurrency) {\n        // get the next job and\n        // remove it from the queue\n        var job = self.jobsList.shift();\n\n        // increment number of job running\n        self.jobsRunning++;\n\n        // fetch args for the job\n        var args = job[1];\n\n        // add jobId in args\n        args._jobId = this.jobId++;\n\n        // emit jobStart event\n        self.emit('jobStart',args);\n\n        // run the job\n        setTimeout(function() {\n            this.j(this.args,self.next.bind(self,this.args));\n        }.bind({j:job[0],args:args}),1);\n    }\n\n    // all jobs done ? emit end event\n    if (this.jobsList.length == 0 && this.jobsRunning == 0) {\n        self.emit('end');\n    }\n}\n\n/*\n * a task has been terminated,\n * so 'next()' has been called\n */\nqjob.prototype.next = function(args) {\n\n    var self = this;\n\n    // update counters\n    this.jobsRunning--;\n    this.jobsDone++;\n\n    // emit 'jobEnd' event\n    self.emit('jobEnd',args);\n\n    // if queue has been set to pause\n    // then do nothing\n    if (this.paused) return;\n\n    // else, execute run() function\n    self.run();\n}\n\n/*\n * You can 'pause' jobs.\n * it will not pause running jobs, but\n * it will stop launching pending jobs\n * until paused = false\n */\nqjob.prototype.pause = function(status) {\n    var self = this;\n    this.paused = status;\n    if (!this.paused && this.pausedId) {\n        clearInterval(this.pausedId);\n        self.emit('unpause');\n        this.run();\n    }\n    if (this.paused && !this.pausedId) {\n        self.lastPause = Date.now();\n        this.pausedId = setInterval(function() {\n            var since = Date.now() - self.lastPause;\n            self.emit('pause',since);\n        },1000);\n        return;\n    }\n}\n\nqjob.prototype.stats = function() {\n\n    var now =  Date.now();\n\n    var o = {};\n    o._timeStart = this.timeStart || 'N/A';\n    o._timeElapsed = (now - this.timeStart) || 'N/A';\n    o._jobsTotal = this.jobsTotal;\n    o._jobsRunning = this.jobsRunning;\n    o._jobsDone = this.jobsDone;\n    o._progress = Math.floor((this.jobsDone/this.jobsTotal)*100);\n    o._concurrency = this.maxConcurrency;\n\n    if (this.paused) {\n        o._status = 'Paused';\n        return o;\n    }\n\n    if (o._timeElapsed == 'N/A') {\n        o._status = 'Starting';\n        return o;\n    }\n\n    if (this.jobsTotal == this.jobsDone) {\n        o._status = 'Finished';\n        return o;\n    }\n\n    o._status = 'Running';\n    return o;\n}\n\nqjob.prototype.abort = function() {\n    this.aborting = true;\n}\n\nmodule.exports = qjob;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}