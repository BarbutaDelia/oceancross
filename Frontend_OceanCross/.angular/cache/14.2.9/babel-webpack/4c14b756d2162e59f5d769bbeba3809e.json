{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getKeywords = void 0;\n\nconst core_1 = require(\"@babel/core\");\n\nconst helper_annotate_as_pure_1 = __importDefault(require(\"@babel/helper-annotate-as-pure\"));\n/**\n * The name of the Typescript decorator helper function created by the TypeScript compiler.\n */\n\n\nconst TSLIB_DECORATE_HELPER_NAME = '__decorate';\n/**\n * The set of Angular static fields that should always be wrapped.\n * These fields may appear to have side effects but are safe to remove if the associated class\n * is otherwise unused within the output.\n */\n\nconst angularStaticsToWrap = new Set(['ɵcmp', 'ɵdir', 'ɵfac', 'ɵinj', 'ɵmod', 'ɵpipe', 'ɵprov', 'INJECTOR_KEY']);\n/**\n * An object map of static fields and related value checks for discovery of Angular generated\n * JIT related static fields.\n */\n\nconst angularStaticsToElide = {\n  'ctorParameters'(path) {\n    return path.isFunctionExpression() || path.isArrowFunctionExpression();\n  },\n\n  'decorators'(path) {\n    return path.isArrayExpression();\n  },\n\n  'propDecorators'(path) {\n    return path.isObjectExpression();\n  }\n\n};\n/**\n * Provides one or more keywords that if found within the content of a source file indicate\n * that this plugin should be used with a source file.\n *\n * @returns An a string iterable containing one or more keywords.\n */\n\nfunction getKeywords() {\n  return ['class'];\n}\n\nexports.getKeywords = getKeywords;\n/**\n * Determines whether a property and its initializer value can be safely wrapped in a pure\n * annotated IIFE. Values that may cause side effects are not considered safe to wrap.\n * Wrapping such values may cause runtime errors and/or incorrect runtime behavior.\n *\n * @param propertyName The name of the property to analyze.\n * @param assignmentValue The initializer value that will be assigned to the property.\n * @returns If the property can be safely wrapped, then true; otherwise, false.\n */\n\nfunction canWrapProperty(propertyName, assignmentValue) {\n  if (angularStaticsToWrap.has(propertyName)) {\n    return true;\n  }\n\n  const {\n    leadingComments\n  } = assignmentValue.node;\n\n  if (leadingComments === null || leadingComments === void 0 ? void 0 : leadingComments.some( // `@pureOrBreakMyCode` is used by closure and is present in Angular code\n  ({\n    value\n  }) => value.includes('@__PURE__') || value.includes('#__PURE__') || value.includes('@pureOrBreakMyCode'))) {\n    return true;\n  }\n\n  return assignmentValue.isPure();\n}\n/**\n * Analyze the sibling nodes of a class to determine if any downlevel elements should be\n * wrapped in a pure annotated IIFE. Also determines if any elements have potential side\n * effects.\n *\n * @param origin The starting NodePath location for analyzing siblings.\n * @param classIdentifier The identifier node that represents the name of the class.\n * @param allowWrappingDecorators Whether to allow decorators to be wrapped.\n * @returns An object containing the results of the analysis.\n */\n\n\nfunction analyzeClassSiblings(origin, classIdentifier, allowWrappingDecorators) {\n  var _a;\n\n  const wrapStatementPaths = [];\n  let hasPotentialSideEffects = false;\n\n  for (let i = 1;; ++i) {\n    const nextStatement = origin.getSibling(+origin.key + i);\n\n    if (!nextStatement.isExpressionStatement()) {\n      break;\n    } // Valid sibling statements for class declarations are only assignment expressions\n    // and TypeScript decorator helper call expressions\n\n\n    const nextExpression = nextStatement.get('expression');\n\n    if (nextExpression.isCallExpression()) {\n      if (!core_1.types.isIdentifier(nextExpression.node.callee) || nextExpression.node.callee.name !== TSLIB_DECORATE_HELPER_NAME) {\n        break;\n      }\n\n      if (allowWrappingDecorators) {\n        wrapStatementPaths.push(nextStatement);\n      } else {\n        // Statement cannot be safely wrapped which makes wrapping the class unneeded.\n        // The statement will prevent even a wrapped class from being optimized away.\n        hasPotentialSideEffects = true;\n      }\n\n      continue;\n    } else if (!nextExpression.isAssignmentExpression()) {\n      break;\n    } // Valid assignment expressions should be member access expressions using the class\n    // name as the object and an identifier as the property for static fields or only\n    // the class name for decorators.\n\n\n    const left = nextExpression.get('left');\n\n    if (left.isIdentifier()) {\n      if (!left.scope.bindingIdentifierEquals(left.node.name, classIdentifier) || !core_1.types.isCallExpression(nextExpression.node.right) || !core_1.types.isIdentifier(nextExpression.node.right.callee) || nextExpression.node.right.callee.name !== TSLIB_DECORATE_HELPER_NAME) {\n        break;\n      }\n\n      if (allowWrappingDecorators) {\n        wrapStatementPaths.push(nextStatement);\n      } else {\n        // Statement cannot be safely wrapped which makes wrapping the class unneeded.\n        // The statement will prevent even a wrapped class from being optimized away.\n        hasPotentialSideEffects = true;\n      }\n\n      continue;\n    } else if (!left.isMemberExpression() || !core_1.types.isIdentifier(left.node.object) || !left.scope.bindingIdentifierEquals(left.node.object.name, classIdentifier) || !core_1.types.isIdentifier(left.node.property)) {\n      break;\n    }\n\n    const propertyName = left.node.property.name;\n    const assignmentValue = nextExpression.get('right');\n\n    if ((_a = angularStaticsToElide[propertyName]) === null || _a === void 0 ? void 0 : _a.call(angularStaticsToElide, assignmentValue)) {\n      nextStatement.remove();\n      --i;\n    } else if (canWrapProperty(propertyName, assignmentValue)) {\n      wrapStatementPaths.push(nextStatement);\n    } else {\n      // Statement cannot be safely wrapped which makes wrapping the class unneeded.\n      // The statement will prevent even a wrapped class from being optimized away.\n      hasPotentialSideEffects = true;\n    }\n  }\n\n  return {\n    hasPotentialSideEffects,\n    wrapStatementPaths\n  };\n}\n/**\n * The set of classed already visited and analyzed during the plugin's execution.\n * This is used to prevent adjusted classes from being repeatedly analyzed which can lead\n * to an infinite loop.\n */\n\n\nconst visitedClasses = new WeakSet();\n/**\n * A babel plugin factory function for adjusting classes; primarily with Angular metadata.\n * The adjustments include wrapping classes with known safe or no side effects with pure\n * annotations to support dead code removal of unused classes. Angular compiler generated\n * metadata static fields not required in AOT mode are also elided to better support bundler-\n * level treeshaking.\n *\n * @returns A babel plugin object instance.\n */\n\nfunction default_1() {\n  return {\n    visitor: {\n      ClassDeclaration(path, state) {\n        const {\n          node: classNode,\n          parentPath\n        } = path;\n        const {\n          wrapDecorators\n        } = state.opts;\n\n        if (visitedClasses.has(classNode)) {\n          return;\n        } // Analyze sibling statements for elements of the class that were downleveled\n\n\n        const hasExport = parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration();\n        const origin = hasExport ? parentPath : path;\n        const {\n          wrapStatementPaths,\n          hasPotentialSideEffects\n        } = analyzeClassSiblings(origin, classNode.id, wrapDecorators);\n        visitedClasses.add(classNode);\n\n        if (hasPotentialSideEffects || wrapStatementPaths.length === 0) {\n          return;\n        }\n\n        const wrapStatementNodes = [];\n\n        for (const statementPath of wrapStatementPaths) {\n          wrapStatementNodes.push(statementPath.node);\n          statementPath.remove();\n        } // Wrap class and safe static assignments in a pure annotated IIFE\n\n\n        const container = core_1.types.arrowFunctionExpression([], core_1.types.blockStatement([classNode, ...wrapStatementNodes, core_1.types.returnStatement(core_1.types.cloneNode(classNode.id))]));\n        const replacementInitializer = core_1.types.callExpression(core_1.types.parenthesizedExpression(container), []);\n        (0, helper_annotate_as_pure_1.default)(replacementInitializer); // Replace class with IIFE wrapped class\n\n        const declaration = core_1.types.variableDeclaration('let', [core_1.types.variableDeclarator(core_1.types.cloneNode(classNode.id), replacementInitializer)]);\n\n        if (parentPath.isExportDefaultDeclaration()) {\n          // When converted to a variable declaration, the default export must be moved\n          // to a subsequent statement to prevent a JavaScript syntax error.\n          parentPath.replaceWithMultiple([declaration, core_1.types.exportNamedDeclaration(undefined, [core_1.types.exportSpecifier(core_1.types.cloneNode(classNode.id), core_1.types.identifier('default'))])]);\n        } else {\n          path.replaceWith(declaration);\n        }\n      },\n\n      ClassExpression(path, state) {\n        const {\n          node: classNode,\n          parentPath\n        } = path;\n        const {\n          wrapDecorators\n        } = state.opts; // Class expressions are used by TypeScript to represent downlevel class/constructor decorators.\n        // If not wrapping decorators, they do not need to be processed.\n\n        if (!wrapDecorators || visitedClasses.has(classNode)) {\n          return;\n        }\n\n        if (!classNode.id || !parentPath.isVariableDeclarator() || !core_1.types.isIdentifier(parentPath.node.id) || parentPath.node.id.name !== classNode.id.name) {\n          return;\n        }\n\n        const origin = parentPath.parentPath;\n\n        if (!origin.isVariableDeclaration() || origin.node.declarations.length !== 1) {\n          return;\n        }\n\n        const {\n          wrapStatementPaths,\n          hasPotentialSideEffects\n        } = analyzeClassSiblings(origin, parentPath.node.id, wrapDecorators);\n        visitedClasses.add(classNode);\n\n        if (hasPotentialSideEffects || wrapStatementPaths.length === 0) {\n          return;\n        }\n\n        const wrapStatementNodes = [];\n\n        for (const statementPath of wrapStatementPaths) {\n          wrapStatementNodes.push(statementPath.node);\n          statementPath.remove();\n        } // Wrap class and safe static assignments in a pure annotated IIFE\n\n\n        const container = core_1.types.arrowFunctionExpression([], core_1.types.blockStatement([core_1.types.variableDeclaration('let', [core_1.types.variableDeclarator(core_1.types.cloneNode(classNode.id), classNode)]), ...wrapStatementNodes, core_1.types.returnStatement(core_1.types.cloneNode(classNode.id))]));\n        const replacementInitializer = core_1.types.callExpression(core_1.types.parenthesizedExpression(container), []);\n        (0, helper_annotate_as_pure_1.default)(replacementInitializer); // Add the wrapped class directly to the variable declaration\n\n        parentPath.get('init').replaceWith(replacementInitializer);\n      }\n\n    }\n  };\n}\n\nexports.default = default_1;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","getKeywords","core_1","require","helper_annotate_as_pure_1","TSLIB_DECORATE_HELPER_NAME","angularStaticsToWrap","Set","angularStaticsToElide","path","isFunctionExpression","isArrowFunctionExpression","isArrayExpression","isObjectExpression","canWrapProperty","propertyName","assignmentValue","has","leadingComments","node","some","includes","isPure","analyzeClassSiblings","origin","classIdentifier","allowWrappingDecorators","_a","wrapStatementPaths","hasPotentialSideEffects","i","nextStatement","getSibling","key","isExpressionStatement","nextExpression","get","isCallExpression","types","isIdentifier","callee","name","push","isAssignmentExpression","left","scope","bindingIdentifierEquals","right","isMemberExpression","object","property","call","remove","visitedClasses","WeakSet","default_1","visitor","ClassDeclaration","state","classNode","parentPath","wrapDecorators","opts","hasExport","isExportNamedDeclaration","isExportDefaultDeclaration","id","add","length","wrapStatementNodes","statementPath","container","arrowFunctionExpression","blockStatement","returnStatement","cloneNode","replacementInitializer","callExpression","parenthesizedExpression","default","declaration","variableDeclaration","variableDeclarator","replaceWithMultiple","exportNamedDeclaration","undefined","exportSpecifier","identifier","replaceWith","ClassExpression","isVariableDeclarator","isVariableDeclaration","declarations"],"sources":["/Users/deliabarbuta/Documents/An4Sem1/PAW/Proiect/proiect-paw-tadam/Frontend_OceanCross/node_modules/@angular-devkit/build-angular/src/babel/plugins/adjust-static-class-members.js"],"sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getKeywords = void 0;\nconst core_1 = require(\"@babel/core\");\nconst helper_annotate_as_pure_1 = __importDefault(require(\"@babel/helper-annotate-as-pure\"));\n/**\n * The name of the Typescript decorator helper function created by the TypeScript compiler.\n */\nconst TSLIB_DECORATE_HELPER_NAME = '__decorate';\n/**\n * The set of Angular static fields that should always be wrapped.\n * These fields may appear to have side effects but are safe to remove if the associated class\n * is otherwise unused within the output.\n */\nconst angularStaticsToWrap = new Set([\n    'ɵcmp',\n    'ɵdir',\n    'ɵfac',\n    'ɵinj',\n    'ɵmod',\n    'ɵpipe',\n    'ɵprov',\n    'INJECTOR_KEY',\n]);\n/**\n * An object map of static fields and related value checks for discovery of Angular generated\n * JIT related static fields.\n */\nconst angularStaticsToElide = {\n    'ctorParameters'(path) {\n        return path.isFunctionExpression() || path.isArrowFunctionExpression();\n    },\n    'decorators'(path) {\n        return path.isArrayExpression();\n    },\n    'propDecorators'(path) {\n        return path.isObjectExpression();\n    },\n};\n/**\n * Provides one or more keywords that if found within the content of a source file indicate\n * that this plugin should be used with a source file.\n *\n * @returns An a string iterable containing one or more keywords.\n */\nfunction getKeywords() {\n    return ['class'];\n}\nexports.getKeywords = getKeywords;\n/**\n * Determines whether a property and its initializer value can be safely wrapped in a pure\n * annotated IIFE. Values that may cause side effects are not considered safe to wrap.\n * Wrapping such values may cause runtime errors and/or incorrect runtime behavior.\n *\n * @param propertyName The name of the property to analyze.\n * @param assignmentValue The initializer value that will be assigned to the property.\n * @returns If the property can be safely wrapped, then true; otherwise, false.\n */\nfunction canWrapProperty(propertyName, assignmentValue) {\n    if (angularStaticsToWrap.has(propertyName)) {\n        return true;\n    }\n    const { leadingComments } = assignmentValue.node;\n    if (leadingComments === null || leadingComments === void 0 ? void 0 : leadingComments.some(\n    // `@pureOrBreakMyCode` is used by closure and is present in Angular code\n    ({ value }) => value.includes('@__PURE__') ||\n        value.includes('#__PURE__') ||\n        value.includes('@pureOrBreakMyCode'))) {\n        return true;\n    }\n    return assignmentValue.isPure();\n}\n/**\n * Analyze the sibling nodes of a class to determine if any downlevel elements should be\n * wrapped in a pure annotated IIFE. Also determines if any elements have potential side\n * effects.\n *\n * @param origin The starting NodePath location for analyzing siblings.\n * @param classIdentifier The identifier node that represents the name of the class.\n * @param allowWrappingDecorators Whether to allow decorators to be wrapped.\n * @returns An object containing the results of the analysis.\n */\nfunction analyzeClassSiblings(origin, classIdentifier, allowWrappingDecorators) {\n    var _a;\n    const wrapStatementPaths = [];\n    let hasPotentialSideEffects = false;\n    for (let i = 1;; ++i) {\n        const nextStatement = origin.getSibling(+origin.key + i);\n        if (!nextStatement.isExpressionStatement()) {\n            break;\n        }\n        // Valid sibling statements for class declarations are only assignment expressions\n        // and TypeScript decorator helper call expressions\n        const nextExpression = nextStatement.get('expression');\n        if (nextExpression.isCallExpression()) {\n            if (!core_1.types.isIdentifier(nextExpression.node.callee) ||\n                nextExpression.node.callee.name !== TSLIB_DECORATE_HELPER_NAME) {\n                break;\n            }\n            if (allowWrappingDecorators) {\n                wrapStatementPaths.push(nextStatement);\n            }\n            else {\n                // Statement cannot be safely wrapped which makes wrapping the class unneeded.\n                // The statement will prevent even a wrapped class from being optimized away.\n                hasPotentialSideEffects = true;\n            }\n            continue;\n        }\n        else if (!nextExpression.isAssignmentExpression()) {\n            break;\n        }\n        // Valid assignment expressions should be member access expressions using the class\n        // name as the object and an identifier as the property for static fields or only\n        // the class name for decorators.\n        const left = nextExpression.get('left');\n        if (left.isIdentifier()) {\n            if (!left.scope.bindingIdentifierEquals(left.node.name, classIdentifier) ||\n                !core_1.types.isCallExpression(nextExpression.node.right) ||\n                !core_1.types.isIdentifier(nextExpression.node.right.callee) ||\n                nextExpression.node.right.callee.name !== TSLIB_DECORATE_HELPER_NAME) {\n                break;\n            }\n            if (allowWrappingDecorators) {\n                wrapStatementPaths.push(nextStatement);\n            }\n            else {\n                // Statement cannot be safely wrapped which makes wrapping the class unneeded.\n                // The statement will prevent even a wrapped class from being optimized away.\n                hasPotentialSideEffects = true;\n            }\n            continue;\n        }\n        else if (!left.isMemberExpression() ||\n            !core_1.types.isIdentifier(left.node.object) ||\n            !left.scope.bindingIdentifierEquals(left.node.object.name, classIdentifier) ||\n            !core_1.types.isIdentifier(left.node.property)) {\n            break;\n        }\n        const propertyName = left.node.property.name;\n        const assignmentValue = nextExpression.get('right');\n        if ((_a = angularStaticsToElide[propertyName]) === null || _a === void 0 ? void 0 : _a.call(angularStaticsToElide, assignmentValue)) {\n            nextStatement.remove();\n            --i;\n        }\n        else if (canWrapProperty(propertyName, assignmentValue)) {\n            wrapStatementPaths.push(nextStatement);\n        }\n        else {\n            // Statement cannot be safely wrapped which makes wrapping the class unneeded.\n            // The statement will prevent even a wrapped class from being optimized away.\n            hasPotentialSideEffects = true;\n        }\n    }\n    return { hasPotentialSideEffects, wrapStatementPaths };\n}\n/**\n * The set of classed already visited and analyzed during the plugin's execution.\n * This is used to prevent adjusted classes from being repeatedly analyzed which can lead\n * to an infinite loop.\n */\nconst visitedClasses = new WeakSet();\n/**\n * A babel plugin factory function for adjusting classes; primarily with Angular metadata.\n * The adjustments include wrapping classes with known safe or no side effects with pure\n * annotations to support dead code removal of unused classes. Angular compiler generated\n * metadata static fields not required in AOT mode are also elided to better support bundler-\n * level treeshaking.\n *\n * @returns A babel plugin object instance.\n */\nfunction default_1() {\n    return {\n        visitor: {\n            ClassDeclaration(path, state) {\n                const { node: classNode, parentPath } = path;\n                const { wrapDecorators } = state.opts;\n                if (visitedClasses.has(classNode)) {\n                    return;\n                }\n                // Analyze sibling statements for elements of the class that were downleveled\n                const hasExport = parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration();\n                const origin = hasExport ? parentPath : path;\n                const { wrapStatementPaths, hasPotentialSideEffects } = analyzeClassSiblings(origin, classNode.id, wrapDecorators);\n                visitedClasses.add(classNode);\n                if (hasPotentialSideEffects || wrapStatementPaths.length === 0) {\n                    return;\n                }\n                const wrapStatementNodes = [];\n                for (const statementPath of wrapStatementPaths) {\n                    wrapStatementNodes.push(statementPath.node);\n                    statementPath.remove();\n                }\n                // Wrap class and safe static assignments in a pure annotated IIFE\n                const container = core_1.types.arrowFunctionExpression([], core_1.types.blockStatement([\n                    classNode,\n                    ...wrapStatementNodes,\n                    core_1.types.returnStatement(core_1.types.cloneNode(classNode.id)),\n                ]));\n                const replacementInitializer = core_1.types.callExpression(core_1.types.parenthesizedExpression(container), []);\n                (0, helper_annotate_as_pure_1.default)(replacementInitializer);\n                // Replace class with IIFE wrapped class\n                const declaration = core_1.types.variableDeclaration('let', [\n                    core_1.types.variableDeclarator(core_1.types.cloneNode(classNode.id), replacementInitializer),\n                ]);\n                if (parentPath.isExportDefaultDeclaration()) {\n                    // When converted to a variable declaration, the default export must be moved\n                    // to a subsequent statement to prevent a JavaScript syntax error.\n                    parentPath.replaceWithMultiple([\n                        declaration,\n                        core_1.types.exportNamedDeclaration(undefined, [\n                            core_1.types.exportSpecifier(core_1.types.cloneNode(classNode.id), core_1.types.identifier('default')),\n                        ]),\n                    ]);\n                }\n                else {\n                    path.replaceWith(declaration);\n                }\n            },\n            ClassExpression(path, state) {\n                const { node: classNode, parentPath } = path;\n                const { wrapDecorators } = state.opts;\n                // Class expressions are used by TypeScript to represent downlevel class/constructor decorators.\n                // If not wrapping decorators, they do not need to be processed.\n                if (!wrapDecorators || visitedClasses.has(classNode)) {\n                    return;\n                }\n                if (!classNode.id ||\n                    !parentPath.isVariableDeclarator() ||\n                    !core_1.types.isIdentifier(parentPath.node.id) ||\n                    parentPath.node.id.name !== classNode.id.name) {\n                    return;\n                }\n                const origin = parentPath.parentPath;\n                if (!origin.isVariableDeclaration() || origin.node.declarations.length !== 1) {\n                    return;\n                }\n                const { wrapStatementPaths, hasPotentialSideEffects } = analyzeClassSiblings(origin, parentPath.node.id, wrapDecorators);\n                visitedClasses.add(classNode);\n                if (hasPotentialSideEffects || wrapStatementPaths.length === 0) {\n                    return;\n                }\n                const wrapStatementNodes = [];\n                for (const statementPath of wrapStatementPaths) {\n                    wrapStatementNodes.push(statementPath.node);\n                    statementPath.remove();\n                }\n                // Wrap class and safe static assignments in a pure annotated IIFE\n                const container = core_1.types.arrowFunctionExpression([], core_1.types.blockStatement([\n                    core_1.types.variableDeclaration('let', [\n                        core_1.types.variableDeclarator(core_1.types.cloneNode(classNode.id), classNode),\n                    ]),\n                    ...wrapStatementNodes,\n                    core_1.types.returnStatement(core_1.types.cloneNode(classNode.id)),\n                ]));\n                const replacementInitializer = core_1.types.callExpression(core_1.types.parenthesizedExpression(container), []);\n                (0, helper_annotate_as_pure_1.default)(replacementInitializer);\n                // Add the wrapped class directly to the variable declaration\n                parentPath.get('init').replaceWith(replacementInitializer);\n            },\n        },\n    };\n}\nexports.default = default_1;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}