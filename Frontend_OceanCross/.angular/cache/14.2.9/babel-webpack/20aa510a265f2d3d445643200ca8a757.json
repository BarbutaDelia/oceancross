{"ast":null,"code":"(module => {\n  \"use strict\";\n\n  var __defProp = Object.defineProperty;\n  var __defProps = Object.defineProperties;\n  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;\n  var __getOwnPropDescs = Object.getOwnPropertyDescriptors;\n  var __getOwnPropNames = Object.getOwnPropertyNames;\n  var __getOwnPropSymbols = Object.getOwnPropertySymbols;\n  var __hasOwnProp = Object.prototype.hasOwnProperty;\n  var __propIsEnum = Object.prototype.propertyIsEnumerable;\n\n  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value\n  }) : obj[key] = value;\n\n  var __spreadValues = (a, b) => {\n    for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n\n    if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n    }\n    return a;\n  };\n\n  var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\n\n  var __export = (target, all) => {\n    for (var name in all) __defProp(target, name, {\n      get: all[name],\n      enumerable: true\n    });\n  };\n\n  var __copyProps = (to, from, except, desc) => {\n    if (from && typeof from === \"object\" || typeof from === \"function\") {\n      for (let key of __getOwnPropNames(from)) if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n        get: () => from[key],\n        enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n      });\n    }\n\n    return to;\n  };\n\n  var __toCommonJS = mod => __copyProps(__defProp({}, \"__esModule\", {\n    value: true\n  }), mod);\n\n  var __async = (__this, __arguments, generator) => {\n    return new Promise((resolve, reject) => {\n      var fulfilled = value => {\n        try {\n          step(generator.next(value));\n        } catch (e) {\n          reject(e);\n        }\n      };\n\n      var rejected = value => {\n        try {\n          step(generator.throw(value));\n        } catch (e) {\n          reject(e);\n        }\n      };\n\n      var step = x => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n\n      step((generator = generator.apply(__this, __arguments)).next());\n    });\n  }; // lib/npm/browser.ts\n\n\n  var browser_exports = {};\n\n  __export(browser_exports, {\n    analyzeMetafile: () => analyzeMetafile,\n    analyzeMetafileSync: () => analyzeMetafileSync,\n    build: () => build,\n    buildSync: () => buildSync,\n    default: () => browser_default,\n    formatMessages: () => formatMessages,\n    formatMessagesSync: () => formatMessagesSync,\n    initialize: () => initialize,\n    serve: () => serve,\n    transform: () => transform,\n    transformSync: () => transformSync,\n    version: () => version\n  });\n\n  module.exports = __toCommonJS(browser_exports); // lib/shared/stdio_protocol.ts\n\n  function encodePacket(packet) {\n    let visit = value => {\n      if (value === null) {\n        bb.write8(0);\n      } else if (typeof value === \"boolean\") {\n        bb.write8(1);\n        bb.write8(+value);\n      } else if (typeof value === \"number\") {\n        bb.write8(2);\n        bb.write32(value | 0);\n      } else if (typeof value === \"string\") {\n        bb.write8(3);\n        bb.write(encodeUTF8(value));\n      } else if (value instanceof Uint8Array) {\n        bb.write8(4);\n        bb.write(value);\n      } else if (value instanceof Array) {\n        bb.write8(5);\n        bb.write32(value.length);\n\n        for (let item of value) {\n          visit(item);\n        }\n      } else {\n        let keys = Object.keys(value);\n        bb.write8(6);\n        bb.write32(keys.length);\n\n        for (let key of keys) {\n          bb.write(encodeUTF8(key));\n          visit(value[key]);\n        }\n      }\n    };\n\n    let bb = new ByteBuffer();\n    bb.write32(0);\n    bb.write32(packet.id << 1 | +!packet.isRequest);\n    visit(packet.value);\n    writeUInt32LE(bb.buf, bb.len - 4, 0);\n    return bb.buf.subarray(0, bb.len);\n  }\n\n  function decodePacket(bytes) {\n    let visit = () => {\n      switch (bb.read8()) {\n        case 0:\n          return null;\n\n        case 1:\n          return !!bb.read8();\n\n        case 2:\n          return bb.read32();\n\n        case 3:\n          return decodeUTF8(bb.read());\n\n        case 4:\n          return bb.read();\n\n        case 5:\n          {\n            let count = bb.read32();\n            let value2 = [];\n\n            for (let i = 0; i < count; i++) {\n              value2.push(visit());\n            }\n\n            return value2;\n          }\n\n        case 6:\n          {\n            let count = bb.read32();\n            let value2 = {};\n\n            for (let i = 0; i < count; i++) {\n              value2[decodeUTF8(bb.read())] = visit();\n            }\n\n            return value2;\n          }\n\n        default:\n          throw new Error(\"Invalid packet\");\n      }\n    };\n\n    let bb = new ByteBuffer(bytes);\n    let id = bb.read32();\n    let isRequest = (id & 1) === 0;\n    id >>>= 1;\n    let value = visit();\n\n    if (bb.ptr !== bytes.length) {\n      throw new Error(\"Invalid packet\");\n    }\n\n    return {\n      id,\n      isRequest,\n      value\n    };\n  }\n\n  var ByteBuffer = class {\n    constructor(buf = new Uint8Array(1024)) {\n      this.buf = buf;\n      this.len = 0;\n      this.ptr = 0;\n    }\n\n    _write(delta) {\n      if (this.len + delta > this.buf.length) {\n        let clone = new Uint8Array((this.len + delta) * 2);\n        clone.set(this.buf);\n        this.buf = clone;\n      }\n\n      this.len += delta;\n      return this.len - delta;\n    }\n\n    write8(value) {\n      let offset = this._write(1);\n\n      this.buf[offset] = value;\n    }\n\n    write32(value) {\n      let offset = this._write(4);\n\n      writeUInt32LE(this.buf, value, offset);\n    }\n\n    write(bytes) {\n      let offset = this._write(4 + bytes.length);\n\n      writeUInt32LE(this.buf, bytes.length, offset);\n      this.buf.set(bytes, offset + 4);\n    }\n\n    _read(delta) {\n      if (this.ptr + delta > this.buf.length) {\n        throw new Error(\"Invalid packet\");\n      }\n\n      this.ptr += delta;\n      return this.ptr - delta;\n    }\n\n    read8() {\n      return this.buf[this._read(1)];\n    }\n\n    read32() {\n      return readUInt32LE(this.buf, this._read(4));\n    }\n\n    read() {\n      let length = this.read32();\n      let bytes = new Uint8Array(length);\n\n      let ptr = this._read(bytes.length);\n\n      bytes.set(this.buf.subarray(ptr, ptr + length));\n      return bytes;\n    }\n\n  };\n  var encodeUTF8;\n  var decodeUTF8;\n\n  if (typeof TextEncoder !== \"undefined\" && typeof TextDecoder !== \"undefined\") {\n    let encoder = new TextEncoder();\n    let decoder = new TextDecoder();\n\n    encodeUTF8 = text => encoder.encode(text);\n\n    decodeUTF8 = bytes => decoder.decode(bytes);\n  } else if (typeof Buffer !== \"undefined\") {\n    encodeUTF8 = text => {\n      let buffer = Buffer.from(text);\n\n      if (!(buffer instanceof Uint8Array)) {\n        buffer = new Uint8Array(buffer);\n      }\n\n      return buffer;\n    };\n\n    decodeUTF8 = bytes => {\n      let {\n        buffer,\n        byteOffset,\n        byteLength\n      } = bytes;\n      return Buffer.from(buffer, byteOffset, byteLength).toString();\n    };\n  } else {\n    throw new Error(\"No UTF-8 codec found\");\n  }\n\n  function readUInt32LE(buffer, offset) {\n    return buffer[offset++] | buffer[offset++] << 8 | buffer[offset++] << 16 | buffer[offset++] << 24;\n  }\n\n  function writeUInt32LE(buffer, value, offset) {\n    buffer[offset++] = value;\n    buffer[offset++] = value >> 8;\n    buffer[offset++] = value >> 16;\n    buffer[offset++] = value >> 24;\n  } // lib/shared/common.ts\n\n\n  function validateTarget(target) {\n    target += \"\";\n    if (target.indexOf(\",\") >= 0) throw new Error(`Invalid target: ${target}`);\n    return target;\n  }\n\n  var canBeAnything = () => null;\n\n  var mustBeBoolean = value => typeof value === \"boolean\" ? null : \"a boolean\";\n\n  var mustBeBooleanOrObject = value => typeof value === \"boolean\" || typeof value === \"object\" && !Array.isArray(value) ? null : \"a boolean or an object\";\n\n  var mustBeString = value => typeof value === \"string\" ? null : \"a string\";\n\n  var mustBeRegExp = value => value instanceof RegExp ? null : \"a RegExp object\";\n\n  var mustBeInteger = value => typeof value === \"number\" && value === (value | 0) ? null : \"an integer\";\n\n  var mustBeFunction = value => typeof value === \"function\" ? null : \"a function\";\n\n  var mustBeArray = value => Array.isArray(value) ? null : \"an array\";\n\n  var mustBeObject = value => typeof value === \"object\" && value !== null && !Array.isArray(value) ? null : \"an object\";\n\n  var mustBeWebAssemblyModule = value => value instanceof WebAssembly.Module ? null : \"a WebAssembly.Module\";\n\n  var mustBeArrayOrRecord = value => typeof value === \"object\" && value !== null ? null : \"an array or an object\";\n\n  var mustBeObjectOrNull = value => typeof value === \"object\" && !Array.isArray(value) ? null : \"an object or null\";\n\n  var mustBeStringOrBoolean = value => typeof value === \"string\" || typeof value === \"boolean\" ? null : \"a string or a boolean\";\n\n  var mustBeStringOrObject = value => typeof value === \"string\" || typeof value === \"object\" && value !== null && !Array.isArray(value) ? null : \"a string or an object\";\n\n  var mustBeStringOrArray = value => typeof value === \"string\" || Array.isArray(value) ? null : \"a string or an array\";\n\n  var mustBeStringOrUint8Array = value => typeof value === \"string\" || value instanceof Uint8Array ? null : \"a string or a Uint8Array\";\n\n  function getFlag(object, keys, key, mustBeFn) {\n    let value = object[key];\n    keys[key + \"\"] = true;\n    if (value === void 0) return void 0;\n    let mustBe = mustBeFn(value);\n    if (mustBe !== null) throw new Error(`\"${key}\" must be ${mustBe}`);\n    return value;\n  }\n\n  function checkForInvalidFlags(object, keys, where) {\n    for (let key in object) {\n      if (!(key in keys)) {\n        throw new Error(`Invalid option ${where}: \"${key}\"`);\n      }\n    }\n  }\n\n  function validateInitializeOptions(options) {\n    let keys = /* @__PURE__ */Object.create(null);\n    let wasmURL = getFlag(options, keys, \"wasmURL\", mustBeString);\n    let wasmModule = getFlag(options, keys, \"wasmModule\", mustBeWebAssemblyModule);\n    let worker = getFlag(options, keys, \"worker\", mustBeBoolean);\n    checkForInvalidFlags(options, keys, \"in initialize() call\");\n    return {\n      wasmURL,\n      wasmModule,\n      worker\n    };\n  }\n\n  function validateMangleCache(mangleCache) {\n    let validated;\n\n    if (mangleCache !== void 0) {\n      validated = /* @__PURE__ */Object.create(null);\n\n      for (let key of Object.keys(mangleCache)) {\n        let value = mangleCache[key];\n\n        if (typeof value === \"string\" || value === false) {\n          validated[key] = value;\n        } else {\n          throw new Error(`Expected ${JSON.stringify(key)} in mangle cache to map to either a string or false`);\n        }\n      }\n    }\n\n    return validated;\n  }\n\n  function pushLogFlags(flags, options, keys, isTTY, logLevelDefault) {\n    let color = getFlag(options, keys, \"color\", mustBeBoolean);\n    let logLevel = getFlag(options, keys, \"logLevel\", mustBeString);\n    let logLimit = getFlag(options, keys, \"logLimit\", mustBeInteger);\n    if (color !== void 0) flags.push(`--color=${color}`);else if (isTTY) flags.push(`--color=true`);\n    flags.push(`--log-level=${logLevel || logLevelDefault}`);\n    flags.push(`--log-limit=${logLimit || 0}`);\n  }\n\n  function pushCommonFlags(flags, options, keys) {\n    let legalComments = getFlag(options, keys, \"legalComments\", mustBeString);\n    let sourceRoot = getFlag(options, keys, \"sourceRoot\", mustBeString);\n    let sourcesContent = getFlag(options, keys, \"sourcesContent\", mustBeBoolean);\n    let target = getFlag(options, keys, \"target\", mustBeStringOrArray);\n    let format = getFlag(options, keys, \"format\", mustBeString);\n    let globalName = getFlag(options, keys, \"globalName\", mustBeString);\n    let mangleProps = getFlag(options, keys, \"mangleProps\", mustBeRegExp);\n    let reserveProps = getFlag(options, keys, \"reserveProps\", mustBeRegExp);\n    let mangleQuoted = getFlag(options, keys, \"mangleQuoted\", mustBeBoolean);\n    let minify = getFlag(options, keys, \"minify\", mustBeBoolean);\n    let minifySyntax = getFlag(options, keys, \"minifySyntax\", mustBeBoolean);\n    let minifyWhitespace = getFlag(options, keys, \"minifyWhitespace\", mustBeBoolean);\n    let minifyIdentifiers = getFlag(options, keys, \"minifyIdentifiers\", mustBeBoolean);\n    let drop = getFlag(options, keys, \"drop\", mustBeArray);\n    let charset = getFlag(options, keys, \"charset\", mustBeString);\n    let treeShaking = getFlag(options, keys, \"treeShaking\", mustBeBoolean);\n    let ignoreAnnotations = getFlag(options, keys, \"ignoreAnnotations\", mustBeBoolean);\n    let jsx = getFlag(options, keys, \"jsx\", mustBeString);\n    let jsxFactory = getFlag(options, keys, \"jsxFactory\", mustBeString);\n    let jsxFragment = getFlag(options, keys, \"jsxFragment\", mustBeString);\n    let jsxImportSource = getFlag(options, keys, \"jsxImportSource\", mustBeString);\n    let jsxDev = getFlag(options, keys, \"jsxDev\", mustBeBoolean);\n    let define = getFlag(options, keys, \"define\", mustBeObject);\n    let logOverride = getFlag(options, keys, \"logOverride\", mustBeObject);\n    let supported = getFlag(options, keys, \"supported\", mustBeObject);\n    let pure = getFlag(options, keys, \"pure\", mustBeArray);\n    let keepNames = getFlag(options, keys, \"keepNames\", mustBeBoolean);\n    let platform = getFlag(options, keys, \"platform\", mustBeString);\n    if (legalComments) flags.push(`--legal-comments=${legalComments}`);\n    if (sourceRoot !== void 0) flags.push(`--source-root=${sourceRoot}`);\n    if (sourcesContent !== void 0) flags.push(`--sources-content=${sourcesContent}`);\n\n    if (target) {\n      if (Array.isArray(target)) flags.push(`--target=${Array.from(target).map(validateTarget).join(\",\")}`);else flags.push(`--target=${validateTarget(target)}`);\n    }\n\n    if (format) flags.push(`--format=${format}`);\n    if (globalName) flags.push(`--global-name=${globalName}`);\n    if (platform) flags.push(`--platform=${platform}`);\n    if (minify) flags.push(\"--minify\");\n    if (minifySyntax) flags.push(\"--minify-syntax\");\n    if (minifyWhitespace) flags.push(\"--minify-whitespace\");\n    if (minifyIdentifiers) flags.push(\"--minify-identifiers\");\n    if (charset) flags.push(`--charset=${charset}`);\n    if (treeShaking !== void 0) flags.push(`--tree-shaking=${treeShaking}`);\n    if (ignoreAnnotations) flags.push(`--ignore-annotations`);\n    if (drop) for (let what of drop) flags.push(`--drop:${what}`);\n    if (mangleProps) flags.push(`--mangle-props=${mangleProps.source}`);\n    if (reserveProps) flags.push(`--reserve-props=${reserveProps.source}`);\n    if (mangleQuoted !== void 0) flags.push(`--mangle-quoted=${mangleQuoted}`);\n    if (jsx) flags.push(`--jsx=${jsx}`);\n    if (jsxFactory) flags.push(`--jsx-factory=${jsxFactory}`);\n    if (jsxFragment) flags.push(`--jsx-fragment=${jsxFragment}`);\n    if (jsxImportSource) flags.push(`--jsx-import-source=${jsxImportSource}`);\n    if (jsxDev) flags.push(`--jsx-dev`);\n\n    if (define) {\n      for (let key in define) {\n        if (key.indexOf(\"=\") >= 0) throw new Error(`Invalid define: ${key}`);\n        flags.push(`--define:${key}=${define[key]}`);\n      }\n    }\n\n    if (logOverride) {\n      for (let key in logOverride) {\n        if (key.indexOf(\"=\") >= 0) throw new Error(`Invalid log override: ${key}`);\n        flags.push(`--log-override:${key}=${logOverride[key]}`);\n      }\n    }\n\n    if (supported) {\n      for (let key in supported) {\n        if (key.indexOf(\"=\") >= 0) throw new Error(`Invalid supported: ${key}`);\n        flags.push(`--supported:${key}=${supported[key]}`);\n      }\n    }\n\n    if (pure) for (let fn of pure) flags.push(`--pure:${fn}`);\n    if (keepNames) flags.push(`--keep-names`);\n  }\n\n  function flagsForBuildOptions(callName, options, isTTY, logLevelDefault, writeDefault) {\n    var _a;\n\n    let flags = [];\n    let entries = [];\n    let keys = /* @__PURE__ */Object.create(null);\n    let stdinContents = null;\n    let stdinResolveDir = null;\n    let watchMode = null;\n    pushLogFlags(flags, options, keys, isTTY, logLevelDefault);\n    pushCommonFlags(flags, options, keys);\n    let sourcemap = getFlag(options, keys, \"sourcemap\", mustBeStringOrBoolean);\n    let bundle = getFlag(options, keys, \"bundle\", mustBeBoolean);\n    let watch = getFlag(options, keys, \"watch\", mustBeBooleanOrObject);\n    let splitting = getFlag(options, keys, \"splitting\", mustBeBoolean);\n    let preserveSymlinks = getFlag(options, keys, \"preserveSymlinks\", mustBeBoolean);\n    let metafile = getFlag(options, keys, \"metafile\", mustBeBoolean);\n    let outfile = getFlag(options, keys, \"outfile\", mustBeString);\n    let outdir = getFlag(options, keys, \"outdir\", mustBeString);\n    let outbase = getFlag(options, keys, \"outbase\", mustBeString);\n    let tsconfig = getFlag(options, keys, \"tsconfig\", mustBeString);\n    let resolveExtensions = getFlag(options, keys, \"resolveExtensions\", mustBeArray);\n    let nodePathsInput = getFlag(options, keys, \"nodePaths\", mustBeArray);\n    let mainFields = getFlag(options, keys, \"mainFields\", mustBeArray);\n    let conditions = getFlag(options, keys, \"conditions\", mustBeArray);\n    let external = getFlag(options, keys, \"external\", mustBeArray);\n    let loader = getFlag(options, keys, \"loader\", mustBeObject);\n    let outExtension = getFlag(options, keys, \"outExtension\", mustBeObject);\n    let publicPath = getFlag(options, keys, \"publicPath\", mustBeString);\n    let entryNames = getFlag(options, keys, \"entryNames\", mustBeString);\n    let chunkNames = getFlag(options, keys, \"chunkNames\", mustBeString);\n    let assetNames = getFlag(options, keys, \"assetNames\", mustBeString);\n    let inject = getFlag(options, keys, \"inject\", mustBeArray);\n    let banner = getFlag(options, keys, \"banner\", mustBeObject);\n    let footer = getFlag(options, keys, \"footer\", mustBeObject);\n    let entryPoints = getFlag(options, keys, \"entryPoints\", mustBeArrayOrRecord);\n    let absWorkingDir = getFlag(options, keys, \"absWorkingDir\", mustBeString);\n    let stdin = getFlag(options, keys, \"stdin\", mustBeObject);\n    let write = (_a = getFlag(options, keys, \"write\", mustBeBoolean)) != null ? _a : writeDefault;\n    let allowOverwrite = getFlag(options, keys, \"allowOverwrite\", mustBeBoolean);\n    let incremental = getFlag(options, keys, \"incremental\", mustBeBoolean) === true;\n    let mangleCache = getFlag(options, keys, \"mangleCache\", mustBeObject);\n    keys.plugins = true;\n    checkForInvalidFlags(options, keys, `in ${callName}() call`);\n    if (sourcemap) flags.push(`--sourcemap${sourcemap === true ? \"\" : `=${sourcemap}`}`);\n    if (bundle) flags.push(\"--bundle\");\n    if (allowOverwrite) flags.push(\"--allow-overwrite\");\n\n    if (watch) {\n      flags.push(\"--watch\");\n\n      if (typeof watch === \"boolean\") {\n        watchMode = {};\n      } else {\n        let watchKeys = /* @__PURE__ */Object.create(null);\n        let onRebuild = getFlag(watch, watchKeys, \"onRebuild\", mustBeFunction);\n        checkForInvalidFlags(watch, watchKeys, `on \"watch\" in ${callName}() call`);\n        watchMode = {\n          onRebuild\n        };\n      }\n    }\n\n    if (splitting) flags.push(\"--splitting\");\n    if (preserveSymlinks) flags.push(\"--preserve-symlinks\");\n    if (metafile) flags.push(`--metafile`);\n    if (outfile) flags.push(`--outfile=${outfile}`);\n    if (outdir) flags.push(`--outdir=${outdir}`);\n    if (outbase) flags.push(`--outbase=${outbase}`);\n    if (tsconfig) flags.push(`--tsconfig=${tsconfig}`);\n\n    if (resolveExtensions) {\n      let values = [];\n\n      for (let value of resolveExtensions) {\n        value += \"\";\n        if (value.indexOf(\",\") >= 0) throw new Error(`Invalid resolve extension: ${value}`);\n        values.push(value);\n      }\n\n      flags.push(`--resolve-extensions=${values.join(\",\")}`);\n    }\n\n    if (publicPath) flags.push(`--public-path=${publicPath}`);\n    if (entryNames) flags.push(`--entry-names=${entryNames}`);\n    if (chunkNames) flags.push(`--chunk-names=${chunkNames}`);\n    if (assetNames) flags.push(`--asset-names=${assetNames}`);\n\n    if (mainFields) {\n      let values = [];\n\n      for (let value of mainFields) {\n        value += \"\";\n        if (value.indexOf(\",\") >= 0) throw new Error(`Invalid main field: ${value}`);\n        values.push(value);\n      }\n\n      flags.push(`--main-fields=${values.join(\",\")}`);\n    }\n\n    if (conditions) {\n      let values = [];\n\n      for (let value of conditions) {\n        value += \"\";\n        if (value.indexOf(\",\") >= 0) throw new Error(`Invalid condition: ${value}`);\n        values.push(value);\n      }\n\n      flags.push(`--conditions=${values.join(\",\")}`);\n    }\n\n    if (external) for (let name of external) flags.push(`--external:${name}`);\n\n    if (banner) {\n      for (let type in banner) {\n        if (type.indexOf(\"=\") >= 0) throw new Error(`Invalid banner file type: ${type}`);\n        flags.push(`--banner:${type}=${banner[type]}`);\n      }\n    }\n\n    if (footer) {\n      for (let type in footer) {\n        if (type.indexOf(\"=\") >= 0) throw new Error(`Invalid footer file type: ${type}`);\n        flags.push(`--footer:${type}=${footer[type]}`);\n      }\n    }\n\n    if (inject) for (let path of inject) flags.push(`--inject:${path}`);\n\n    if (loader) {\n      for (let ext in loader) {\n        if (ext.indexOf(\"=\") >= 0) throw new Error(`Invalid loader extension: ${ext}`);\n        flags.push(`--loader:${ext}=${loader[ext]}`);\n      }\n    }\n\n    if (outExtension) {\n      for (let ext in outExtension) {\n        if (ext.indexOf(\"=\") >= 0) throw new Error(`Invalid out extension: ${ext}`);\n        flags.push(`--out-extension:${ext}=${outExtension[ext]}`);\n      }\n    }\n\n    if (entryPoints) {\n      if (Array.isArray(entryPoints)) {\n        for (let entryPoint of entryPoints) {\n          entries.push([\"\", entryPoint + \"\"]);\n        }\n      } else {\n        for (let [key, value] of Object.entries(entryPoints)) {\n          entries.push([key + \"\", value + \"\"]);\n        }\n      }\n    }\n\n    if (stdin) {\n      let stdinKeys = /* @__PURE__ */Object.create(null);\n      let contents = getFlag(stdin, stdinKeys, \"contents\", mustBeStringOrUint8Array);\n      let resolveDir = getFlag(stdin, stdinKeys, \"resolveDir\", mustBeString);\n      let sourcefile = getFlag(stdin, stdinKeys, \"sourcefile\", mustBeString);\n      let loader2 = getFlag(stdin, stdinKeys, \"loader\", mustBeString);\n      checkForInvalidFlags(stdin, stdinKeys, 'in \"stdin\" object');\n      if (sourcefile) flags.push(`--sourcefile=${sourcefile}`);\n      if (loader2) flags.push(`--loader=${loader2}`);\n      if (resolveDir) stdinResolveDir = resolveDir + \"\";\n      if (typeof contents === \"string\") stdinContents = encodeUTF8(contents);else if (contents instanceof Uint8Array) stdinContents = contents;\n    }\n\n    let nodePaths = [];\n\n    if (nodePathsInput) {\n      for (let value of nodePathsInput) {\n        value += \"\";\n        nodePaths.push(value);\n      }\n    }\n\n    return {\n      entries,\n      flags,\n      write,\n      stdinContents,\n      stdinResolveDir,\n      absWorkingDir,\n      incremental,\n      nodePaths,\n      watch: watchMode,\n      mangleCache: validateMangleCache(mangleCache)\n    };\n  }\n\n  function flagsForTransformOptions(callName, options, isTTY, logLevelDefault) {\n    let flags = [];\n    let keys = /* @__PURE__ */Object.create(null);\n    pushLogFlags(flags, options, keys, isTTY, logLevelDefault);\n    pushCommonFlags(flags, options, keys);\n    let sourcemap = getFlag(options, keys, \"sourcemap\", mustBeStringOrBoolean);\n    let tsconfigRaw = getFlag(options, keys, \"tsconfigRaw\", mustBeStringOrObject);\n    let sourcefile = getFlag(options, keys, \"sourcefile\", mustBeString);\n    let loader = getFlag(options, keys, \"loader\", mustBeString);\n    let banner = getFlag(options, keys, \"banner\", mustBeString);\n    let footer = getFlag(options, keys, \"footer\", mustBeString);\n    let mangleCache = getFlag(options, keys, \"mangleCache\", mustBeObject);\n    checkForInvalidFlags(options, keys, `in ${callName}() call`);\n    if (sourcemap) flags.push(`--sourcemap=${sourcemap === true ? \"external\" : sourcemap}`);\n    if (tsconfigRaw) flags.push(`--tsconfig-raw=${typeof tsconfigRaw === \"string\" ? tsconfigRaw : JSON.stringify(tsconfigRaw)}`);\n    if (sourcefile) flags.push(`--sourcefile=${sourcefile}`);\n    if (loader) flags.push(`--loader=${loader}`);\n    if (banner) flags.push(`--banner=${banner}`);\n    if (footer) flags.push(`--footer=${footer}`);\n    return {\n      flags,\n      mangleCache: validateMangleCache(mangleCache)\n    };\n  }\n\n  function createChannel(streamIn) {\n    let responseCallbacks = /* @__PURE__ */new Map();\n    let pluginCallbacks = /* @__PURE__ */new Map();\n    let watchCallbacks = /* @__PURE__ */new Map();\n    let serveCallbacks = /* @__PURE__ */new Map();\n    let closeData = null;\n    let nextRequestID = 0;\n    let nextBuildKey = 0;\n    let stdout = new Uint8Array(16 * 1024);\n    let stdoutUsed = 0;\n\n    let readFromStdout = chunk => {\n      let limit = stdoutUsed + chunk.length;\n\n      if (limit > stdout.length) {\n        let swap = new Uint8Array(limit * 2);\n        swap.set(stdout);\n        stdout = swap;\n      }\n\n      stdout.set(chunk, stdoutUsed);\n      stdoutUsed += chunk.length;\n      let offset = 0;\n\n      while (offset + 4 <= stdoutUsed) {\n        let length = readUInt32LE(stdout, offset);\n\n        if (offset + 4 + length > stdoutUsed) {\n          break;\n        }\n\n        offset += 4;\n        handleIncomingPacket(stdout.subarray(offset, offset + length));\n        offset += length;\n      }\n\n      if (offset > 0) {\n        stdout.copyWithin(0, offset, stdoutUsed);\n        stdoutUsed -= offset;\n      }\n    };\n\n    let afterClose = error => {\n      closeData = {\n        reason: error ? \": \" + (error.message || error) : \"\"\n      };\n      const text = \"The service was stopped\" + closeData.reason;\n\n      for (let callback of responseCallbacks.values()) {\n        callback(text, null);\n      }\n\n      responseCallbacks.clear();\n\n      for (let callbacks of serveCallbacks.values()) {\n        callbacks.onWait(text);\n      }\n\n      serveCallbacks.clear();\n\n      for (let callback of watchCallbacks.values()) {\n        try {\n          callback(new Error(text), null);\n        } catch (e) {\n          console.error(e);\n        }\n      }\n\n      watchCallbacks.clear();\n    };\n\n    let sendRequest = (refs, value, callback) => {\n      if (closeData) return callback(\"The service is no longer running\" + closeData.reason, null);\n      let id = nextRequestID++;\n      responseCallbacks.set(id, (error, response) => {\n        try {\n          callback(error, response);\n        } finally {\n          if (refs) refs.unref();\n        }\n      });\n      if (refs) refs.ref();\n      streamIn.writeToStdin(encodePacket({\n        id,\n        isRequest: true,\n        value\n      }));\n    };\n\n    let sendResponse = (id, value) => {\n      if (closeData) throw new Error(\"The service is no longer running\" + closeData.reason);\n      streamIn.writeToStdin(encodePacket({\n        id,\n        isRequest: false,\n        value\n      }));\n    };\n\n    let handleRequest = (id, request) => __async(this, null, function* () {\n      try {\n        switch (request.command) {\n          case \"ping\":\n            {\n              sendResponse(id, {});\n              break;\n            }\n\n          case \"on-start\":\n            {\n              let callback = pluginCallbacks.get(request.key);\n              if (!callback) sendResponse(id, {});else sendResponse(id, yield callback(request));\n              break;\n            }\n\n          case \"on-resolve\":\n            {\n              let callback = pluginCallbacks.get(request.key);\n              if (!callback) sendResponse(id, {});else sendResponse(id, yield callback(request));\n              break;\n            }\n\n          case \"on-load\":\n            {\n              let callback = pluginCallbacks.get(request.key);\n              if (!callback) sendResponse(id, {});else sendResponse(id, yield callback(request));\n              break;\n            }\n\n          case \"serve-request\":\n            {\n              let callbacks = serveCallbacks.get(request.key);\n              if (callbacks && callbacks.onRequest) callbacks.onRequest(request.args);\n              sendResponse(id, {});\n              break;\n            }\n\n          case \"serve-wait\":\n            {\n              let callbacks = serveCallbacks.get(request.key);\n              if (callbacks) callbacks.onWait(request.error);\n              sendResponse(id, {});\n              break;\n            }\n\n          case \"watch-rebuild\":\n            {\n              let callback = watchCallbacks.get(request.key);\n\n              try {\n                if (callback) callback(null, request.args);\n              } catch (err) {\n                console.error(err);\n              }\n\n              sendResponse(id, {});\n              break;\n            }\n\n          default:\n            throw new Error(`Invalid command: ` + request.command);\n        }\n      } catch (e) {\n        sendResponse(id, {\n          errors: [extractErrorMessageV8(e, streamIn, null, void 0, \"\")]\n        });\n      }\n    });\n\n    let isFirstPacket = true;\n\n    let handleIncomingPacket = bytes => {\n      if (isFirstPacket) {\n        isFirstPacket = false;\n        let binaryVersion = String.fromCharCode(...bytes);\n\n        if (binaryVersion !== \"0.15.5\") {\n          throw new Error(`Cannot start service: Host version \"${\"0.15.5\"}\" does not match binary version ${JSON.stringify(binaryVersion)}`);\n        }\n\n        return;\n      }\n\n      let packet = decodePacket(bytes);\n\n      if (packet.isRequest) {\n        handleRequest(packet.id, packet.value);\n      } else {\n        let callback = responseCallbacks.get(packet.id);\n        responseCallbacks.delete(packet.id);\n        if (packet.value.error) callback(packet.value.error, {});else callback(null, packet.value);\n      }\n    };\n\n    let handlePlugins = (initialOptions, plugins, buildKey, stash, refs) => __async(this, null, function* () {\n      let onStartCallbacks = [];\n      let onEndCallbacks = [];\n      let onResolveCallbacks = {};\n      let onLoadCallbacks = {};\n      let nextCallbackID = 0;\n      let i = 0;\n      let requestPlugins = [];\n      let isSetupDone = false;\n      plugins = [...plugins];\n\n      for (let item of plugins) {\n        let keys = {};\n        if (typeof item !== \"object\") throw new Error(`Plugin at index ${i} must be an object`);\n        const name = getFlag(item, keys, \"name\", mustBeString);\n        if (typeof name !== \"string\" || name === \"\") throw new Error(`Plugin at index ${i} is missing a name`);\n\n        try {\n          let setup = getFlag(item, keys, \"setup\", mustBeFunction);\n          if (typeof setup !== \"function\") throw new Error(`Plugin is missing a setup function`);\n          checkForInvalidFlags(item, keys, `on plugin ${JSON.stringify(name)}`);\n          let plugin = {\n            name,\n            onResolve: [],\n            onLoad: []\n          };\n          i++;\n\n          let resolve = (path, options = {}) => {\n            if (!isSetupDone) throw new Error('Cannot call \"resolve\" before plugin setup has completed');\n            if (typeof path !== \"string\") throw new Error(`The path to resolve must be a string`);\n            let keys2 = /* @__PURE__ */Object.create(null);\n            let pluginName = getFlag(options, keys2, \"pluginName\", mustBeString);\n            let importer = getFlag(options, keys2, \"importer\", mustBeString);\n            let namespace = getFlag(options, keys2, \"namespace\", mustBeString);\n            let resolveDir = getFlag(options, keys2, \"resolveDir\", mustBeString);\n            let kind = getFlag(options, keys2, \"kind\", mustBeString);\n            let pluginData = getFlag(options, keys2, \"pluginData\", canBeAnything);\n            checkForInvalidFlags(options, keys2, \"in resolve() call\");\n            return new Promise((resolve2, reject) => {\n              const request = {\n                command: \"resolve\",\n                path,\n                key: buildKey,\n                pluginName: name\n              };\n              if (pluginName != null) request.pluginName = pluginName;\n              if (importer != null) request.importer = importer;\n              if (namespace != null) request.namespace = namespace;\n              if (resolveDir != null) request.resolveDir = resolveDir;\n              if (kind != null) request.kind = kind;\n              if (pluginData != null) request.pluginData = stash.store(pluginData);\n              sendRequest(refs, request, (error, response) => {\n                if (error !== null) reject(new Error(error));else resolve2({\n                  errors: replaceDetailsInMessages(response.errors, stash),\n                  warnings: replaceDetailsInMessages(response.warnings, stash),\n                  path: response.path,\n                  external: response.external,\n                  sideEffects: response.sideEffects,\n                  namespace: response.namespace,\n                  suffix: response.suffix,\n                  pluginData: stash.load(response.pluginData)\n                });\n              });\n            });\n          };\n\n          let promise = setup({\n            initialOptions,\n            resolve,\n\n            onStart(callback2) {\n              let registeredText = `This error came from the \"onStart\" callback registered here:`;\n              let registeredNote = extractCallerV8(new Error(registeredText), streamIn, \"onStart\");\n              onStartCallbacks.push({\n                name,\n                callback: callback2,\n                note: registeredNote\n              });\n            },\n\n            onEnd(callback2) {\n              let registeredText = `This error came from the \"onEnd\" callback registered here:`;\n              let registeredNote = extractCallerV8(new Error(registeredText), streamIn, \"onEnd\");\n              onEndCallbacks.push({\n                name,\n                callback: callback2,\n                note: registeredNote\n              });\n            },\n\n            onResolve(options, callback2) {\n              let registeredText = `This error came from the \"onResolve\" callback registered here:`;\n              let registeredNote = extractCallerV8(new Error(registeredText), streamIn, \"onResolve\");\n              let keys2 = {};\n              let filter = getFlag(options, keys2, \"filter\", mustBeRegExp);\n              let namespace = getFlag(options, keys2, \"namespace\", mustBeString);\n              checkForInvalidFlags(options, keys2, `in onResolve() call for plugin ${JSON.stringify(name)}`);\n              if (filter == null) throw new Error(`onResolve() call is missing a filter`);\n              let id = nextCallbackID++;\n              onResolveCallbacks[id] = {\n                name,\n                callback: callback2,\n                note: registeredNote\n              };\n              plugin.onResolve.push({\n                id,\n                filter: filter.source,\n                namespace: namespace || \"\"\n              });\n            },\n\n            onLoad(options, callback2) {\n              let registeredText = `This error came from the \"onLoad\" callback registered here:`;\n              let registeredNote = extractCallerV8(new Error(registeredText), streamIn, \"onLoad\");\n              let keys2 = {};\n              let filter = getFlag(options, keys2, \"filter\", mustBeRegExp);\n              let namespace = getFlag(options, keys2, \"namespace\", mustBeString);\n              checkForInvalidFlags(options, keys2, `in onLoad() call for plugin ${JSON.stringify(name)}`);\n              if (filter == null) throw new Error(`onLoad() call is missing a filter`);\n              let id = nextCallbackID++;\n              onLoadCallbacks[id] = {\n                name,\n                callback: callback2,\n                note: registeredNote\n              };\n              plugin.onLoad.push({\n                id,\n                filter: filter.source,\n                namespace: namespace || \"\"\n              });\n            },\n\n            esbuild: streamIn.esbuild\n          });\n          if (promise) yield promise;\n          requestPlugins.push(plugin);\n        } catch (e) {\n          return {\n            ok: false,\n            error: e,\n            pluginName: name\n          };\n        }\n      }\n\n      const callback = request => __async(this, null, function* () {\n        switch (request.command) {\n          case \"on-start\":\n            {\n              let response = {\n                errors: [],\n                warnings: []\n              };\n              yield Promise.all(onStartCallbacks.map(_0 => __async(this, [_0], function* ({\n                name,\n                callback: callback2,\n                note\n              }) {\n                try {\n                  let result = yield callback2();\n\n                  if (result != null) {\n                    if (typeof result !== \"object\") throw new Error(`Expected onStart() callback in plugin ${JSON.stringify(name)} to return an object`);\n                    let keys = {};\n                    let errors = getFlag(result, keys, \"errors\", mustBeArray);\n                    let warnings = getFlag(result, keys, \"warnings\", mustBeArray);\n                    checkForInvalidFlags(result, keys, `from onStart() callback in plugin ${JSON.stringify(name)}`);\n                    if (errors != null) response.errors.push(...sanitizeMessages(errors, \"errors\", stash, name));\n                    if (warnings != null) response.warnings.push(...sanitizeMessages(warnings, \"warnings\", stash, name));\n                  }\n                } catch (e) {\n                  response.errors.push(extractErrorMessageV8(e, streamIn, stash, note && note(), name));\n                }\n              })));\n              return response;\n            }\n\n          case \"on-resolve\":\n            {\n              let response = {},\n                  name = \"\",\n                  callback2,\n                  note;\n\n              for (let id of request.ids) {\n                try {\n                  ({\n                    name,\n                    callback: callback2,\n                    note\n                  } = onResolveCallbacks[id]);\n                  let result = yield callback2({\n                    path: request.path,\n                    importer: request.importer,\n                    namespace: request.namespace,\n                    resolveDir: request.resolveDir,\n                    kind: request.kind,\n                    pluginData: stash.load(request.pluginData)\n                  });\n\n                  if (result != null) {\n                    if (typeof result !== \"object\") throw new Error(`Expected onResolve() callback in plugin ${JSON.stringify(name)} to return an object`);\n                    let keys = {};\n                    let pluginName = getFlag(result, keys, \"pluginName\", mustBeString);\n                    let path = getFlag(result, keys, \"path\", mustBeString);\n                    let namespace = getFlag(result, keys, \"namespace\", mustBeString);\n                    let suffix = getFlag(result, keys, \"suffix\", mustBeString);\n                    let external = getFlag(result, keys, \"external\", mustBeBoolean);\n                    let sideEffects = getFlag(result, keys, \"sideEffects\", mustBeBoolean);\n                    let pluginData = getFlag(result, keys, \"pluginData\", canBeAnything);\n                    let errors = getFlag(result, keys, \"errors\", mustBeArray);\n                    let warnings = getFlag(result, keys, \"warnings\", mustBeArray);\n                    let watchFiles = getFlag(result, keys, \"watchFiles\", mustBeArray);\n                    let watchDirs = getFlag(result, keys, \"watchDirs\", mustBeArray);\n                    checkForInvalidFlags(result, keys, `from onResolve() callback in plugin ${JSON.stringify(name)}`);\n                    response.id = id;\n                    if (pluginName != null) response.pluginName = pluginName;\n                    if (path != null) response.path = path;\n                    if (namespace != null) response.namespace = namespace;\n                    if (suffix != null) response.suffix = suffix;\n                    if (external != null) response.external = external;\n                    if (sideEffects != null) response.sideEffects = sideEffects;\n                    if (pluginData != null) response.pluginData = stash.store(pluginData);\n                    if (errors != null) response.errors = sanitizeMessages(errors, \"errors\", stash, name);\n                    if (warnings != null) response.warnings = sanitizeMessages(warnings, \"warnings\", stash, name);\n                    if (watchFiles != null) response.watchFiles = sanitizeStringArray(watchFiles, \"watchFiles\");\n                    if (watchDirs != null) response.watchDirs = sanitizeStringArray(watchDirs, \"watchDirs\");\n                    break;\n                  }\n                } catch (e) {\n                  return {\n                    id,\n                    errors: [extractErrorMessageV8(e, streamIn, stash, note && note(), name)]\n                  };\n                }\n              }\n\n              return response;\n            }\n\n          case \"on-load\":\n            {\n              let response = {},\n                  name = \"\",\n                  callback2,\n                  note;\n\n              for (let id of request.ids) {\n                try {\n                  ({\n                    name,\n                    callback: callback2,\n                    note\n                  } = onLoadCallbacks[id]);\n                  let result = yield callback2({\n                    path: request.path,\n                    namespace: request.namespace,\n                    suffix: request.suffix,\n                    pluginData: stash.load(request.pluginData)\n                  });\n\n                  if (result != null) {\n                    if (typeof result !== \"object\") throw new Error(`Expected onLoad() callback in plugin ${JSON.stringify(name)} to return an object`);\n                    let keys = {};\n                    let pluginName = getFlag(result, keys, \"pluginName\", mustBeString);\n                    let contents = getFlag(result, keys, \"contents\", mustBeStringOrUint8Array);\n                    let resolveDir = getFlag(result, keys, \"resolveDir\", mustBeString);\n                    let pluginData = getFlag(result, keys, \"pluginData\", canBeAnything);\n                    let loader = getFlag(result, keys, \"loader\", mustBeString);\n                    let errors = getFlag(result, keys, \"errors\", mustBeArray);\n                    let warnings = getFlag(result, keys, \"warnings\", mustBeArray);\n                    let watchFiles = getFlag(result, keys, \"watchFiles\", mustBeArray);\n                    let watchDirs = getFlag(result, keys, \"watchDirs\", mustBeArray);\n                    checkForInvalidFlags(result, keys, `from onLoad() callback in plugin ${JSON.stringify(name)}`);\n                    response.id = id;\n                    if (pluginName != null) response.pluginName = pluginName;\n                    if (contents instanceof Uint8Array) response.contents = contents;else if (contents != null) response.contents = encodeUTF8(contents);\n                    if (resolveDir != null) response.resolveDir = resolveDir;\n                    if (pluginData != null) response.pluginData = stash.store(pluginData);\n                    if (loader != null) response.loader = loader;\n                    if (errors != null) response.errors = sanitizeMessages(errors, \"errors\", stash, name);\n                    if (warnings != null) response.warnings = sanitizeMessages(warnings, \"warnings\", stash, name);\n                    if (watchFiles != null) response.watchFiles = sanitizeStringArray(watchFiles, \"watchFiles\");\n                    if (watchDirs != null) response.watchDirs = sanitizeStringArray(watchDirs, \"watchDirs\");\n                    break;\n                  }\n                } catch (e) {\n                  return {\n                    id,\n                    errors: [extractErrorMessageV8(e, streamIn, stash, note && note(), name)]\n                  };\n                }\n              }\n\n              return response;\n            }\n\n          default:\n            throw new Error(`Invalid command: ` + request.command);\n        }\n      });\n\n      let runOnEndCallbacks = (result, logPluginError, done) => done();\n\n      if (onEndCallbacks.length > 0) {\n        runOnEndCallbacks = (result, logPluginError, done) => {\n          (() => __async(this, null, function* () {\n            for (const {\n              name,\n              callback: callback2,\n              note\n            } of onEndCallbacks) {\n              try {\n                yield callback2(result);\n              } catch (e) {\n                result.errors.push(yield new Promise(resolve => logPluginError(e, name, note && note(), resolve)));\n              }\n            }\n          }))().then(done);\n        };\n      }\n\n      isSetupDone = true;\n      let refCount = 0;\n      return {\n        ok: true,\n        requestPlugins,\n        runOnEndCallbacks,\n        pluginRefs: {\n          ref() {\n            if (++refCount === 1) pluginCallbacks.set(buildKey, callback);\n          },\n\n          unref() {\n            if (--refCount === 0) pluginCallbacks.delete(buildKey);\n          }\n\n        }\n      };\n    });\n\n    let buildServeData = (refs, options, request, key) => {\n      let keys = {};\n      let port = getFlag(options, keys, \"port\", mustBeInteger);\n      let host = getFlag(options, keys, \"host\", mustBeString);\n      let servedir = getFlag(options, keys, \"servedir\", mustBeString);\n      let onRequest = getFlag(options, keys, \"onRequest\", mustBeFunction);\n      let onWait;\n      let wait = new Promise((resolve, reject) => {\n        onWait = error => {\n          serveCallbacks.delete(key);\n          if (error !== null) reject(new Error(error));else resolve();\n        };\n      });\n      request.serve = {};\n      checkForInvalidFlags(options, keys, `in serve() call`);\n      if (port !== void 0) request.serve.port = port;\n      if (host !== void 0) request.serve.host = host;\n      if (servedir !== void 0) request.serve.servedir = servedir;\n      serveCallbacks.set(key, {\n        onRequest,\n        onWait\n      });\n      return {\n        wait,\n\n        stop() {\n          sendRequest(refs, {\n            command: \"serve-stop\",\n            key\n          }, () => {});\n        }\n\n      };\n    };\n\n    const buildLogLevelDefault = \"warning\";\n    const transformLogLevelDefault = \"silent\";\n\n    let buildOrServe = args => {\n      let key = nextBuildKey++;\n      const details = createObjectStash();\n      let plugins;\n      let {\n        refs,\n        options,\n        isTTY,\n        callback\n      } = args;\n\n      if (typeof options === \"object\") {\n        let value = options.plugins;\n\n        if (value !== void 0) {\n          if (!Array.isArray(value)) throw new Error(`\"plugins\" must be an array`);\n          plugins = value;\n        }\n      }\n\n      let logPluginError = (e, pluginName, note, done) => {\n        let flags = [];\n\n        try {\n          pushLogFlags(flags, options, {}, isTTY, buildLogLevelDefault);\n        } catch (e2) {}\n\n        const message = extractErrorMessageV8(e, streamIn, details, note, pluginName);\n        sendRequest(refs, {\n          command: \"error\",\n          flags,\n          error: message\n        }, () => {\n          message.detail = details.load(message.detail);\n          done(message);\n        });\n      };\n\n      let handleError = (e, pluginName) => {\n        logPluginError(e, pluginName, void 0, error => {\n          callback(failureErrorWithLog(\"Build failed\", [error], []), null);\n        });\n      };\n\n      if (plugins && plugins.length > 0) {\n        if (streamIn.isSync) return handleError(new Error(\"Cannot use plugins in synchronous API calls\"), \"\");\n        handlePlugins(options, plugins, key, details, refs).then(result => {\n          if (!result.ok) {\n            handleError(result.error, result.pluginName);\n          } else {\n            try {\n              buildOrServeContinue(__spreadProps(__spreadValues({}, args), {\n                key,\n                details,\n                logPluginError,\n                requestPlugins: result.requestPlugins,\n                runOnEndCallbacks: result.runOnEndCallbacks,\n                pluginRefs: result.pluginRefs\n              }));\n            } catch (e) {\n              handleError(e, \"\");\n            }\n          }\n        }, e => handleError(e, \"\"));\n      } else {\n        try {\n          buildOrServeContinue(__spreadProps(__spreadValues({}, args), {\n            key,\n            details,\n            logPluginError,\n            requestPlugins: null,\n            runOnEndCallbacks: (result, logPluginError2, done) => done(),\n            pluginRefs: null\n          }));\n        } catch (e) {\n          handleError(e, \"\");\n        }\n      }\n    };\n\n    let buildOrServeContinue = ({\n      callName,\n      refs: callerRefs,\n      serveOptions,\n      options,\n      isTTY,\n      defaultWD,\n      callback,\n      key,\n      details,\n      logPluginError,\n      requestPlugins,\n      runOnEndCallbacks,\n      pluginRefs\n    }) => {\n      const refs = {\n        ref() {\n          if (pluginRefs) pluginRefs.ref();\n          if (callerRefs) callerRefs.ref();\n        },\n\n        unref() {\n          if (pluginRefs) pluginRefs.unref();\n          if (callerRefs) callerRefs.unref();\n        }\n\n      };\n      let writeDefault = !streamIn.isWriteUnavailable;\n      let {\n        entries,\n        flags,\n        write,\n        stdinContents,\n        stdinResolveDir,\n        absWorkingDir,\n        incremental,\n        nodePaths,\n        watch,\n        mangleCache\n      } = flagsForBuildOptions(callName, options, isTTY, buildLogLevelDefault, writeDefault);\n      let request = {\n        command: \"build\",\n        key,\n        entries,\n        flags,\n        write,\n        stdinContents,\n        stdinResolveDir,\n        absWorkingDir: absWorkingDir || defaultWD,\n        incremental,\n        nodePaths\n      };\n      if (requestPlugins) request.plugins = requestPlugins;\n      if (mangleCache) request.mangleCache = mangleCache;\n      let serve2 = serveOptions && buildServeData(refs, serveOptions, request, key);\n      let rebuild;\n      let stop;\n\n      let copyResponseToResult = (response, result) => {\n        if (response.outputFiles) result.outputFiles = response.outputFiles.map(convertOutputFiles);\n        if (response.metafile) result.metafile = JSON.parse(response.metafile);\n        if (response.mangleCache) result.mangleCache = response.mangleCache;\n        if (response.writeToStdout !== void 0) console.log(decodeUTF8(response.writeToStdout).replace(/\\n$/, \"\"));\n      };\n\n      let buildResponseToResult = (response, callback2) => {\n        let result = {\n          errors: replaceDetailsInMessages(response.errors, details),\n          warnings: replaceDetailsInMessages(response.warnings, details)\n        };\n        copyResponseToResult(response, result);\n        runOnEndCallbacks(result, logPluginError, () => {\n          if (result.errors.length > 0) {\n            return callback2(failureErrorWithLog(\"Build failed\", result.errors, result.warnings), null);\n          }\n\n          if (response.rebuild) {\n            if (!rebuild) {\n              let isDisposed = false;\n\n              rebuild = () => new Promise((resolve, reject) => {\n                if (isDisposed || closeData) throw new Error(\"Cannot rebuild\");\n                sendRequest(refs, {\n                  command: \"rebuild\",\n                  key\n                }, (error2, response2) => {\n                  if (error2) {\n                    const message = {\n                      id: \"\",\n                      pluginName: \"\",\n                      text: error2,\n                      location: null,\n                      notes: [],\n                      detail: void 0\n                    };\n                    return callback2(failureErrorWithLog(\"Build failed\", [message], []), null);\n                  }\n\n                  buildResponseToResult(response2, (error3, result3) => {\n                    if (error3) reject(error3);else resolve(result3);\n                  });\n                });\n              });\n\n              refs.ref();\n\n              rebuild.dispose = () => {\n                if (isDisposed) return;\n                isDisposed = true;\n                sendRequest(refs, {\n                  command: \"rebuild-dispose\",\n                  key\n                }, () => {});\n                refs.unref();\n              };\n            }\n\n            result.rebuild = rebuild;\n          }\n\n          if (response.watch) {\n            if (!stop) {\n              let isStopped = false;\n              refs.ref();\n\n              stop = () => {\n                if (isStopped) return;\n                isStopped = true;\n                watchCallbacks.delete(key);\n                sendRequest(refs, {\n                  command: \"watch-stop\",\n                  key\n                }, () => {});\n                refs.unref();\n              };\n\n              if (watch) {\n                watchCallbacks.set(key, (serviceStopError, watchResponse) => {\n                  if (serviceStopError) {\n                    if (watch.onRebuild) watch.onRebuild(serviceStopError, null);\n                    return;\n                  }\n\n                  let result2 = {\n                    errors: replaceDetailsInMessages(watchResponse.errors, details),\n                    warnings: replaceDetailsInMessages(watchResponse.warnings, details)\n                  };\n                  copyResponseToResult(watchResponse, result2);\n                  runOnEndCallbacks(result2, logPluginError, () => {\n                    if (result2.errors.length > 0) {\n                      if (watch.onRebuild) watch.onRebuild(failureErrorWithLog(\"Build failed\", result2.errors, result2.warnings), null);\n                      return;\n                    }\n\n                    if (watchResponse.rebuildID !== void 0) result2.rebuild = rebuild;\n                    result2.stop = stop;\n                    if (watch.onRebuild) watch.onRebuild(null, result2);\n                  });\n                });\n              }\n            }\n\n            result.stop = stop;\n          }\n\n          callback2(null, result);\n        });\n      };\n\n      if (write && streamIn.isWriteUnavailable) throw new Error(`The \"write\" option is unavailable in this environment`);\n      if (incremental && streamIn.isSync) throw new Error(`Cannot use \"incremental\" with a synchronous build`);\n      if (watch && streamIn.isSync) throw new Error(`Cannot use \"watch\" with a synchronous build`);\n      sendRequest(refs, request, (error, response) => {\n        if (error) return callback(new Error(error), null);\n\n        if (serve2) {\n          let serveResponse = response;\n          let isStopped = false;\n          refs.ref();\n          let result = {\n            port: serveResponse.port,\n            host: serveResponse.host,\n            wait: serve2.wait,\n\n            stop() {\n              if (isStopped) return;\n              isStopped = true;\n              serve2.stop();\n              refs.unref();\n            }\n\n          };\n          refs.ref();\n          serve2.wait.then(refs.unref, refs.unref);\n          return callback(null, result);\n        }\n\n        return buildResponseToResult(response, callback);\n      });\n    };\n\n    let transform2 = ({\n      callName,\n      refs,\n      input,\n      options,\n      isTTY,\n      fs,\n      callback\n    }) => {\n      const details = createObjectStash();\n\n      let start = inputPath => {\n        try {\n          if (typeof input !== \"string\" && !(input instanceof Uint8Array)) throw new Error('The input to \"transform\" must be a string or a Uint8Array');\n          let {\n            flags,\n            mangleCache\n          } = flagsForTransformOptions(callName, options, isTTY, transformLogLevelDefault);\n          let request = {\n            command: \"transform\",\n            flags,\n            inputFS: inputPath !== null,\n            input: inputPath !== null ? encodeUTF8(inputPath) : typeof input === \"string\" ? encodeUTF8(input) : input\n          };\n          if (mangleCache) request.mangleCache = mangleCache;\n          sendRequest(refs, request, (error, response) => {\n            if (error) return callback(new Error(error), null);\n            let errors = replaceDetailsInMessages(response.errors, details);\n            let warnings = replaceDetailsInMessages(response.warnings, details);\n            let outstanding = 1;\n\n            let next = () => {\n              if (--outstanding === 0) {\n                let result = {\n                  warnings,\n                  code: response.code,\n                  map: response.map\n                };\n                if (response.mangleCache) result.mangleCache = response == null ? void 0 : response.mangleCache;\n                callback(null, result);\n              }\n            };\n\n            if (errors.length > 0) return callback(failureErrorWithLog(\"Transform failed\", errors, warnings), null);\n\n            if (response.codeFS) {\n              outstanding++;\n              fs.readFile(response.code, (err, contents) => {\n                if (err !== null) {\n                  callback(err, null);\n                } else {\n                  response.code = contents;\n                  next();\n                }\n              });\n            }\n\n            if (response.mapFS) {\n              outstanding++;\n              fs.readFile(response.map, (err, contents) => {\n                if (err !== null) {\n                  callback(err, null);\n                } else {\n                  response.map = contents;\n                  next();\n                }\n              });\n            }\n\n            next();\n          });\n        } catch (e) {\n          let flags = [];\n\n          try {\n            pushLogFlags(flags, options, {}, isTTY, transformLogLevelDefault);\n          } catch (e2) {}\n\n          const error = extractErrorMessageV8(e, streamIn, details, void 0, \"\");\n          sendRequest(refs, {\n            command: \"error\",\n            flags,\n            error\n          }, () => {\n            error.detail = details.load(error.detail);\n            callback(failureErrorWithLog(\"Transform failed\", [error], []), null);\n          });\n        }\n      };\n\n      if ((typeof input === \"string\" || input instanceof Uint8Array) && input.length > 1024 * 1024) {\n        let next = start;\n\n        start = () => fs.writeFile(input, next);\n      }\n\n      start(null);\n    };\n\n    let formatMessages2 = ({\n      callName,\n      refs,\n      messages,\n      options,\n      callback\n    }) => {\n      let result = sanitizeMessages(messages, \"messages\", null, \"\");\n      if (!options) throw new Error(`Missing second argument in ${callName}() call`);\n      let keys = {};\n      let kind = getFlag(options, keys, \"kind\", mustBeString);\n      let color = getFlag(options, keys, \"color\", mustBeBoolean);\n      let terminalWidth = getFlag(options, keys, \"terminalWidth\", mustBeInteger);\n      checkForInvalidFlags(options, keys, `in ${callName}() call`);\n      if (kind === void 0) throw new Error(`Missing \"kind\" in ${callName}() call`);\n      if (kind !== \"error\" && kind !== \"warning\") throw new Error(`Expected \"kind\" to be \"error\" or \"warning\" in ${callName}() call`);\n      let request = {\n        command: \"format-msgs\",\n        messages: result,\n        isWarning: kind === \"warning\"\n      };\n      if (color !== void 0) request.color = color;\n      if (terminalWidth !== void 0) request.terminalWidth = terminalWidth;\n      sendRequest(refs, request, (error, response) => {\n        if (error) return callback(new Error(error), null);\n        callback(null, response.messages);\n      });\n    };\n\n    let analyzeMetafile2 = ({\n      callName,\n      refs,\n      metafile,\n      options,\n      callback\n    }) => {\n      if (options === void 0) options = {};\n      let keys = {};\n      let color = getFlag(options, keys, \"color\", mustBeBoolean);\n      let verbose = getFlag(options, keys, \"verbose\", mustBeBoolean);\n      checkForInvalidFlags(options, keys, `in ${callName}() call`);\n      let request = {\n        command: \"analyze-metafile\",\n        metafile\n      };\n      if (color !== void 0) request.color = color;\n      if (verbose !== void 0) request.verbose = verbose;\n      sendRequest(refs, request, (error, response) => {\n        if (error) return callback(new Error(error), null);\n        callback(null, response.result);\n      });\n    };\n\n    return {\n      readFromStdout,\n      afterClose,\n      service: {\n        buildOrServe,\n        transform: transform2,\n        formatMessages: formatMessages2,\n        analyzeMetafile: analyzeMetafile2\n      }\n    };\n  }\n\n  function createObjectStash() {\n    const map = /* @__PURE__ */new Map();\n    let nextID = 0;\n    return {\n      load(id) {\n        return map.get(id);\n      },\n\n      store(value) {\n        if (value === void 0) return -1;\n        const id = nextID++;\n        map.set(id, value);\n        return id;\n      }\n\n    };\n  }\n\n  function extractCallerV8(e, streamIn, ident) {\n    let note;\n    let tried = false;\n    return () => {\n      if (tried) return note;\n      tried = true;\n\n      try {\n        let lines = (e.stack + \"\").split(\"\\n\");\n        lines.splice(1, 1);\n        let location = parseStackLinesV8(streamIn, lines, ident);\n\n        if (location) {\n          note = {\n            text: e.message,\n            location\n          };\n          return note;\n        }\n      } catch (e2) {}\n    };\n  }\n\n  function extractErrorMessageV8(e, streamIn, stash, note, pluginName) {\n    let text = \"Internal error\";\n    let location = null;\n\n    try {\n      text = (e && e.message || e) + \"\";\n    } catch (e2) {}\n\n    try {\n      location = parseStackLinesV8(streamIn, (e.stack + \"\").split(\"\\n\"), \"\");\n    } catch (e2) {}\n\n    return {\n      id: \"\",\n      pluginName,\n      text,\n      location,\n      notes: note ? [note] : [],\n      detail: stash ? stash.store(e) : -1\n    };\n  }\n\n  function parseStackLinesV8(streamIn, lines, ident) {\n    let at = \"    at \";\n\n    if (streamIn.readFileSync && !lines[0].startsWith(at) && lines[1].startsWith(at)) {\n      for (let i = 1; i < lines.length; i++) {\n        let line = lines[i];\n        if (!line.startsWith(at)) continue;\n        line = line.slice(at.length);\n\n        while (true) {\n          let match = /^(?:new |async )?\\S+ \\((.*)\\)$/.exec(line);\n\n          if (match) {\n            line = match[1];\n            continue;\n          }\n\n          match = /^eval at \\S+ \\((.*)\\)(?:, \\S+:\\d+:\\d+)?$/.exec(line);\n\n          if (match) {\n            line = match[1];\n            continue;\n          }\n\n          match = /^(\\S+):(\\d+):(\\d+)$/.exec(line);\n\n          if (match) {\n            let contents;\n\n            try {\n              contents = streamIn.readFileSync(match[1], \"utf8\");\n            } catch (e) {\n              break;\n            }\n\n            let lineText = contents.split(/\\r\\n|\\r|\\n|\\u2028|\\u2029/)[+match[2] - 1] || \"\";\n            let column = +match[3] - 1;\n            let length = lineText.slice(column, column + ident.length) === ident ? ident.length : 0;\n            return {\n              file: match[1],\n              namespace: \"file\",\n              line: +match[2],\n              column: encodeUTF8(lineText.slice(0, column)).length,\n              length: encodeUTF8(lineText.slice(column, column + length)).length,\n              lineText: lineText + \"\\n\" + lines.slice(1).join(\"\\n\"),\n              suggestion: \"\"\n            };\n          }\n\n          break;\n        }\n      }\n    }\n\n    return null;\n  }\n\n  function failureErrorWithLog(text, errors, warnings) {\n    let limit = 5;\n    let summary = errors.length < 1 ? \"\" : ` with ${errors.length} error${errors.length < 2 ? \"\" : \"s\"}:` + errors.slice(0, limit + 1).map((e, i) => {\n      if (i === limit) return \"\\n...\";\n      if (!e.location) return `\nerror: ${e.text}`;\n      let {\n        file,\n        line,\n        column\n      } = e.location;\n      let pluginText = e.pluginName ? `[plugin: ${e.pluginName}] ` : \"\";\n      return `\n${file}:${line}:${column}: ERROR: ${pluginText}${e.text}`;\n    }).join(\"\");\n    let error = new Error(`${text}${summary}`);\n    error.errors = errors;\n    error.warnings = warnings;\n    return error;\n  }\n\n  function replaceDetailsInMessages(messages, stash) {\n    for (const message of messages) {\n      message.detail = stash.load(message.detail);\n    }\n\n    return messages;\n  }\n\n  function sanitizeLocation(location, where) {\n    if (location == null) return null;\n    let keys = {};\n    let file = getFlag(location, keys, \"file\", mustBeString);\n    let namespace = getFlag(location, keys, \"namespace\", mustBeString);\n    let line = getFlag(location, keys, \"line\", mustBeInteger);\n    let column = getFlag(location, keys, \"column\", mustBeInteger);\n    let length = getFlag(location, keys, \"length\", mustBeInteger);\n    let lineText = getFlag(location, keys, \"lineText\", mustBeString);\n    let suggestion = getFlag(location, keys, \"suggestion\", mustBeString);\n    checkForInvalidFlags(location, keys, where);\n    return {\n      file: file || \"\",\n      namespace: namespace || \"\",\n      line: line || 0,\n      column: column || 0,\n      length: length || 0,\n      lineText: lineText || \"\",\n      suggestion: suggestion || \"\"\n    };\n  }\n\n  function sanitizeMessages(messages, property, stash, fallbackPluginName) {\n    let messagesClone = [];\n    let index = 0;\n\n    for (const message of messages) {\n      let keys = {};\n      let id = getFlag(message, keys, \"id\", mustBeString);\n      let pluginName = getFlag(message, keys, \"pluginName\", mustBeString);\n      let text = getFlag(message, keys, \"text\", mustBeString);\n      let location = getFlag(message, keys, \"location\", mustBeObjectOrNull);\n      let notes = getFlag(message, keys, \"notes\", mustBeArray);\n      let detail = getFlag(message, keys, \"detail\", canBeAnything);\n      let where = `in element ${index} of \"${property}\"`;\n      checkForInvalidFlags(message, keys, where);\n      let notesClone = [];\n\n      if (notes) {\n        for (const note of notes) {\n          let noteKeys = {};\n          let noteText = getFlag(note, noteKeys, \"text\", mustBeString);\n          let noteLocation = getFlag(note, noteKeys, \"location\", mustBeObjectOrNull);\n          checkForInvalidFlags(note, noteKeys, where);\n          notesClone.push({\n            text: noteText || \"\",\n            location: sanitizeLocation(noteLocation, where)\n          });\n        }\n      }\n\n      messagesClone.push({\n        id: id || \"\",\n        pluginName: pluginName || fallbackPluginName,\n        text: text || \"\",\n        location: sanitizeLocation(location, where),\n        notes: notesClone,\n        detail: stash ? stash.store(detail) : -1\n      });\n      index++;\n    }\n\n    return messagesClone;\n  }\n\n  function sanitizeStringArray(values, property) {\n    const result = [];\n\n    for (const value of values) {\n      if (typeof value !== \"string\") throw new Error(`${JSON.stringify(property)} must be an array of strings`);\n      result.push(value);\n    }\n\n    return result;\n  }\n\n  function convertOutputFiles({\n    path,\n    contents\n  }) {\n    let text = null;\n    return {\n      path,\n      contents,\n\n      get text() {\n        const binary = this.contents;\n\n        if (text === null || binary !== contents) {\n          contents = binary;\n          text = decodeUTF8(binary);\n        }\n\n        return text;\n      }\n\n    };\n  } // lib/npm/browser.ts\n\n\n  var version = \"0.15.5\";\n\n  var build = options => ensureServiceIsRunning().build(options);\n\n  var serve = () => {\n    throw new Error(`The \"serve\" API only works in node`);\n  };\n\n  var transform = (input, options) => ensureServiceIsRunning().transform(input, options);\n\n  var formatMessages = (messages, options) => ensureServiceIsRunning().formatMessages(messages, options);\n\n  var analyzeMetafile = (metafile, options) => ensureServiceIsRunning().analyzeMetafile(metafile, options);\n\n  var buildSync = () => {\n    throw new Error(`The \"buildSync\" API only works in node`);\n  };\n\n  var transformSync = () => {\n    throw new Error(`The \"transformSync\" API only works in node`);\n  };\n\n  var formatMessagesSync = () => {\n    throw new Error(`The \"formatMessagesSync\" API only works in node`);\n  };\n\n  var analyzeMetafileSync = () => {\n    throw new Error(`The \"analyzeMetafileSync\" API only works in node`);\n  };\n\n  var initializePromise;\n  var longLivedService;\n\n  var ensureServiceIsRunning = () => {\n    if (longLivedService) return longLivedService;\n    if (initializePromise) throw new Error('You need to wait for the promise returned from \"initialize\" to be resolved before calling this');\n    throw new Error('You need to call \"initialize\" before calling this');\n  };\n\n  var initialize = options => {\n    options = validateInitializeOptions(options || {});\n    let wasmURL = options.wasmURL;\n    let wasmModule = options.wasmModule;\n    let useWorker = options.worker !== false;\n    if (!wasmURL && !wasmModule) throw new Error('Must provide either the \"wasmURL\" option or the \"wasmModule\" option');\n    if (initializePromise) throw new Error('Cannot call \"initialize\" more than once');\n    initializePromise = startRunningService(wasmURL || \"\", wasmModule, useWorker);\n    initializePromise.catch(() => {\n      initializePromise = void 0;\n    });\n    return initializePromise;\n  };\n\n  var startRunningService = (wasmURL, wasmModule, useWorker) => __async(void 0, null, function* () {\n    let wasm;\n\n    if (wasmModule) {\n      wasm = wasmModule;\n    } else {\n      let res = yield fetch(wasmURL);\n      if (!res.ok) throw new Error(`Failed to download ${JSON.stringify(wasmURL)}`);\n      wasm = yield res.arrayBuffer();\n    }\n\n    let worker;\n\n    if (useWorker) {\n      let blob = new Blob([`onmessage=${'((postMessage) => {\\n      // Copyright 2018 The Go Authors. All rights reserved.\\n      // Use of this source code is governed by a BSD-style\\n      // license that can be found in the LICENSE file.\\n      var __async = (__this, __arguments, generator) => {\\n        return new Promise((resolve, reject) => {\\n          var fulfilled = (value) => {\\n            try {\\n              step(generator.next(value));\\n            } catch (e) {\\n              reject(e);\\n            }\\n          };\\n          var rejected = (value) => {\\n            try {\\n              step(generator.throw(value));\\n            } catch (e) {\\n              reject(e);\\n            }\\n          };\\n          var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\\n          step((generator = generator.apply(__this, __arguments)).next());\\n        });\\n      };\\n      let onmessage;\\n      let globalThis = {};\\n      for (let o = self; o; o = Object.getPrototypeOf(o))\\n        for (let k of Object.getOwnPropertyNames(o))\\n          if (!(k in globalThis))\\n            Object.defineProperty(globalThis, k, { get: () => self[k] });\\n      \"use strict\";\\n      (() => {\\n        const enosys = () => {\\n          const err = new Error(\"not implemented\");\\n          err.code = \"ENOSYS\";\\n          return err;\\n        };\\n        if (!globalThis.fs) {\\n          let outputBuf = \"\";\\n          globalThis.fs = {\\n            constants: { O_WRONLY: -1, O_RDWR: -1, O_CREAT: -1, O_TRUNC: -1, O_APPEND: -1, O_EXCL: -1 },\\n            writeSync(fd, buf) {\\n              outputBuf += decoder.decode(buf);\\n              const nl = outputBuf.lastIndexOf(\"\\\\n\");\\n              if (nl != -1) {\\n                console.log(outputBuf.substr(0, nl));\\n                outputBuf = outputBuf.substr(nl + 1);\\n              }\\n              return buf.length;\\n            },\\n            write(fd, buf, offset, length, position, callback) {\\n              if (offset !== 0 || length !== buf.length || position !== null) {\\n                callback(enosys());\\n                return;\\n              }\\n              const n = this.writeSync(fd, buf);\\n              callback(null, n);\\n            },\\n            chmod(path, mode, callback) {\\n              callback(enosys());\\n            },\\n            chown(path, uid, gid, callback) {\\n              callback(enosys());\\n            },\\n            close(fd, callback) {\\n              callback(enosys());\\n            },\\n            fchmod(fd, mode, callback) {\\n              callback(enosys());\\n            },\\n            fchown(fd, uid, gid, callback) {\\n              callback(enosys());\\n            },\\n            fstat(fd, callback) {\\n              callback(enosys());\\n            },\\n            fsync(fd, callback) {\\n              callback(null);\\n            },\\n            ftruncate(fd, length, callback) {\\n              callback(enosys());\\n            },\\n            lchown(path, uid, gid, callback) {\\n              callback(enosys());\\n            },\\n            link(path, link, callback) {\\n              callback(enosys());\\n            },\\n            lstat(path, callback) {\\n              callback(enosys());\\n            },\\n            mkdir(path, perm, callback) {\\n              callback(enosys());\\n            },\\n            open(path, flags, mode, callback) {\\n              callback(enosys());\\n            },\\n            read(fd, buffer, offset, length, position, callback) {\\n              callback(enosys());\\n            },\\n            readdir(path, callback) {\\n              callback(enosys());\\n            },\\n            readlink(path, callback) {\\n              callback(enosys());\\n            },\\n            rename(from, to, callback) {\\n              callback(enosys());\\n            },\\n            rmdir(path, callback) {\\n              callback(enosys());\\n            },\\n            stat(path, callback) {\\n              callback(enosys());\\n            },\\n            symlink(path, link, callback) {\\n              callback(enosys());\\n            },\\n            truncate(path, length, callback) {\\n              callback(enosys());\\n            },\\n            unlink(path, callback) {\\n              callback(enosys());\\n            },\\n            utimes(path, atime, mtime, callback) {\\n              callback(enosys());\\n            }\\n          };\\n        }\\n        if (!globalThis.process) {\\n          globalThis.process = {\\n            getuid() {\\n              return -1;\\n            },\\n            getgid() {\\n              return -1;\\n            },\\n            geteuid() {\\n              return -1;\\n            },\\n            getegid() {\\n              return -1;\\n            },\\n            getgroups() {\\n              throw enosys();\\n            },\\n            pid: -1,\\n            ppid: -1,\\n            umask() {\\n              throw enosys();\\n            },\\n            cwd() {\\n              throw enosys();\\n            },\\n            chdir() {\\n              throw enosys();\\n            }\\n          };\\n        }\\n        if (!globalThis.crypto) {\\n          throw new Error(\"globalThis.crypto is not available, polyfill required (crypto.getRandomValues only)\");\\n        }\\n        if (!globalThis.performance) {\\n          throw new Error(\"globalThis.performance is not available, polyfill required (performance.now only)\");\\n        }\\n        if (!globalThis.TextEncoder) {\\n          throw new Error(\"globalThis.TextEncoder is not available, polyfill required\");\\n        }\\n        if (!globalThis.TextDecoder) {\\n          throw new Error(\"globalThis.TextDecoder is not available, polyfill required\");\\n        }\\n        const encoder = new TextEncoder(\"utf-8\");\\n        const decoder = new TextDecoder(\"utf-8\");\\n        globalThis.Go = class {\\n          constructor() {\\n            this.argv = [\"js\"];\\n            this.env = {};\\n            this.exit = (code) => {\\n              if (code !== 0) {\\n                console.warn(\"exit code:\", code);\\n              }\\n            };\\n            this._exitPromise = new Promise((resolve) => {\\n              this._resolveExitPromise = resolve;\\n            });\\n            this._pendingEvent = null;\\n            this._scheduledTimeouts = /* @__PURE__ */ new Map();\\n            this._nextCallbackTimeoutID = 1;\\n            const setInt64 = (addr, v) => {\\n              this.mem.setUint32(addr + 0, v, true);\\n              this.mem.setUint32(addr + 4, Math.floor(v / 4294967296), true);\\n            };\\n            const getInt64 = (addr) => {\\n              const low = this.mem.getUint32(addr + 0, true);\\n              const high = this.mem.getInt32(addr + 4, true);\\n              return low + high * 4294967296;\\n            };\\n            const loadValue = (addr) => {\\n              const f = this.mem.getFloat64(addr, true);\\n              if (f === 0) {\\n                return void 0;\\n              }\\n              if (!isNaN(f)) {\\n                return f;\\n              }\\n              const id = this.mem.getUint32(addr, true);\\n              return this._values[id];\\n            };\\n            const storeValue = (addr, v) => {\\n              const nanHead = 2146959360;\\n              if (typeof v === \"number\" && v !== 0) {\\n                if (isNaN(v)) {\\n                  this.mem.setUint32(addr + 4, nanHead, true);\\n                  this.mem.setUint32(addr, 0, true);\\n                  return;\\n                }\\n                this.mem.setFloat64(addr, v, true);\\n                return;\\n              }\\n              if (v === void 0) {\\n                this.mem.setFloat64(addr, 0, true);\\n                return;\\n              }\\n              let id = this._ids.get(v);\\n              if (id === void 0) {\\n                id = this._idPool.pop();\\n                if (id === void 0) {\\n                  id = this._values.length;\\n                }\\n                this._values[id] = v;\\n                this._goRefCounts[id] = 0;\\n                this._ids.set(v, id);\\n              }\\n              this._goRefCounts[id]++;\\n              let typeFlag = 0;\\n              switch (typeof v) {\\n                case \"object\":\\n                  if (v !== null) {\\n                    typeFlag = 1;\\n                  }\\n                  break;\\n                case \"string\":\\n                  typeFlag = 2;\\n                  break;\\n                case \"symbol\":\\n                  typeFlag = 3;\\n                  break;\\n                case \"function\":\\n                  typeFlag = 4;\\n                  break;\\n              }\\n              this.mem.setUint32(addr + 4, nanHead | typeFlag, true);\\n              this.mem.setUint32(addr, id, true);\\n            };\\n            const loadSlice = (addr) => {\\n              const array = getInt64(addr + 0);\\n              const len = getInt64(addr + 8);\\n              return new Uint8Array(this._inst.exports.mem.buffer, array, len);\\n            };\\n            const loadSliceOfValues = (addr) => {\\n              const array = getInt64(addr + 0);\\n              const len = getInt64(addr + 8);\\n              const a = new Array(len);\\n              for (let i = 0; i < len; i++) {\\n                a[i] = loadValue(array + i * 8);\\n              }\\n              return a;\\n            };\\n            const loadString = (addr) => {\\n              const saddr = getInt64(addr + 0);\\n              const len = getInt64(addr + 8);\\n              return decoder.decode(new DataView(this._inst.exports.mem.buffer, saddr, len));\\n            };\\n            const timeOrigin = Date.now() - performance.now();\\n            this.importObject = {\\n              go: {\\n                \"runtime.wasmExit\": (sp) => {\\n                  sp >>>= 0;\\n                  const code = this.mem.getInt32(sp + 8, true);\\n                  this.exited = true;\\n                  delete this._inst;\\n                  delete this._values;\\n                  delete this._goRefCounts;\\n                  delete this._ids;\\n                  delete this._idPool;\\n                  this.exit(code);\\n                },\\n                \"runtime.wasmWrite\": (sp) => {\\n                  sp >>>= 0;\\n                  const fd = getInt64(sp + 8);\\n                  const p = getInt64(sp + 16);\\n                  const n = this.mem.getInt32(sp + 24, true);\\n                  globalThis.fs.writeSync(fd, new Uint8Array(this._inst.exports.mem.buffer, p, n));\\n                },\\n                \"runtime.resetMemoryDataView\": (sp) => {\\n                  sp >>>= 0;\\n                  this.mem = new DataView(this._inst.exports.mem.buffer);\\n                },\\n                \"runtime.nanotime1\": (sp) => {\\n                  sp >>>= 0;\\n                  setInt64(sp + 8, (timeOrigin + performance.now()) * 1e6);\\n                },\\n                \"runtime.walltime\": (sp) => {\\n                  sp >>>= 0;\\n                  const msec = new Date().getTime();\\n                  setInt64(sp + 8, msec / 1e3);\\n                  this.mem.setInt32(sp + 16, msec % 1e3 * 1e6, true);\\n                },\\n                \"runtime.scheduleTimeoutEvent\": (sp) => {\\n                  sp >>>= 0;\\n                  const id = this._nextCallbackTimeoutID;\\n                  this._nextCallbackTimeoutID++;\\n                  this._scheduledTimeouts.set(id, setTimeout(\\n                    () => {\\n                      this._resume();\\n                      while (this._scheduledTimeouts.has(id)) {\\n                        console.warn(\"scheduleTimeoutEvent: missed timeout event\");\\n                        this._resume();\\n                      }\\n                    },\\n                    getInt64(sp + 8) + 1\\n                  ));\\n                  this.mem.setInt32(sp + 16, id, true);\\n                },\\n                \"runtime.clearTimeoutEvent\": (sp) => {\\n                  sp >>>= 0;\\n                  const id = this.mem.getInt32(sp + 8, true);\\n                  clearTimeout(this._scheduledTimeouts.get(id));\\n                  this._scheduledTimeouts.delete(id);\\n                },\\n                \"runtime.getRandomData\": (sp) => {\\n                  sp >>>= 0;\\n                  crypto.getRandomValues(loadSlice(sp + 8));\\n                },\\n                \"syscall/js.finalizeRef\": (sp) => {\\n                  sp >>>= 0;\\n                  const id = this.mem.getUint32(sp + 8, true);\\n                  this._goRefCounts[id]--;\\n                  if (this._goRefCounts[id] === 0) {\\n                    const v = this._values[id];\\n                    this._values[id] = null;\\n                    this._ids.delete(v);\\n                    this._idPool.push(id);\\n                  }\\n                },\\n                \"syscall/js.stringVal\": (sp) => {\\n                  sp >>>= 0;\\n                  storeValue(sp + 24, loadString(sp + 8));\\n                },\\n                \"syscall/js.valueGet\": (sp) => {\\n                  sp >>>= 0;\\n                  const result = Reflect.get(loadValue(sp + 8), loadString(sp + 16));\\n                  sp = this._inst.exports.getsp() >>> 0;\\n                  storeValue(sp + 32, result);\\n                },\\n                \"syscall/js.valueSet\": (sp) => {\\n                  sp >>>= 0;\\n                  Reflect.set(loadValue(sp + 8), loadString(sp + 16), loadValue(sp + 32));\\n                },\\n                \"syscall/js.valueDelete\": (sp) => {\\n                  sp >>>= 0;\\n                  Reflect.deleteProperty(loadValue(sp + 8), loadString(sp + 16));\\n                },\\n                \"syscall/js.valueIndex\": (sp) => {\\n                  sp >>>= 0;\\n                  storeValue(sp + 24, Reflect.get(loadValue(sp + 8), getInt64(sp + 16)));\\n                },\\n                \"syscall/js.valueSetIndex\": (sp) => {\\n                  sp >>>= 0;\\n                  Reflect.set(loadValue(sp + 8), getInt64(sp + 16), loadValue(sp + 24));\\n                },\\n                \"syscall/js.valueCall\": (sp) => {\\n                  sp >>>= 0;\\n                  try {\\n                    const v = loadValue(sp + 8);\\n                    const m = Reflect.get(v, loadString(sp + 16));\\n                    const args = loadSliceOfValues(sp + 32);\\n                    const result = Reflect.apply(m, v, args);\\n                    sp = this._inst.exports.getsp() >>> 0;\\n                    storeValue(sp + 56, result);\\n                    this.mem.setUint8(sp + 64, 1);\\n                  } catch (err) {\\n                    sp = this._inst.exports.getsp() >>> 0;\\n                    storeValue(sp + 56, err);\\n                    this.mem.setUint8(sp + 64, 0);\\n                  }\\n                },\\n                \"syscall/js.valueInvoke\": (sp) => {\\n                  sp >>>= 0;\\n                  try {\\n                    const v = loadValue(sp + 8);\\n                    const args = loadSliceOfValues(sp + 16);\\n                    const result = Reflect.apply(v, void 0, args);\\n                    sp = this._inst.exports.getsp() >>> 0;\\n                    storeValue(sp + 40, result);\\n                    this.mem.setUint8(sp + 48, 1);\\n                  } catch (err) {\\n                    sp = this._inst.exports.getsp() >>> 0;\\n                    storeValue(sp + 40, err);\\n                    this.mem.setUint8(sp + 48, 0);\\n                  }\\n                },\\n                \"syscall/js.valueNew\": (sp) => {\\n                  sp >>>= 0;\\n                  try {\\n                    const v = loadValue(sp + 8);\\n                    const args = loadSliceOfValues(sp + 16);\\n                    const result = Reflect.construct(v, args);\\n                    sp = this._inst.exports.getsp() >>> 0;\\n                    storeValue(sp + 40, result);\\n                    this.mem.setUint8(sp + 48, 1);\\n                  } catch (err) {\\n                    sp = this._inst.exports.getsp() >>> 0;\\n                    storeValue(sp + 40, err);\\n                    this.mem.setUint8(sp + 48, 0);\\n                  }\\n                },\\n                \"syscall/js.valueLength\": (sp) => {\\n                  sp >>>= 0;\\n                  setInt64(sp + 16, parseInt(loadValue(sp + 8).length));\\n                },\\n                \"syscall/js.valuePrepareString\": (sp) => {\\n                  sp >>>= 0;\\n                  const str = encoder.encode(String(loadValue(sp + 8)));\\n                  storeValue(sp + 16, str);\\n                  setInt64(sp + 24, str.length);\\n                },\\n                \"syscall/js.valueLoadString\": (sp) => {\\n                  sp >>>= 0;\\n                  const str = loadValue(sp + 8);\\n                  loadSlice(sp + 16).set(str);\\n                },\\n                \"syscall/js.valueInstanceOf\": (sp) => {\\n                  sp >>>= 0;\\n                  this.mem.setUint8(sp + 24, loadValue(sp + 8) instanceof loadValue(sp + 16) ? 1 : 0);\\n                },\\n                \"syscall/js.copyBytesToGo\": (sp) => {\\n                  sp >>>= 0;\\n                  const dst = loadSlice(sp + 8);\\n                  const src = loadValue(sp + 32);\\n                  if (!(src instanceof Uint8Array || src instanceof Uint8ClampedArray)) {\\n                    this.mem.setUint8(sp + 48, 0);\\n                    return;\\n                  }\\n                  const toCopy = src.subarray(0, dst.length);\\n                  dst.set(toCopy);\\n                  setInt64(sp + 40, toCopy.length);\\n                  this.mem.setUint8(sp + 48, 1);\\n                },\\n                \"syscall/js.copyBytesToJS\": (sp) => {\\n                  sp >>>= 0;\\n                  const dst = loadValue(sp + 8);\\n                  const src = loadSlice(sp + 16);\\n                  if (!(dst instanceof Uint8Array || dst instanceof Uint8ClampedArray)) {\\n                    this.mem.setUint8(sp + 48, 0);\\n                    return;\\n                  }\\n                  const toCopy = src.subarray(0, dst.length);\\n                  dst.set(toCopy);\\n                  setInt64(sp + 40, toCopy.length);\\n                  this.mem.setUint8(sp + 48, 1);\\n                },\\n                \"debug\": (value) => {\\n                  console.log(value);\\n                }\\n              }\\n            };\\n          }\\n          run(instance) {\\n            return __async(this, null, function* () {\\n              if (!(instance instanceof WebAssembly.Instance)) {\\n                throw new Error(\"Go.run: WebAssembly.Instance expected\");\\n              }\\n              this._inst = instance;\\n              this.mem = new DataView(this._inst.exports.mem.buffer);\\n              this._values = [\\n                NaN,\\n                0,\\n                null,\\n                true,\\n                false,\\n                globalThis,\\n                this\\n              ];\\n              this._goRefCounts = new Array(this._values.length).fill(Infinity);\\n              this._ids = /* @__PURE__ */ new Map([\\n                [0, 1],\\n                [null, 2],\\n                [true, 3],\\n                [false, 4],\\n                [globalThis, 5],\\n                [this, 6]\\n              ]);\\n              this._idPool = [];\\n              this.exited = false;\\n              let offset = 4096;\\n              const strPtr = (str) => {\\n                const ptr = offset;\\n                const bytes = encoder.encode(str + \"\\\\0\");\\n                new Uint8Array(this.mem.buffer, offset, bytes.length).set(bytes);\\n                offset += bytes.length;\\n                if (offset % 8 !== 0) {\\n                  offset += 8 - offset % 8;\\n                }\\n                return ptr;\\n              };\\n              const argc = this.argv.length;\\n              const argvPtrs = [];\\n              this.argv.forEach((arg) => {\\n                argvPtrs.push(strPtr(arg));\\n              });\\n              argvPtrs.push(0);\\n              const keys = Object.keys(this.env).sort();\\n              keys.forEach((key) => {\\n                argvPtrs.push(strPtr(`${key}=${this.env[key]}`));\\n              });\\n              argvPtrs.push(0);\\n              const argv = offset;\\n              argvPtrs.forEach((ptr) => {\\n                this.mem.setUint32(offset, ptr, true);\\n                this.mem.setUint32(offset + 4, 0, true);\\n                offset += 8;\\n              });\\n              const wasmMinDataAddr = 4096 + 8192;\\n              if (offset >= wasmMinDataAddr) {\\n                throw new Error(\"total length of command line and environment variables exceeds limit\");\\n              }\\n              this._inst.exports.run(argc, argv);\\n              if (this.exited) {\\n                this._resolveExitPromise();\\n              }\\n              yield this._exitPromise;\\n            });\\n          }\\n          _resume() {\\n            if (this.exited) {\\n              throw new Error(\"Go program has already exited\");\\n            }\\n            this._inst.exports.resume();\\n            if (this.exited) {\\n              this._resolveExitPromise();\\n            }\\n          }\\n          _makeFuncWrapper(id) {\\n            const go = this;\\n            return function() {\\n              const event = { id, this: this, args: arguments };\\n              go._pendingEvent = event;\\n              go._resume();\\n              return event.result;\\n            };\\n          }\\n        };\\n      })();\\n      onmessage = ({ data: wasm }) => {\\n        let decoder = new TextDecoder();\\n        let fs = globalThis.fs;\\n        let stderr = \"\";\\n        fs.writeSync = (fd, buffer) => {\\n          if (fd === 1) {\\n            postMessage(buffer);\\n          } else if (fd === 2) {\\n            stderr += decoder.decode(buffer);\\n            let parts = stderr.split(\"\\\\n\");\\n            if (parts.length > 1)\\n              console.log(parts.slice(0, -1).join(\"\\\\n\"));\\n            stderr = parts[parts.length - 1];\\n          } else {\\n            throw new Error(\"Bad write\");\\n          }\\n          return buffer.length;\\n        };\\n        let stdin = [];\\n        let resumeStdin;\\n        let stdinPos = 0;\\n        onmessage = ({ data }) => {\\n          if (data.length > 0) {\\n            stdin.push(data);\\n            if (resumeStdin)\\n              resumeStdin();\\n          }\\n        };\\n        fs.read = (fd, buffer, offset, length, position, callback) => {\\n          if (fd !== 0 || offset !== 0 || length !== buffer.length || position !== null) {\\n            throw new Error(\"Bad read\");\\n          }\\n          if (stdin.length === 0) {\\n            resumeStdin = () => fs.read(fd, buffer, offset, length, position, callback);\\n            return;\\n          }\\n          let first = stdin[0];\\n          let count = Math.max(0, Math.min(length, first.length - stdinPos));\\n          buffer.set(first.subarray(stdinPos, stdinPos + count), offset);\\n          stdinPos += count;\\n          if (stdinPos === first.length) {\\n            stdin.shift();\\n            stdinPos = 0;\\n          }\\n          callback(null, count);\\n        };\\n        let go = new globalThis.Go();\\n        go.argv = [\"\", `--service=${\"0.15.5\"}`];\\n        if (wasm instanceof WebAssembly.Module) {\\n          WebAssembly.instantiate(wasm, go.importObject).then((instance) => go.run(instance));\\n        } else {\\n          WebAssembly.instantiate(wasm, go.importObject).then(({ instance }) => go.run(instance));\\n        }\\n      };\\n      return (m) => onmessage(m);\\n    })'}(postMessage)`], {\n        type: \"text/javascript\"\n      });\n      worker = new Worker(URL.createObjectURL(blob));\n    } else {\n      let onmessage = (postMessage => {\n        // Copyright 2018 The Go Authors. All rights reserved.\n        // Use of this source code is governed by a BSD-style\n        // license that can be found in the LICENSE file.\n        var __async = (__this, __arguments, generator) => {\n          return new Promise((resolve, reject) => {\n            var fulfilled = value => {\n              try {\n                step(generator.next(value));\n              } catch (e) {\n                reject(e);\n              }\n            };\n\n            var rejected = value => {\n              try {\n                step(generator.throw(value));\n              } catch (e) {\n                reject(e);\n              }\n            };\n\n            var step = x => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n\n            step((generator = generator.apply(__this, __arguments)).next());\n          });\n        };\n\n        let onmessage;\n        let globalThis = {};\n\n        for (let o = self; o; o = Object.getPrototypeOf(o)) for (let k of Object.getOwnPropertyNames(o)) if (!(k in globalThis)) Object.defineProperty(globalThis, k, {\n          get: () => self[k]\n        });\n\n        \"use strict\";\n\n        (() => {\n          const enosys = () => {\n            const err = new Error(\"not implemented\");\n            err.code = \"ENOSYS\";\n            return err;\n          };\n\n          if (!globalThis.fs) {\n            let outputBuf = \"\";\n            globalThis.fs = {\n              constants: {\n                O_WRONLY: -1,\n                O_RDWR: -1,\n                O_CREAT: -1,\n                O_TRUNC: -1,\n                O_APPEND: -1,\n                O_EXCL: -1\n              },\n\n              writeSync(fd, buf) {\n                outputBuf += decoder.decode(buf);\n                const nl = outputBuf.lastIndexOf(\"\\n\");\n\n                if (nl != -1) {\n                  console.log(outputBuf.substr(0, nl));\n                  outputBuf = outputBuf.substr(nl + 1);\n                }\n\n                return buf.length;\n              },\n\n              write(fd, buf, offset, length, position, callback) {\n                if (offset !== 0 || length !== buf.length || position !== null) {\n                  callback(enosys());\n                  return;\n                }\n\n                const n = this.writeSync(fd, buf);\n                callback(null, n);\n              },\n\n              chmod(path, mode, callback) {\n                callback(enosys());\n              },\n\n              chown(path, uid, gid, callback) {\n                callback(enosys());\n              },\n\n              close(fd, callback) {\n                callback(enosys());\n              },\n\n              fchmod(fd, mode, callback) {\n                callback(enosys());\n              },\n\n              fchown(fd, uid, gid, callback) {\n                callback(enosys());\n              },\n\n              fstat(fd, callback) {\n                callback(enosys());\n              },\n\n              fsync(fd, callback) {\n                callback(null);\n              },\n\n              ftruncate(fd, length, callback) {\n                callback(enosys());\n              },\n\n              lchown(path, uid, gid, callback) {\n                callback(enosys());\n              },\n\n              link(path, link, callback) {\n                callback(enosys());\n              },\n\n              lstat(path, callback) {\n                callback(enosys());\n              },\n\n              mkdir(path, perm, callback) {\n                callback(enosys());\n              },\n\n              open(path, flags, mode, callback) {\n                callback(enosys());\n              },\n\n              read(fd, buffer, offset, length, position, callback) {\n                callback(enosys());\n              },\n\n              readdir(path, callback) {\n                callback(enosys());\n              },\n\n              readlink(path, callback) {\n                callback(enosys());\n              },\n\n              rename(from, to, callback) {\n                callback(enosys());\n              },\n\n              rmdir(path, callback) {\n                callback(enosys());\n              },\n\n              stat(path, callback) {\n                callback(enosys());\n              },\n\n              symlink(path, link, callback) {\n                callback(enosys());\n              },\n\n              truncate(path, length, callback) {\n                callback(enosys());\n              },\n\n              unlink(path, callback) {\n                callback(enosys());\n              },\n\n              utimes(path, atime, mtime, callback) {\n                callback(enosys());\n              }\n\n            };\n          }\n\n          if (!globalThis.process) {\n            globalThis.process = {\n              getuid() {\n                return -1;\n              },\n\n              getgid() {\n                return -1;\n              },\n\n              geteuid() {\n                return -1;\n              },\n\n              getegid() {\n                return -1;\n              },\n\n              getgroups() {\n                throw enosys();\n              },\n\n              pid: -1,\n              ppid: -1,\n\n              umask() {\n                throw enosys();\n              },\n\n              cwd() {\n                throw enosys();\n              },\n\n              chdir() {\n                throw enosys();\n              }\n\n            };\n          }\n\n          if (!globalThis.crypto) {\n            throw new Error(\"globalThis.crypto is not available, polyfill required (crypto.getRandomValues only)\");\n          }\n\n          if (!globalThis.performance) {\n            throw new Error(\"globalThis.performance is not available, polyfill required (performance.now only)\");\n          }\n\n          if (!globalThis.TextEncoder) {\n            throw new Error(\"globalThis.TextEncoder is not available, polyfill required\");\n          }\n\n          if (!globalThis.TextDecoder) {\n            throw new Error(\"globalThis.TextDecoder is not available, polyfill required\");\n          }\n\n          const encoder = new TextEncoder(\"utf-8\");\n          const decoder = new TextDecoder(\"utf-8\");\n          globalThis.Go = class {\n            constructor() {\n              this.argv = [\"js\"];\n              this.env = {};\n\n              this.exit = code => {\n                if (code !== 0) {\n                  console.warn(\"exit code:\", code);\n                }\n              };\n\n              this._exitPromise = new Promise(resolve => {\n                this._resolveExitPromise = resolve;\n              });\n              this._pendingEvent = null;\n              this._scheduledTimeouts = /* @__PURE__ */new Map();\n              this._nextCallbackTimeoutID = 1;\n\n              const setInt64 = (addr, v) => {\n                this.mem.setUint32(addr + 0, v, true);\n                this.mem.setUint32(addr + 4, Math.floor(v / 4294967296), true);\n              };\n\n              const getInt64 = addr => {\n                const low = this.mem.getUint32(addr + 0, true);\n                const high = this.mem.getInt32(addr + 4, true);\n                return low + high * 4294967296;\n              };\n\n              const loadValue = addr => {\n                const f = this.mem.getFloat64(addr, true);\n\n                if (f === 0) {\n                  return void 0;\n                }\n\n                if (!isNaN(f)) {\n                  return f;\n                }\n\n                const id = this.mem.getUint32(addr, true);\n                return this._values[id];\n              };\n\n              const storeValue = (addr, v) => {\n                const nanHead = 2146959360;\n\n                if (typeof v === \"number\" && v !== 0) {\n                  if (isNaN(v)) {\n                    this.mem.setUint32(addr + 4, nanHead, true);\n                    this.mem.setUint32(addr, 0, true);\n                    return;\n                  }\n\n                  this.mem.setFloat64(addr, v, true);\n                  return;\n                }\n\n                if (v === void 0) {\n                  this.mem.setFloat64(addr, 0, true);\n                  return;\n                }\n\n                let id = this._ids.get(v);\n\n                if (id === void 0) {\n                  id = this._idPool.pop();\n\n                  if (id === void 0) {\n                    id = this._values.length;\n                  }\n\n                  this._values[id] = v;\n                  this._goRefCounts[id] = 0;\n\n                  this._ids.set(v, id);\n                }\n\n                this._goRefCounts[id]++;\n                let typeFlag = 0;\n\n                switch (typeof v) {\n                  case \"object\":\n                    if (v !== null) {\n                      typeFlag = 1;\n                    }\n\n                    break;\n\n                  case \"string\":\n                    typeFlag = 2;\n                    break;\n\n                  case \"symbol\":\n                    typeFlag = 3;\n                    break;\n\n                  case \"function\":\n                    typeFlag = 4;\n                    break;\n                }\n\n                this.mem.setUint32(addr + 4, nanHead | typeFlag, true);\n                this.mem.setUint32(addr, id, true);\n              };\n\n              const loadSlice = addr => {\n                const array = getInt64(addr + 0);\n                const len = getInt64(addr + 8);\n                return new Uint8Array(this._inst.exports.mem.buffer, array, len);\n              };\n\n              const loadSliceOfValues = addr => {\n                const array = getInt64(addr + 0);\n                const len = getInt64(addr + 8);\n                const a = new Array(len);\n\n                for (let i = 0; i < len; i++) {\n                  a[i] = loadValue(array + i * 8);\n                }\n\n                return a;\n              };\n\n              const loadString = addr => {\n                const saddr = getInt64(addr + 0);\n                const len = getInt64(addr + 8);\n                return decoder.decode(new DataView(this._inst.exports.mem.buffer, saddr, len));\n              };\n\n              const timeOrigin = Date.now() - performance.now();\n              this.importObject = {\n                go: {\n                  \"runtime.wasmExit\": sp => {\n                    sp >>>= 0;\n                    const code = this.mem.getInt32(sp + 8, true);\n                    this.exited = true;\n                    delete this._inst;\n                    delete this._values;\n                    delete this._goRefCounts;\n                    delete this._ids;\n                    delete this._idPool;\n                    this.exit(code);\n                  },\n                  \"runtime.wasmWrite\": sp => {\n                    sp >>>= 0;\n                    const fd = getInt64(sp + 8);\n                    const p = getInt64(sp + 16);\n                    const n = this.mem.getInt32(sp + 24, true);\n                    globalThis.fs.writeSync(fd, new Uint8Array(this._inst.exports.mem.buffer, p, n));\n                  },\n                  \"runtime.resetMemoryDataView\": sp => {\n                    sp >>>= 0;\n                    this.mem = new DataView(this._inst.exports.mem.buffer);\n                  },\n                  \"runtime.nanotime1\": sp => {\n                    sp >>>= 0;\n                    setInt64(sp + 8, (timeOrigin + performance.now()) * 1e6);\n                  },\n                  \"runtime.walltime\": sp => {\n                    sp >>>= 0;\n                    const msec = new Date().getTime();\n                    setInt64(sp + 8, msec / 1e3);\n                    this.mem.setInt32(sp + 16, msec % 1e3 * 1e6, true);\n                  },\n                  \"runtime.scheduleTimeoutEvent\": sp => {\n                    sp >>>= 0;\n                    const id = this._nextCallbackTimeoutID;\n                    this._nextCallbackTimeoutID++;\n\n                    this._scheduledTimeouts.set(id, setTimeout(() => {\n                      this._resume();\n\n                      while (this._scheduledTimeouts.has(id)) {\n                        console.warn(\"scheduleTimeoutEvent: missed timeout event\");\n\n                        this._resume();\n                      }\n                    }, getInt64(sp + 8) + 1));\n\n                    this.mem.setInt32(sp + 16, id, true);\n                  },\n                  \"runtime.clearTimeoutEvent\": sp => {\n                    sp >>>= 0;\n                    const id = this.mem.getInt32(sp + 8, true);\n                    clearTimeout(this._scheduledTimeouts.get(id));\n\n                    this._scheduledTimeouts.delete(id);\n                  },\n                  \"runtime.getRandomData\": sp => {\n                    sp >>>= 0;\n                    crypto.getRandomValues(loadSlice(sp + 8));\n                  },\n                  \"syscall/js.finalizeRef\": sp => {\n                    sp >>>= 0;\n                    const id = this.mem.getUint32(sp + 8, true);\n                    this._goRefCounts[id]--;\n\n                    if (this._goRefCounts[id] === 0) {\n                      const v = this._values[id];\n                      this._values[id] = null;\n\n                      this._ids.delete(v);\n\n                      this._idPool.push(id);\n                    }\n                  },\n                  \"syscall/js.stringVal\": sp => {\n                    sp >>>= 0;\n                    storeValue(sp + 24, loadString(sp + 8));\n                  },\n                  \"syscall/js.valueGet\": sp => {\n                    sp >>>= 0;\n                    const result = Reflect.get(loadValue(sp + 8), loadString(sp + 16));\n                    sp = this._inst.exports.getsp() >>> 0;\n                    storeValue(sp + 32, result);\n                  },\n                  \"syscall/js.valueSet\": sp => {\n                    sp >>>= 0;\n                    Reflect.set(loadValue(sp + 8), loadString(sp + 16), loadValue(sp + 32));\n                  },\n                  \"syscall/js.valueDelete\": sp => {\n                    sp >>>= 0;\n                    Reflect.deleteProperty(loadValue(sp + 8), loadString(sp + 16));\n                  },\n                  \"syscall/js.valueIndex\": sp => {\n                    sp >>>= 0;\n                    storeValue(sp + 24, Reflect.get(loadValue(sp + 8), getInt64(sp + 16)));\n                  },\n                  \"syscall/js.valueSetIndex\": sp => {\n                    sp >>>= 0;\n                    Reflect.set(loadValue(sp + 8), getInt64(sp + 16), loadValue(sp + 24));\n                  },\n                  \"syscall/js.valueCall\": sp => {\n                    sp >>>= 0;\n\n                    try {\n                      const v = loadValue(sp + 8);\n                      const m = Reflect.get(v, loadString(sp + 16));\n                      const args = loadSliceOfValues(sp + 32);\n                      const result = Reflect.apply(m, v, args);\n                      sp = this._inst.exports.getsp() >>> 0;\n                      storeValue(sp + 56, result);\n                      this.mem.setUint8(sp + 64, 1);\n                    } catch (err) {\n                      sp = this._inst.exports.getsp() >>> 0;\n                      storeValue(sp + 56, err);\n                      this.mem.setUint8(sp + 64, 0);\n                    }\n                  },\n                  \"syscall/js.valueInvoke\": sp => {\n                    sp >>>= 0;\n\n                    try {\n                      const v = loadValue(sp + 8);\n                      const args = loadSliceOfValues(sp + 16);\n                      const result = Reflect.apply(v, void 0, args);\n                      sp = this._inst.exports.getsp() >>> 0;\n                      storeValue(sp + 40, result);\n                      this.mem.setUint8(sp + 48, 1);\n                    } catch (err) {\n                      sp = this._inst.exports.getsp() >>> 0;\n                      storeValue(sp + 40, err);\n                      this.mem.setUint8(sp + 48, 0);\n                    }\n                  },\n                  \"syscall/js.valueNew\": sp => {\n                    sp >>>= 0;\n\n                    try {\n                      const v = loadValue(sp + 8);\n                      const args = loadSliceOfValues(sp + 16);\n                      const result = Reflect.construct(v, args);\n                      sp = this._inst.exports.getsp() >>> 0;\n                      storeValue(sp + 40, result);\n                      this.mem.setUint8(sp + 48, 1);\n                    } catch (err) {\n                      sp = this._inst.exports.getsp() >>> 0;\n                      storeValue(sp + 40, err);\n                      this.mem.setUint8(sp + 48, 0);\n                    }\n                  },\n                  \"syscall/js.valueLength\": sp => {\n                    sp >>>= 0;\n                    setInt64(sp + 16, parseInt(loadValue(sp + 8).length));\n                  },\n                  \"syscall/js.valuePrepareString\": sp => {\n                    sp >>>= 0;\n                    const str = encoder.encode(String(loadValue(sp + 8)));\n                    storeValue(sp + 16, str);\n                    setInt64(sp + 24, str.length);\n                  },\n                  \"syscall/js.valueLoadString\": sp => {\n                    sp >>>= 0;\n                    const str = loadValue(sp + 8);\n                    loadSlice(sp + 16).set(str);\n                  },\n                  \"syscall/js.valueInstanceOf\": sp => {\n                    sp >>>= 0;\n                    this.mem.setUint8(sp + 24, loadValue(sp + 8) instanceof loadValue(sp + 16) ? 1 : 0);\n                  },\n                  \"syscall/js.copyBytesToGo\": sp => {\n                    sp >>>= 0;\n                    const dst = loadSlice(sp + 8);\n                    const src = loadValue(sp + 32);\n\n                    if (!(src instanceof Uint8Array || src instanceof Uint8ClampedArray)) {\n                      this.mem.setUint8(sp + 48, 0);\n                      return;\n                    }\n\n                    const toCopy = src.subarray(0, dst.length);\n                    dst.set(toCopy);\n                    setInt64(sp + 40, toCopy.length);\n                    this.mem.setUint8(sp + 48, 1);\n                  },\n                  \"syscall/js.copyBytesToJS\": sp => {\n                    sp >>>= 0;\n                    const dst = loadValue(sp + 8);\n                    const src = loadSlice(sp + 16);\n\n                    if (!(dst instanceof Uint8Array || dst instanceof Uint8ClampedArray)) {\n                      this.mem.setUint8(sp + 48, 0);\n                      return;\n                    }\n\n                    const toCopy = src.subarray(0, dst.length);\n                    dst.set(toCopy);\n                    setInt64(sp + 40, toCopy.length);\n                    this.mem.setUint8(sp + 48, 1);\n                  },\n                  \"debug\": value => {\n                    console.log(value);\n                  }\n                }\n              };\n            }\n\n            run(instance) {\n              return __async(this, null, function* () {\n                if (!(instance instanceof WebAssembly.Instance)) {\n                  throw new Error(\"Go.run: WebAssembly.Instance expected\");\n                }\n\n                this._inst = instance;\n                this.mem = new DataView(this._inst.exports.mem.buffer);\n                this._values = [NaN, 0, null, true, false, globalThis, this];\n                this._goRefCounts = new Array(this._values.length).fill(Infinity);\n                this._ids = /* @__PURE__ */new Map([[0, 1], [null, 2], [true, 3], [false, 4], [globalThis, 5], [this, 6]]);\n                this._idPool = [];\n                this.exited = false;\n                let offset = 4096;\n\n                const strPtr = str => {\n                  const ptr = offset;\n                  const bytes = encoder.encode(str + \"\\0\");\n                  new Uint8Array(this.mem.buffer, offset, bytes.length).set(bytes);\n                  offset += bytes.length;\n\n                  if (offset % 8 !== 0) {\n                    offset += 8 - offset % 8;\n                  }\n\n                  return ptr;\n                };\n\n                const argc = this.argv.length;\n                const argvPtrs = [];\n                this.argv.forEach(arg => {\n                  argvPtrs.push(strPtr(arg));\n                });\n                argvPtrs.push(0);\n                const keys = Object.keys(this.env).sort();\n                keys.forEach(key => {\n                  argvPtrs.push(strPtr(`${key}=${this.env[key]}`));\n                });\n                argvPtrs.push(0);\n                const argv = offset;\n                argvPtrs.forEach(ptr => {\n                  this.mem.setUint32(offset, ptr, true);\n                  this.mem.setUint32(offset + 4, 0, true);\n                  offset += 8;\n                });\n                const wasmMinDataAddr = 4096 + 8192;\n\n                if (offset >= wasmMinDataAddr) {\n                  throw new Error(\"total length of command line and environment variables exceeds limit\");\n                }\n\n                this._inst.exports.run(argc, argv);\n\n                if (this.exited) {\n                  this._resolveExitPromise();\n                }\n\n                yield this._exitPromise;\n              });\n            }\n\n            _resume() {\n              if (this.exited) {\n                throw new Error(\"Go program has already exited\");\n              }\n\n              this._inst.exports.resume();\n\n              if (this.exited) {\n                this._resolveExitPromise();\n              }\n            }\n\n            _makeFuncWrapper(id) {\n              const go = this;\n              return function () {\n                const event = {\n                  id,\n                  this: this,\n                  args: arguments\n                };\n                go._pendingEvent = event;\n\n                go._resume();\n\n                return event.result;\n              };\n            }\n\n          };\n        })();\n\n        onmessage = ({\n          data: wasm\n        }) => {\n          let decoder = new TextDecoder();\n          let fs = globalThis.fs;\n          let stderr = \"\";\n\n          fs.writeSync = (fd, buffer) => {\n            if (fd === 1) {\n              postMessage(buffer);\n            } else if (fd === 2) {\n              stderr += decoder.decode(buffer);\n              let parts = stderr.split(\"\\n\");\n              if (parts.length > 1) console.log(parts.slice(0, -1).join(\"\\n\"));\n              stderr = parts[parts.length - 1];\n            } else {\n              throw new Error(\"Bad write\");\n            }\n\n            return buffer.length;\n          };\n\n          let stdin = [];\n          let resumeStdin;\n          let stdinPos = 0;\n\n          onmessage = ({\n            data\n          }) => {\n            if (data.length > 0) {\n              stdin.push(data);\n              if (resumeStdin) resumeStdin();\n            }\n          };\n\n          fs.read = (fd, buffer, offset, length, position, callback) => {\n            if (fd !== 0 || offset !== 0 || length !== buffer.length || position !== null) {\n              throw new Error(\"Bad read\");\n            }\n\n            if (stdin.length === 0) {\n              resumeStdin = () => fs.read(fd, buffer, offset, length, position, callback);\n\n              return;\n            }\n\n            let first = stdin[0];\n            let count = Math.max(0, Math.min(length, first.length - stdinPos));\n            buffer.set(first.subarray(stdinPos, stdinPos + count), offset);\n            stdinPos += count;\n\n            if (stdinPos === first.length) {\n              stdin.shift();\n              stdinPos = 0;\n            }\n\n            callback(null, count);\n          };\n\n          let go = new globalThis.Go();\n          go.argv = [\"\", `--service=${\"0.15.5\"}`];\n\n          if (wasm instanceof WebAssembly.Module) {\n            WebAssembly.instantiate(wasm, go.importObject).then(instance => go.run(instance));\n          } else {\n            WebAssembly.instantiate(wasm, go.importObject).then(({\n              instance\n            }) => go.run(instance));\n          }\n        };\n\n        return m => onmessage(m);\n      })(data => worker.onmessage({\n        data\n      }));\n\n      worker = {\n        onmessage: null,\n        postMessage: data => setTimeout(() => onmessage({\n          data\n        })),\n\n        terminate() {}\n\n      };\n    }\n\n    worker.postMessage(wasm);\n\n    worker.onmessage = ({\n      data\n    }) => readFromStdout(data);\n\n    let {\n      readFromStdout,\n      service\n    } = createChannel({\n      writeToStdin(bytes) {\n        worker.postMessage(bytes);\n      },\n\n      isSync: false,\n      isWriteUnavailable: true,\n      esbuild: browser_exports\n    });\n    longLivedService = {\n      build: options => new Promise((resolve, reject) => service.buildOrServe({\n        callName: \"build\",\n        refs: null,\n        serveOptions: null,\n        options,\n        isTTY: false,\n        defaultWD: \"/\",\n        callback: (err, res) => err ? reject(err) : resolve(res)\n      })),\n      transform: (input, options) => new Promise((resolve, reject) => service.transform({\n        callName: \"transform\",\n        refs: null,\n        input,\n        options: options || {},\n        isTTY: false,\n        fs: {\n          readFile(_, callback) {\n            callback(new Error(\"Internal error\"), null);\n          },\n\n          writeFile(_, callback) {\n            callback(null);\n          }\n\n        },\n        callback: (err, res) => err ? reject(err) : resolve(res)\n      })),\n      formatMessages: (messages, options) => new Promise((resolve, reject) => service.formatMessages({\n        callName: \"formatMessages\",\n        refs: null,\n        messages,\n        options,\n        callback: (err, res) => err ? reject(err) : resolve(res)\n      })),\n      analyzeMetafile: (metafile, options) => new Promise((resolve, reject) => service.analyzeMetafile({\n        callName: \"analyzeMetafile\",\n        refs: null,\n        metafile: typeof metafile === \"string\" ? metafile : JSON.stringify(metafile),\n        options,\n        callback: (err, res) => err ? reject(err) : resolve(res)\n      }))\n    };\n  });\n\n  var browser_default = browser_exports;\n})(typeof module === \"object\" ? module : {\n  set exports(x) {\n    (typeof self !== \"undefined\" ? self : this).esbuild = x;\n  }\n\n});","map":{"version":3,"names":["module","__defProp","Object","defineProperty","__defProps","defineProperties","__getOwnPropDesc","getOwnPropertyDescriptor","__getOwnPropDescs","getOwnPropertyDescriptors","__getOwnPropNames","getOwnPropertyNames","__getOwnPropSymbols","getOwnPropertySymbols","__hasOwnProp","prototype","hasOwnProperty","__propIsEnum","propertyIsEnumerable","__defNormalProp","obj","key","value","enumerable","configurable","writable","__spreadValues","a","b","prop","call","__spreadProps","__export","target","all","name","get","__copyProps","to","from","except","desc","__toCommonJS","mod","__async","__this","__arguments","generator","Promise","resolve","reject","fulfilled","step","next","e","rejected","throw","x","done","then","apply","browser_exports","analyzeMetafile","analyzeMetafileSync","build","buildSync","default","browser_default","formatMessages","formatMessagesSync","initialize","serve","transform","transformSync","version","exports","encodePacket","packet","visit","bb","write8","write32","write","encodeUTF8","Uint8Array","Array","length","item","keys","ByteBuffer","id","isRequest","writeUInt32LE","buf","len","subarray","decodePacket","bytes","read8","read32","decodeUTF8","read","count","value2","i","push","Error","ptr","constructor","_write","delta","clone","set","offset","_read","readUInt32LE","TextEncoder","TextDecoder","encoder","decoder","text","encode","decode","Buffer","buffer","byteOffset","byteLength","toString","validateTarget","indexOf","canBeAnything","mustBeBoolean","mustBeBooleanOrObject","isArray","mustBeString","mustBeRegExp","RegExp","mustBeInteger","mustBeFunction","mustBeArray","mustBeObject","mustBeWebAssemblyModule","WebAssembly","Module","mustBeArrayOrRecord","mustBeObjectOrNull","mustBeStringOrBoolean","mustBeStringOrObject","mustBeStringOrArray","mustBeStringOrUint8Array","getFlag","object","mustBeFn","mustBe","checkForInvalidFlags","where","validateInitializeOptions","options","create","wasmURL","wasmModule","worker","validateMangleCache","mangleCache","validated","JSON","stringify","pushLogFlags","flags","isTTY","logLevelDefault","color","logLevel","logLimit","pushCommonFlags","legalComments","sourceRoot","sourcesContent","format","globalName","mangleProps","reserveProps","mangleQuoted","minify","minifySyntax","minifyWhitespace","minifyIdentifiers","drop","charset","treeShaking","ignoreAnnotations","jsx","jsxFactory","jsxFragment","jsxImportSource","jsxDev","define","logOverride","supported","pure","keepNames","platform","map","join","what","source","fn","flagsForBuildOptions","callName","writeDefault","_a","entries","stdinContents","stdinResolveDir","watchMode","sourcemap","bundle","watch","splitting","preserveSymlinks","metafile","outfile","outdir","outbase","tsconfig","resolveExtensions","nodePathsInput","mainFields","conditions","external","loader","outExtension","publicPath","entryNames","chunkNames","assetNames","inject","banner","footer","entryPoints","absWorkingDir","stdin","allowOverwrite","incremental","plugins","watchKeys","onRebuild","values","type","path","ext","entryPoint","stdinKeys","contents","resolveDir","sourcefile","loader2","nodePaths","flagsForTransformOptions","tsconfigRaw","createChannel","streamIn","responseCallbacks","Map","pluginCallbacks","watchCallbacks","serveCallbacks","closeData","nextRequestID","nextBuildKey","stdout","stdoutUsed","readFromStdout","chunk","limit","swap","handleIncomingPacket","copyWithin","afterClose","error","reason","message","callback","clear","callbacks","onWait","console","sendRequest","refs","response","unref","ref","writeToStdin","sendResponse","handleRequest","request","command","onRequest","args","err","errors","extractErrorMessageV8","isFirstPacket","binaryVersion","String","fromCharCode","delete","handlePlugins","initialOptions","buildKey","stash","onStartCallbacks","onEndCallbacks","onResolveCallbacks","onLoadCallbacks","nextCallbackID","requestPlugins","isSetupDone","setup","plugin","onResolve","onLoad","keys2","pluginName","importer","namespace","kind","pluginData","resolve2","store","replaceDetailsInMessages","warnings","sideEffects","suffix","load","promise","onStart","callback2","registeredText","registeredNote","extractCallerV8","note","onEnd","filter","esbuild","ok","_0","result","sanitizeMessages","ids","watchFiles","watchDirs","sanitizeStringArray","runOnEndCallbacks","logPluginError","refCount","pluginRefs","buildServeData","port","host","servedir","wait","stop","buildLogLevelDefault","transformLogLevelDefault","buildOrServe","details","createObjectStash","e2","detail","handleError","failureErrorWithLog","isSync","buildOrServeContinue","logPluginError2","callerRefs","serveOptions","defaultWD","isWriteUnavailable","serve2","rebuild","copyResponseToResult","outputFiles","convertOutputFiles","parse","writeToStdout","log","replace","buildResponseToResult","isDisposed","error2","response2","location","notes","error3","result3","dispose","isStopped","serviceStopError","watchResponse","result2","rebuildID","serveResponse","transform2","input","fs","start","inputPath","inputFS","outstanding","code","codeFS","readFile","mapFS","writeFile","formatMessages2","messages","terminalWidth","isWarning","analyzeMetafile2","verbose","service","nextID","ident","tried","lines","stack","split","splice","parseStackLinesV8","at","readFileSync","startsWith","line","slice","match","exec","lineText","column","file","suggestion","summary","pluginText","sanitizeLocation","property","fallbackPluginName","messagesClone","index","notesClone","noteKeys","noteText","noteLocation","binary","ensureServiceIsRunning","initializePromise","longLivedService","useWorker","startRunningService","catch","wasm","res","fetch","arrayBuffer","blob","Blob","Worker","URL","createObjectURL","onmessage","postMessage","globalThis","o","self","getPrototypeOf","k","enosys","outputBuf","constants","O_WRONLY","O_RDWR","O_CREAT","O_TRUNC","O_APPEND","O_EXCL","writeSync","fd","nl","lastIndexOf","substr","position","n","chmod","mode","chown","uid","gid","close","fchmod","fchown","fstat","fsync","ftruncate","lchown","link","lstat","mkdir","perm","open","readdir","readlink","rename","rmdir","stat","symlink","truncate","unlink","utimes","atime","mtime","process","getuid","getgid","geteuid","getegid","getgroups","pid","ppid","umask","cwd","chdir","crypto","performance","Go","argv","env","exit","warn","_exitPromise","_resolveExitPromise","_pendingEvent","_scheduledTimeouts","_nextCallbackTimeoutID","setInt64","addr","v","mem","setUint32","Math","floor","getInt64","low","getUint32","high","getInt32","loadValue","f","getFloat64","isNaN","_values","storeValue","nanHead","setFloat64","_ids","_idPool","pop","_goRefCounts","typeFlag","loadSlice","array","_inst","loadSliceOfValues","loadString","saddr","DataView","timeOrigin","Date","now","importObject","go","sp","exited","p","msec","getTime","setInt32","setTimeout","_resume","has","clearTimeout","getRandomValues","Reflect","getsp","deleteProperty","m","setUint8","construct","parseInt","str","dst","src","Uint8ClampedArray","toCopy","run","instance","Instance","NaN","fill","Infinity","strPtr","argc","argvPtrs","forEach","arg","sort","wasmMinDataAddr","resume","_makeFuncWrapper","event","this","arguments","data","stderr","parts","resumeStdin","stdinPos","first","max","min","shift","instantiate","terminate","_"],"sources":["/Users/deliabarbuta/Documents/An4Sem1/PAW/Proiect/proiect-paw-tadam/Frontend_OceanCross/node_modules/esbuild-wasm/lib/browser.js"],"sourcesContent":["(module=>{\n\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\n\n// lib/npm/browser.ts\nvar browser_exports = {};\n__export(browser_exports, {\n  analyzeMetafile: () => analyzeMetafile,\n  analyzeMetafileSync: () => analyzeMetafileSync,\n  build: () => build,\n  buildSync: () => buildSync,\n  default: () => browser_default,\n  formatMessages: () => formatMessages,\n  formatMessagesSync: () => formatMessagesSync,\n  initialize: () => initialize,\n  serve: () => serve,\n  transform: () => transform,\n  transformSync: () => transformSync,\n  version: () => version\n});\nmodule.exports = __toCommonJS(browser_exports);\n\n// lib/shared/stdio_protocol.ts\nfunction encodePacket(packet) {\n  let visit = (value) => {\n    if (value === null) {\n      bb.write8(0);\n    } else if (typeof value === \"boolean\") {\n      bb.write8(1);\n      bb.write8(+value);\n    } else if (typeof value === \"number\") {\n      bb.write8(2);\n      bb.write32(value | 0);\n    } else if (typeof value === \"string\") {\n      bb.write8(3);\n      bb.write(encodeUTF8(value));\n    } else if (value instanceof Uint8Array) {\n      bb.write8(4);\n      bb.write(value);\n    } else if (value instanceof Array) {\n      bb.write8(5);\n      bb.write32(value.length);\n      for (let item of value) {\n        visit(item);\n      }\n    } else {\n      let keys = Object.keys(value);\n      bb.write8(6);\n      bb.write32(keys.length);\n      for (let key of keys) {\n        bb.write(encodeUTF8(key));\n        visit(value[key]);\n      }\n    }\n  };\n  let bb = new ByteBuffer();\n  bb.write32(0);\n  bb.write32(packet.id << 1 | +!packet.isRequest);\n  visit(packet.value);\n  writeUInt32LE(bb.buf, bb.len - 4, 0);\n  return bb.buf.subarray(0, bb.len);\n}\nfunction decodePacket(bytes) {\n  let visit = () => {\n    switch (bb.read8()) {\n      case 0:\n        return null;\n      case 1:\n        return !!bb.read8();\n      case 2:\n        return bb.read32();\n      case 3:\n        return decodeUTF8(bb.read());\n      case 4:\n        return bb.read();\n      case 5: {\n        let count = bb.read32();\n        let value2 = [];\n        for (let i = 0; i < count; i++) {\n          value2.push(visit());\n        }\n        return value2;\n      }\n      case 6: {\n        let count = bb.read32();\n        let value2 = {};\n        for (let i = 0; i < count; i++) {\n          value2[decodeUTF8(bb.read())] = visit();\n        }\n        return value2;\n      }\n      default:\n        throw new Error(\"Invalid packet\");\n    }\n  };\n  let bb = new ByteBuffer(bytes);\n  let id = bb.read32();\n  let isRequest = (id & 1) === 0;\n  id >>>= 1;\n  let value = visit();\n  if (bb.ptr !== bytes.length) {\n    throw new Error(\"Invalid packet\");\n  }\n  return { id, isRequest, value };\n}\nvar ByteBuffer = class {\n  constructor(buf = new Uint8Array(1024)) {\n    this.buf = buf;\n    this.len = 0;\n    this.ptr = 0;\n  }\n  _write(delta) {\n    if (this.len + delta > this.buf.length) {\n      let clone = new Uint8Array((this.len + delta) * 2);\n      clone.set(this.buf);\n      this.buf = clone;\n    }\n    this.len += delta;\n    return this.len - delta;\n  }\n  write8(value) {\n    let offset = this._write(1);\n    this.buf[offset] = value;\n  }\n  write32(value) {\n    let offset = this._write(4);\n    writeUInt32LE(this.buf, value, offset);\n  }\n  write(bytes) {\n    let offset = this._write(4 + bytes.length);\n    writeUInt32LE(this.buf, bytes.length, offset);\n    this.buf.set(bytes, offset + 4);\n  }\n  _read(delta) {\n    if (this.ptr + delta > this.buf.length) {\n      throw new Error(\"Invalid packet\");\n    }\n    this.ptr += delta;\n    return this.ptr - delta;\n  }\n  read8() {\n    return this.buf[this._read(1)];\n  }\n  read32() {\n    return readUInt32LE(this.buf, this._read(4));\n  }\n  read() {\n    let length = this.read32();\n    let bytes = new Uint8Array(length);\n    let ptr = this._read(bytes.length);\n    bytes.set(this.buf.subarray(ptr, ptr + length));\n    return bytes;\n  }\n};\nvar encodeUTF8;\nvar decodeUTF8;\nif (typeof TextEncoder !== \"undefined\" && typeof TextDecoder !== \"undefined\") {\n  let encoder = new TextEncoder();\n  let decoder = new TextDecoder();\n  encodeUTF8 = (text) => encoder.encode(text);\n  decodeUTF8 = (bytes) => decoder.decode(bytes);\n} else if (typeof Buffer !== \"undefined\") {\n  encodeUTF8 = (text) => {\n    let buffer = Buffer.from(text);\n    if (!(buffer instanceof Uint8Array)) {\n      buffer = new Uint8Array(buffer);\n    }\n    return buffer;\n  };\n  decodeUTF8 = (bytes) => {\n    let { buffer, byteOffset, byteLength } = bytes;\n    return Buffer.from(buffer, byteOffset, byteLength).toString();\n  };\n} else {\n  throw new Error(\"No UTF-8 codec found\");\n}\nfunction readUInt32LE(buffer, offset) {\n  return buffer[offset++] | buffer[offset++] << 8 | buffer[offset++] << 16 | buffer[offset++] << 24;\n}\nfunction writeUInt32LE(buffer, value, offset) {\n  buffer[offset++] = value;\n  buffer[offset++] = value >> 8;\n  buffer[offset++] = value >> 16;\n  buffer[offset++] = value >> 24;\n}\n\n// lib/shared/common.ts\nfunction validateTarget(target) {\n  target += \"\";\n  if (target.indexOf(\",\") >= 0)\n    throw new Error(`Invalid target: ${target}`);\n  return target;\n}\nvar canBeAnything = () => null;\nvar mustBeBoolean = (value) => typeof value === \"boolean\" ? null : \"a boolean\";\nvar mustBeBooleanOrObject = (value) => typeof value === \"boolean\" || typeof value === \"object\" && !Array.isArray(value) ? null : \"a boolean or an object\";\nvar mustBeString = (value) => typeof value === \"string\" ? null : \"a string\";\nvar mustBeRegExp = (value) => value instanceof RegExp ? null : \"a RegExp object\";\nvar mustBeInteger = (value) => typeof value === \"number\" && value === (value | 0) ? null : \"an integer\";\nvar mustBeFunction = (value) => typeof value === \"function\" ? null : \"a function\";\nvar mustBeArray = (value) => Array.isArray(value) ? null : \"an array\";\nvar mustBeObject = (value) => typeof value === \"object\" && value !== null && !Array.isArray(value) ? null : \"an object\";\nvar mustBeWebAssemblyModule = (value) => value instanceof WebAssembly.Module ? null : \"a WebAssembly.Module\";\nvar mustBeArrayOrRecord = (value) => typeof value === \"object\" && value !== null ? null : \"an array or an object\";\nvar mustBeObjectOrNull = (value) => typeof value === \"object\" && !Array.isArray(value) ? null : \"an object or null\";\nvar mustBeStringOrBoolean = (value) => typeof value === \"string\" || typeof value === \"boolean\" ? null : \"a string or a boolean\";\nvar mustBeStringOrObject = (value) => typeof value === \"string\" || typeof value === \"object\" && value !== null && !Array.isArray(value) ? null : \"a string or an object\";\nvar mustBeStringOrArray = (value) => typeof value === \"string\" || Array.isArray(value) ? null : \"a string or an array\";\nvar mustBeStringOrUint8Array = (value) => typeof value === \"string\" || value instanceof Uint8Array ? null : \"a string or a Uint8Array\";\nfunction getFlag(object, keys, key, mustBeFn) {\n  let value = object[key];\n  keys[key + \"\"] = true;\n  if (value === void 0)\n    return void 0;\n  let mustBe = mustBeFn(value);\n  if (mustBe !== null)\n    throw new Error(`\"${key}\" must be ${mustBe}`);\n  return value;\n}\nfunction checkForInvalidFlags(object, keys, where) {\n  for (let key in object) {\n    if (!(key in keys)) {\n      throw new Error(`Invalid option ${where}: \"${key}\"`);\n    }\n  }\n}\nfunction validateInitializeOptions(options) {\n  let keys = /* @__PURE__ */ Object.create(null);\n  let wasmURL = getFlag(options, keys, \"wasmURL\", mustBeString);\n  let wasmModule = getFlag(options, keys, \"wasmModule\", mustBeWebAssemblyModule);\n  let worker = getFlag(options, keys, \"worker\", mustBeBoolean);\n  checkForInvalidFlags(options, keys, \"in initialize() call\");\n  return {\n    wasmURL,\n    wasmModule,\n    worker\n  };\n}\nfunction validateMangleCache(mangleCache) {\n  let validated;\n  if (mangleCache !== void 0) {\n    validated = /* @__PURE__ */ Object.create(null);\n    for (let key of Object.keys(mangleCache)) {\n      let value = mangleCache[key];\n      if (typeof value === \"string\" || value === false) {\n        validated[key] = value;\n      } else {\n        throw new Error(`Expected ${JSON.stringify(key)} in mangle cache to map to either a string or false`);\n      }\n    }\n  }\n  return validated;\n}\nfunction pushLogFlags(flags, options, keys, isTTY, logLevelDefault) {\n  let color = getFlag(options, keys, \"color\", mustBeBoolean);\n  let logLevel = getFlag(options, keys, \"logLevel\", mustBeString);\n  let logLimit = getFlag(options, keys, \"logLimit\", mustBeInteger);\n  if (color !== void 0)\n    flags.push(`--color=${color}`);\n  else if (isTTY)\n    flags.push(`--color=true`);\n  flags.push(`--log-level=${logLevel || logLevelDefault}`);\n  flags.push(`--log-limit=${logLimit || 0}`);\n}\nfunction pushCommonFlags(flags, options, keys) {\n  let legalComments = getFlag(options, keys, \"legalComments\", mustBeString);\n  let sourceRoot = getFlag(options, keys, \"sourceRoot\", mustBeString);\n  let sourcesContent = getFlag(options, keys, \"sourcesContent\", mustBeBoolean);\n  let target = getFlag(options, keys, \"target\", mustBeStringOrArray);\n  let format = getFlag(options, keys, \"format\", mustBeString);\n  let globalName = getFlag(options, keys, \"globalName\", mustBeString);\n  let mangleProps = getFlag(options, keys, \"mangleProps\", mustBeRegExp);\n  let reserveProps = getFlag(options, keys, \"reserveProps\", mustBeRegExp);\n  let mangleQuoted = getFlag(options, keys, \"mangleQuoted\", mustBeBoolean);\n  let minify = getFlag(options, keys, \"minify\", mustBeBoolean);\n  let minifySyntax = getFlag(options, keys, \"minifySyntax\", mustBeBoolean);\n  let minifyWhitespace = getFlag(options, keys, \"minifyWhitespace\", mustBeBoolean);\n  let minifyIdentifiers = getFlag(options, keys, \"minifyIdentifiers\", mustBeBoolean);\n  let drop = getFlag(options, keys, \"drop\", mustBeArray);\n  let charset = getFlag(options, keys, \"charset\", mustBeString);\n  let treeShaking = getFlag(options, keys, \"treeShaking\", mustBeBoolean);\n  let ignoreAnnotations = getFlag(options, keys, \"ignoreAnnotations\", mustBeBoolean);\n  let jsx = getFlag(options, keys, \"jsx\", mustBeString);\n  let jsxFactory = getFlag(options, keys, \"jsxFactory\", mustBeString);\n  let jsxFragment = getFlag(options, keys, \"jsxFragment\", mustBeString);\n  let jsxImportSource = getFlag(options, keys, \"jsxImportSource\", mustBeString);\n  let jsxDev = getFlag(options, keys, \"jsxDev\", mustBeBoolean);\n  let define = getFlag(options, keys, \"define\", mustBeObject);\n  let logOverride = getFlag(options, keys, \"logOverride\", mustBeObject);\n  let supported = getFlag(options, keys, \"supported\", mustBeObject);\n  let pure = getFlag(options, keys, \"pure\", mustBeArray);\n  let keepNames = getFlag(options, keys, \"keepNames\", mustBeBoolean);\n  let platform = getFlag(options, keys, \"platform\", mustBeString);\n  if (legalComments)\n    flags.push(`--legal-comments=${legalComments}`);\n  if (sourceRoot !== void 0)\n    flags.push(`--source-root=${sourceRoot}`);\n  if (sourcesContent !== void 0)\n    flags.push(`--sources-content=${sourcesContent}`);\n  if (target) {\n    if (Array.isArray(target))\n      flags.push(`--target=${Array.from(target).map(validateTarget).join(\",\")}`);\n    else\n      flags.push(`--target=${validateTarget(target)}`);\n  }\n  if (format)\n    flags.push(`--format=${format}`);\n  if (globalName)\n    flags.push(`--global-name=${globalName}`);\n  if (platform)\n    flags.push(`--platform=${platform}`);\n  if (minify)\n    flags.push(\"--minify\");\n  if (minifySyntax)\n    flags.push(\"--minify-syntax\");\n  if (minifyWhitespace)\n    flags.push(\"--minify-whitespace\");\n  if (minifyIdentifiers)\n    flags.push(\"--minify-identifiers\");\n  if (charset)\n    flags.push(`--charset=${charset}`);\n  if (treeShaking !== void 0)\n    flags.push(`--tree-shaking=${treeShaking}`);\n  if (ignoreAnnotations)\n    flags.push(`--ignore-annotations`);\n  if (drop)\n    for (let what of drop)\n      flags.push(`--drop:${what}`);\n  if (mangleProps)\n    flags.push(`--mangle-props=${mangleProps.source}`);\n  if (reserveProps)\n    flags.push(`--reserve-props=${reserveProps.source}`);\n  if (mangleQuoted !== void 0)\n    flags.push(`--mangle-quoted=${mangleQuoted}`);\n  if (jsx)\n    flags.push(`--jsx=${jsx}`);\n  if (jsxFactory)\n    flags.push(`--jsx-factory=${jsxFactory}`);\n  if (jsxFragment)\n    flags.push(`--jsx-fragment=${jsxFragment}`);\n  if (jsxImportSource)\n    flags.push(`--jsx-import-source=${jsxImportSource}`);\n  if (jsxDev)\n    flags.push(`--jsx-dev`);\n  if (define) {\n    for (let key in define) {\n      if (key.indexOf(\"=\") >= 0)\n        throw new Error(`Invalid define: ${key}`);\n      flags.push(`--define:${key}=${define[key]}`);\n    }\n  }\n  if (logOverride) {\n    for (let key in logOverride) {\n      if (key.indexOf(\"=\") >= 0)\n        throw new Error(`Invalid log override: ${key}`);\n      flags.push(`--log-override:${key}=${logOverride[key]}`);\n    }\n  }\n  if (supported) {\n    for (let key in supported) {\n      if (key.indexOf(\"=\") >= 0)\n        throw new Error(`Invalid supported: ${key}`);\n      flags.push(`--supported:${key}=${supported[key]}`);\n    }\n  }\n  if (pure)\n    for (let fn of pure)\n      flags.push(`--pure:${fn}`);\n  if (keepNames)\n    flags.push(`--keep-names`);\n}\nfunction flagsForBuildOptions(callName, options, isTTY, logLevelDefault, writeDefault) {\n  var _a;\n  let flags = [];\n  let entries = [];\n  let keys = /* @__PURE__ */ Object.create(null);\n  let stdinContents = null;\n  let stdinResolveDir = null;\n  let watchMode = null;\n  pushLogFlags(flags, options, keys, isTTY, logLevelDefault);\n  pushCommonFlags(flags, options, keys);\n  let sourcemap = getFlag(options, keys, \"sourcemap\", mustBeStringOrBoolean);\n  let bundle = getFlag(options, keys, \"bundle\", mustBeBoolean);\n  let watch = getFlag(options, keys, \"watch\", mustBeBooleanOrObject);\n  let splitting = getFlag(options, keys, \"splitting\", mustBeBoolean);\n  let preserveSymlinks = getFlag(options, keys, \"preserveSymlinks\", mustBeBoolean);\n  let metafile = getFlag(options, keys, \"metafile\", mustBeBoolean);\n  let outfile = getFlag(options, keys, \"outfile\", mustBeString);\n  let outdir = getFlag(options, keys, \"outdir\", mustBeString);\n  let outbase = getFlag(options, keys, \"outbase\", mustBeString);\n  let tsconfig = getFlag(options, keys, \"tsconfig\", mustBeString);\n  let resolveExtensions = getFlag(options, keys, \"resolveExtensions\", mustBeArray);\n  let nodePathsInput = getFlag(options, keys, \"nodePaths\", mustBeArray);\n  let mainFields = getFlag(options, keys, \"mainFields\", mustBeArray);\n  let conditions = getFlag(options, keys, \"conditions\", mustBeArray);\n  let external = getFlag(options, keys, \"external\", mustBeArray);\n  let loader = getFlag(options, keys, \"loader\", mustBeObject);\n  let outExtension = getFlag(options, keys, \"outExtension\", mustBeObject);\n  let publicPath = getFlag(options, keys, \"publicPath\", mustBeString);\n  let entryNames = getFlag(options, keys, \"entryNames\", mustBeString);\n  let chunkNames = getFlag(options, keys, \"chunkNames\", mustBeString);\n  let assetNames = getFlag(options, keys, \"assetNames\", mustBeString);\n  let inject = getFlag(options, keys, \"inject\", mustBeArray);\n  let banner = getFlag(options, keys, \"banner\", mustBeObject);\n  let footer = getFlag(options, keys, \"footer\", mustBeObject);\n  let entryPoints = getFlag(options, keys, \"entryPoints\", mustBeArrayOrRecord);\n  let absWorkingDir = getFlag(options, keys, \"absWorkingDir\", mustBeString);\n  let stdin = getFlag(options, keys, \"stdin\", mustBeObject);\n  let write = (_a = getFlag(options, keys, \"write\", mustBeBoolean)) != null ? _a : writeDefault;\n  let allowOverwrite = getFlag(options, keys, \"allowOverwrite\", mustBeBoolean);\n  let incremental = getFlag(options, keys, \"incremental\", mustBeBoolean) === true;\n  let mangleCache = getFlag(options, keys, \"mangleCache\", mustBeObject);\n  keys.plugins = true;\n  checkForInvalidFlags(options, keys, `in ${callName}() call`);\n  if (sourcemap)\n    flags.push(`--sourcemap${sourcemap === true ? \"\" : `=${sourcemap}`}`);\n  if (bundle)\n    flags.push(\"--bundle\");\n  if (allowOverwrite)\n    flags.push(\"--allow-overwrite\");\n  if (watch) {\n    flags.push(\"--watch\");\n    if (typeof watch === \"boolean\") {\n      watchMode = {};\n    } else {\n      let watchKeys = /* @__PURE__ */ Object.create(null);\n      let onRebuild = getFlag(watch, watchKeys, \"onRebuild\", mustBeFunction);\n      checkForInvalidFlags(watch, watchKeys, `on \"watch\" in ${callName}() call`);\n      watchMode = { onRebuild };\n    }\n  }\n  if (splitting)\n    flags.push(\"--splitting\");\n  if (preserveSymlinks)\n    flags.push(\"--preserve-symlinks\");\n  if (metafile)\n    flags.push(`--metafile`);\n  if (outfile)\n    flags.push(`--outfile=${outfile}`);\n  if (outdir)\n    flags.push(`--outdir=${outdir}`);\n  if (outbase)\n    flags.push(`--outbase=${outbase}`);\n  if (tsconfig)\n    flags.push(`--tsconfig=${tsconfig}`);\n  if (resolveExtensions) {\n    let values = [];\n    for (let value of resolveExtensions) {\n      value += \"\";\n      if (value.indexOf(\",\") >= 0)\n        throw new Error(`Invalid resolve extension: ${value}`);\n      values.push(value);\n    }\n    flags.push(`--resolve-extensions=${values.join(\",\")}`);\n  }\n  if (publicPath)\n    flags.push(`--public-path=${publicPath}`);\n  if (entryNames)\n    flags.push(`--entry-names=${entryNames}`);\n  if (chunkNames)\n    flags.push(`--chunk-names=${chunkNames}`);\n  if (assetNames)\n    flags.push(`--asset-names=${assetNames}`);\n  if (mainFields) {\n    let values = [];\n    for (let value of mainFields) {\n      value += \"\";\n      if (value.indexOf(\",\") >= 0)\n        throw new Error(`Invalid main field: ${value}`);\n      values.push(value);\n    }\n    flags.push(`--main-fields=${values.join(\",\")}`);\n  }\n  if (conditions) {\n    let values = [];\n    for (let value of conditions) {\n      value += \"\";\n      if (value.indexOf(\",\") >= 0)\n        throw new Error(`Invalid condition: ${value}`);\n      values.push(value);\n    }\n    flags.push(`--conditions=${values.join(\",\")}`);\n  }\n  if (external)\n    for (let name of external)\n      flags.push(`--external:${name}`);\n  if (banner) {\n    for (let type in banner) {\n      if (type.indexOf(\"=\") >= 0)\n        throw new Error(`Invalid banner file type: ${type}`);\n      flags.push(`--banner:${type}=${banner[type]}`);\n    }\n  }\n  if (footer) {\n    for (let type in footer) {\n      if (type.indexOf(\"=\") >= 0)\n        throw new Error(`Invalid footer file type: ${type}`);\n      flags.push(`--footer:${type}=${footer[type]}`);\n    }\n  }\n  if (inject)\n    for (let path of inject)\n      flags.push(`--inject:${path}`);\n  if (loader) {\n    for (let ext in loader) {\n      if (ext.indexOf(\"=\") >= 0)\n        throw new Error(`Invalid loader extension: ${ext}`);\n      flags.push(`--loader:${ext}=${loader[ext]}`);\n    }\n  }\n  if (outExtension) {\n    for (let ext in outExtension) {\n      if (ext.indexOf(\"=\") >= 0)\n        throw new Error(`Invalid out extension: ${ext}`);\n      flags.push(`--out-extension:${ext}=${outExtension[ext]}`);\n    }\n  }\n  if (entryPoints) {\n    if (Array.isArray(entryPoints)) {\n      for (let entryPoint of entryPoints) {\n        entries.push([\"\", entryPoint + \"\"]);\n      }\n    } else {\n      for (let [key, value] of Object.entries(entryPoints)) {\n        entries.push([key + \"\", value + \"\"]);\n      }\n    }\n  }\n  if (stdin) {\n    let stdinKeys = /* @__PURE__ */ Object.create(null);\n    let contents = getFlag(stdin, stdinKeys, \"contents\", mustBeStringOrUint8Array);\n    let resolveDir = getFlag(stdin, stdinKeys, \"resolveDir\", mustBeString);\n    let sourcefile = getFlag(stdin, stdinKeys, \"sourcefile\", mustBeString);\n    let loader2 = getFlag(stdin, stdinKeys, \"loader\", mustBeString);\n    checkForInvalidFlags(stdin, stdinKeys, 'in \"stdin\" object');\n    if (sourcefile)\n      flags.push(`--sourcefile=${sourcefile}`);\n    if (loader2)\n      flags.push(`--loader=${loader2}`);\n    if (resolveDir)\n      stdinResolveDir = resolveDir + \"\";\n    if (typeof contents === \"string\")\n      stdinContents = encodeUTF8(contents);\n    else if (contents instanceof Uint8Array)\n      stdinContents = contents;\n  }\n  let nodePaths = [];\n  if (nodePathsInput) {\n    for (let value of nodePathsInput) {\n      value += \"\";\n      nodePaths.push(value);\n    }\n  }\n  return {\n    entries,\n    flags,\n    write,\n    stdinContents,\n    stdinResolveDir,\n    absWorkingDir,\n    incremental,\n    nodePaths,\n    watch: watchMode,\n    mangleCache: validateMangleCache(mangleCache)\n  };\n}\nfunction flagsForTransformOptions(callName, options, isTTY, logLevelDefault) {\n  let flags = [];\n  let keys = /* @__PURE__ */ Object.create(null);\n  pushLogFlags(flags, options, keys, isTTY, logLevelDefault);\n  pushCommonFlags(flags, options, keys);\n  let sourcemap = getFlag(options, keys, \"sourcemap\", mustBeStringOrBoolean);\n  let tsconfigRaw = getFlag(options, keys, \"tsconfigRaw\", mustBeStringOrObject);\n  let sourcefile = getFlag(options, keys, \"sourcefile\", mustBeString);\n  let loader = getFlag(options, keys, \"loader\", mustBeString);\n  let banner = getFlag(options, keys, \"banner\", mustBeString);\n  let footer = getFlag(options, keys, \"footer\", mustBeString);\n  let mangleCache = getFlag(options, keys, \"mangleCache\", mustBeObject);\n  checkForInvalidFlags(options, keys, `in ${callName}() call`);\n  if (sourcemap)\n    flags.push(`--sourcemap=${sourcemap === true ? \"external\" : sourcemap}`);\n  if (tsconfigRaw)\n    flags.push(`--tsconfig-raw=${typeof tsconfigRaw === \"string\" ? tsconfigRaw : JSON.stringify(tsconfigRaw)}`);\n  if (sourcefile)\n    flags.push(`--sourcefile=${sourcefile}`);\n  if (loader)\n    flags.push(`--loader=${loader}`);\n  if (banner)\n    flags.push(`--banner=${banner}`);\n  if (footer)\n    flags.push(`--footer=${footer}`);\n  return {\n    flags,\n    mangleCache: validateMangleCache(mangleCache)\n  };\n}\nfunction createChannel(streamIn) {\n  let responseCallbacks = /* @__PURE__ */ new Map();\n  let pluginCallbacks = /* @__PURE__ */ new Map();\n  let watchCallbacks = /* @__PURE__ */ new Map();\n  let serveCallbacks = /* @__PURE__ */ new Map();\n  let closeData = null;\n  let nextRequestID = 0;\n  let nextBuildKey = 0;\n  let stdout = new Uint8Array(16 * 1024);\n  let stdoutUsed = 0;\n  let readFromStdout = (chunk) => {\n    let limit = stdoutUsed + chunk.length;\n    if (limit > stdout.length) {\n      let swap = new Uint8Array(limit * 2);\n      swap.set(stdout);\n      stdout = swap;\n    }\n    stdout.set(chunk, stdoutUsed);\n    stdoutUsed += chunk.length;\n    let offset = 0;\n    while (offset + 4 <= stdoutUsed) {\n      let length = readUInt32LE(stdout, offset);\n      if (offset + 4 + length > stdoutUsed) {\n        break;\n      }\n      offset += 4;\n      handleIncomingPacket(stdout.subarray(offset, offset + length));\n      offset += length;\n    }\n    if (offset > 0) {\n      stdout.copyWithin(0, offset, stdoutUsed);\n      stdoutUsed -= offset;\n    }\n  };\n  let afterClose = (error) => {\n    closeData = { reason: error ? \": \" + (error.message || error) : \"\" };\n    const text = \"The service was stopped\" + closeData.reason;\n    for (let callback of responseCallbacks.values()) {\n      callback(text, null);\n    }\n    responseCallbacks.clear();\n    for (let callbacks of serveCallbacks.values()) {\n      callbacks.onWait(text);\n    }\n    serveCallbacks.clear();\n    for (let callback of watchCallbacks.values()) {\n      try {\n        callback(new Error(text), null);\n      } catch (e) {\n        console.error(e);\n      }\n    }\n    watchCallbacks.clear();\n  };\n  let sendRequest = (refs, value, callback) => {\n    if (closeData)\n      return callback(\"The service is no longer running\" + closeData.reason, null);\n    let id = nextRequestID++;\n    responseCallbacks.set(id, (error, response) => {\n      try {\n        callback(error, response);\n      } finally {\n        if (refs)\n          refs.unref();\n      }\n    });\n    if (refs)\n      refs.ref();\n    streamIn.writeToStdin(encodePacket({ id, isRequest: true, value }));\n  };\n  let sendResponse = (id, value) => {\n    if (closeData)\n      throw new Error(\"The service is no longer running\" + closeData.reason);\n    streamIn.writeToStdin(encodePacket({ id, isRequest: false, value }));\n  };\n  let handleRequest = (id, request) => __async(this, null, function* () {\n    try {\n      switch (request.command) {\n        case \"ping\": {\n          sendResponse(id, {});\n          break;\n        }\n        case \"on-start\": {\n          let callback = pluginCallbacks.get(request.key);\n          if (!callback)\n            sendResponse(id, {});\n          else\n            sendResponse(id, yield callback(request));\n          break;\n        }\n        case \"on-resolve\": {\n          let callback = pluginCallbacks.get(request.key);\n          if (!callback)\n            sendResponse(id, {});\n          else\n            sendResponse(id, yield callback(request));\n          break;\n        }\n        case \"on-load\": {\n          let callback = pluginCallbacks.get(request.key);\n          if (!callback)\n            sendResponse(id, {});\n          else\n            sendResponse(id, yield callback(request));\n          break;\n        }\n        case \"serve-request\": {\n          let callbacks = serveCallbacks.get(request.key);\n          if (callbacks && callbacks.onRequest)\n            callbacks.onRequest(request.args);\n          sendResponse(id, {});\n          break;\n        }\n        case \"serve-wait\": {\n          let callbacks = serveCallbacks.get(request.key);\n          if (callbacks)\n            callbacks.onWait(request.error);\n          sendResponse(id, {});\n          break;\n        }\n        case \"watch-rebuild\": {\n          let callback = watchCallbacks.get(request.key);\n          try {\n            if (callback)\n              callback(null, request.args);\n          } catch (err) {\n            console.error(err);\n          }\n          sendResponse(id, {});\n          break;\n        }\n        default:\n          throw new Error(`Invalid command: ` + request.command);\n      }\n    } catch (e) {\n      sendResponse(id, { errors: [extractErrorMessageV8(e, streamIn, null, void 0, \"\")] });\n    }\n  });\n  let isFirstPacket = true;\n  let handleIncomingPacket = (bytes) => {\n    if (isFirstPacket) {\n      isFirstPacket = false;\n      let binaryVersion = String.fromCharCode(...bytes);\n      if (binaryVersion !== \"0.15.5\") {\n        throw new Error(`Cannot start service: Host version \"${\"0.15.5\"}\" does not match binary version ${JSON.stringify(binaryVersion)}`);\n      }\n      return;\n    }\n    let packet = decodePacket(bytes);\n    if (packet.isRequest) {\n      handleRequest(packet.id, packet.value);\n    } else {\n      let callback = responseCallbacks.get(packet.id);\n      responseCallbacks.delete(packet.id);\n      if (packet.value.error)\n        callback(packet.value.error, {});\n      else\n        callback(null, packet.value);\n    }\n  };\n  let handlePlugins = (initialOptions, plugins, buildKey, stash, refs) => __async(this, null, function* () {\n    let onStartCallbacks = [];\n    let onEndCallbacks = [];\n    let onResolveCallbacks = {};\n    let onLoadCallbacks = {};\n    let nextCallbackID = 0;\n    let i = 0;\n    let requestPlugins = [];\n    let isSetupDone = false;\n    plugins = [...plugins];\n    for (let item of plugins) {\n      let keys = {};\n      if (typeof item !== \"object\")\n        throw new Error(`Plugin at index ${i} must be an object`);\n      const name = getFlag(item, keys, \"name\", mustBeString);\n      if (typeof name !== \"string\" || name === \"\")\n        throw new Error(`Plugin at index ${i} is missing a name`);\n      try {\n        let setup = getFlag(item, keys, \"setup\", mustBeFunction);\n        if (typeof setup !== \"function\")\n          throw new Error(`Plugin is missing a setup function`);\n        checkForInvalidFlags(item, keys, `on plugin ${JSON.stringify(name)}`);\n        let plugin = {\n          name,\n          onResolve: [],\n          onLoad: []\n        };\n        i++;\n        let resolve = (path, options = {}) => {\n          if (!isSetupDone)\n            throw new Error('Cannot call \"resolve\" before plugin setup has completed');\n          if (typeof path !== \"string\")\n            throw new Error(`The path to resolve must be a string`);\n          let keys2 = /* @__PURE__ */ Object.create(null);\n          let pluginName = getFlag(options, keys2, \"pluginName\", mustBeString);\n          let importer = getFlag(options, keys2, \"importer\", mustBeString);\n          let namespace = getFlag(options, keys2, \"namespace\", mustBeString);\n          let resolveDir = getFlag(options, keys2, \"resolveDir\", mustBeString);\n          let kind = getFlag(options, keys2, \"kind\", mustBeString);\n          let pluginData = getFlag(options, keys2, \"pluginData\", canBeAnything);\n          checkForInvalidFlags(options, keys2, \"in resolve() call\");\n          return new Promise((resolve2, reject) => {\n            const request = {\n              command: \"resolve\",\n              path,\n              key: buildKey,\n              pluginName: name\n            };\n            if (pluginName != null)\n              request.pluginName = pluginName;\n            if (importer != null)\n              request.importer = importer;\n            if (namespace != null)\n              request.namespace = namespace;\n            if (resolveDir != null)\n              request.resolveDir = resolveDir;\n            if (kind != null)\n              request.kind = kind;\n            if (pluginData != null)\n              request.pluginData = stash.store(pluginData);\n            sendRequest(refs, request, (error, response) => {\n              if (error !== null)\n                reject(new Error(error));\n              else\n                resolve2({\n                  errors: replaceDetailsInMessages(response.errors, stash),\n                  warnings: replaceDetailsInMessages(response.warnings, stash),\n                  path: response.path,\n                  external: response.external,\n                  sideEffects: response.sideEffects,\n                  namespace: response.namespace,\n                  suffix: response.suffix,\n                  pluginData: stash.load(response.pluginData)\n                });\n            });\n          });\n        };\n        let promise = setup({\n          initialOptions,\n          resolve,\n          onStart(callback2) {\n            let registeredText = `This error came from the \"onStart\" callback registered here:`;\n            let registeredNote = extractCallerV8(new Error(registeredText), streamIn, \"onStart\");\n            onStartCallbacks.push({ name, callback: callback2, note: registeredNote });\n          },\n          onEnd(callback2) {\n            let registeredText = `This error came from the \"onEnd\" callback registered here:`;\n            let registeredNote = extractCallerV8(new Error(registeredText), streamIn, \"onEnd\");\n            onEndCallbacks.push({ name, callback: callback2, note: registeredNote });\n          },\n          onResolve(options, callback2) {\n            let registeredText = `This error came from the \"onResolve\" callback registered here:`;\n            let registeredNote = extractCallerV8(new Error(registeredText), streamIn, \"onResolve\");\n            let keys2 = {};\n            let filter = getFlag(options, keys2, \"filter\", mustBeRegExp);\n            let namespace = getFlag(options, keys2, \"namespace\", mustBeString);\n            checkForInvalidFlags(options, keys2, `in onResolve() call for plugin ${JSON.stringify(name)}`);\n            if (filter == null)\n              throw new Error(`onResolve() call is missing a filter`);\n            let id = nextCallbackID++;\n            onResolveCallbacks[id] = { name, callback: callback2, note: registeredNote };\n            plugin.onResolve.push({ id, filter: filter.source, namespace: namespace || \"\" });\n          },\n          onLoad(options, callback2) {\n            let registeredText = `This error came from the \"onLoad\" callback registered here:`;\n            let registeredNote = extractCallerV8(new Error(registeredText), streamIn, \"onLoad\");\n            let keys2 = {};\n            let filter = getFlag(options, keys2, \"filter\", mustBeRegExp);\n            let namespace = getFlag(options, keys2, \"namespace\", mustBeString);\n            checkForInvalidFlags(options, keys2, `in onLoad() call for plugin ${JSON.stringify(name)}`);\n            if (filter == null)\n              throw new Error(`onLoad() call is missing a filter`);\n            let id = nextCallbackID++;\n            onLoadCallbacks[id] = { name, callback: callback2, note: registeredNote };\n            plugin.onLoad.push({ id, filter: filter.source, namespace: namespace || \"\" });\n          },\n          esbuild: streamIn.esbuild\n        });\n        if (promise)\n          yield promise;\n        requestPlugins.push(plugin);\n      } catch (e) {\n        return { ok: false, error: e, pluginName: name };\n      }\n    }\n    const callback = (request) => __async(this, null, function* () {\n      switch (request.command) {\n        case \"on-start\": {\n          let response = { errors: [], warnings: [] };\n          yield Promise.all(onStartCallbacks.map((_0) => __async(this, [_0], function* ({ name, callback: callback2, note }) {\n            try {\n              let result = yield callback2();\n              if (result != null) {\n                if (typeof result !== \"object\")\n                  throw new Error(`Expected onStart() callback in plugin ${JSON.stringify(name)} to return an object`);\n                let keys = {};\n                let errors = getFlag(result, keys, \"errors\", mustBeArray);\n                let warnings = getFlag(result, keys, \"warnings\", mustBeArray);\n                checkForInvalidFlags(result, keys, `from onStart() callback in plugin ${JSON.stringify(name)}`);\n                if (errors != null)\n                  response.errors.push(...sanitizeMessages(errors, \"errors\", stash, name));\n                if (warnings != null)\n                  response.warnings.push(...sanitizeMessages(warnings, \"warnings\", stash, name));\n              }\n            } catch (e) {\n              response.errors.push(extractErrorMessageV8(e, streamIn, stash, note && note(), name));\n            }\n          })));\n          return response;\n        }\n        case \"on-resolve\": {\n          let response = {}, name = \"\", callback2, note;\n          for (let id of request.ids) {\n            try {\n              ({ name, callback: callback2, note } = onResolveCallbacks[id]);\n              let result = yield callback2({\n                path: request.path,\n                importer: request.importer,\n                namespace: request.namespace,\n                resolveDir: request.resolveDir,\n                kind: request.kind,\n                pluginData: stash.load(request.pluginData)\n              });\n              if (result != null) {\n                if (typeof result !== \"object\")\n                  throw new Error(`Expected onResolve() callback in plugin ${JSON.stringify(name)} to return an object`);\n                let keys = {};\n                let pluginName = getFlag(result, keys, \"pluginName\", mustBeString);\n                let path = getFlag(result, keys, \"path\", mustBeString);\n                let namespace = getFlag(result, keys, \"namespace\", mustBeString);\n                let suffix = getFlag(result, keys, \"suffix\", mustBeString);\n                let external = getFlag(result, keys, \"external\", mustBeBoolean);\n                let sideEffects = getFlag(result, keys, \"sideEffects\", mustBeBoolean);\n                let pluginData = getFlag(result, keys, \"pluginData\", canBeAnything);\n                let errors = getFlag(result, keys, \"errors\", mustBeArray);\n                let warnings = getFlag(result, keys, \"warnings\", mustBeArray);\n                let watchFiles = getFlag(result, keys, \"watchFiles\", mustBeArray);\n                let watchDirs = getFlag(result, keys, \"watchDirs\", mustBeArray);\n                checkForInvalidFlags(result, keys, `from onResolve() callback in plugin ${JSON.stringify(name)}`);\n                response.id = id;\n                if (pluginName != null)\n                  response.pluginName = pluginName;\n                if (path != null)\n                  response.path = path;\n                if (namespace != null)\n                  response.namespace = namespace;\n                if (suffix != null)\n                  response.suffix = suffix;\n                if (external != null)\n                  response.external = external;\n                if (sideEffects != null)\n                  response.sideEffects = sideEffects;\n                if (pluginData != null)\n                  response.pluginData = stash.store(pluginData);\n                if (errors != null)\n                  response.errors = sanitizeMessages(errors, \"errors\", stash, name);\n                if (warnings != null)\n                  response.warnings = sanitizeMessages(warnings, \"warnings\", stash, name);\n                if (watchFiles != null)\n                  response.watchFiles = sanitizeStringArray(watchFiles, \"watchFiles\");\n                if (watchDirs != null)\n                  response.watchDirs = sanitizeStringArray(watchDirs, \"watchDirs\");\n                break;\n              }\n            } catch (e) {\n              return { id, errors: [extractErrorMessageV8(e, streamIn, stash, note && note(), name)] };\n            }\n          }\n          return response;\n        }\n        case \"on-load\": {\n          let response = {}, name = \"\", callback2, note;\n          for (let id of request.ids) {\n            try {\n              ({ name, callback: callback2, note } = onLoadCallbacks[id]);\n              let result = yield callback2({\n                path: request.path,\n                namespace: request.namespace,\n                suffix: request.suffix,\n                pluginData: stash.load(request.pluginData)\n              });\n              if (result != null) {\n                if (typeof result !== \"object\")\n                  throw new Error(`Expected onLoad() callback in plugin ${JSON.stringify(name)} to return an object`);\n                let keys = {};\n                let pluginName = getFlag(result, keys, \"pluginName\", mustBeString);\n                let contents = getFlag(result, keys, \"contents\", mustBeStringOrUint8Array);\n                let resolveDir = getFlag(result, keys, \"resolveDir\", mustBeString);\n                let pluginData = getFlag(result, keys, \"pluginData\", canBeAnything);\n                let loader = getFlag(result, keys, \"loader\", mustBeString);\n                let errors = getFlag(result, keys, \"errors\", mustBeArray);\n                let warnings = getFlag(result, keys, \"warnings\", mustBeArray);\n                let watchFiles = getFlag(result, keys, \"watchFiles\", mustBeArray);\n                let watchDirs = getFlag(result, keys, \"watchDirs\", mustBeArray);\n                checkForInvalidFlags(result, keys, `from onLoad() callback in plugin ${JSON.stringify(name)}`);\n                response.id = id;\n                if (pluginName != null)\n                  response.pluginName = pluginName;\n                if (contents instanceof Uint8Array)\n                  response.contents = contents;\n                else if (contents != null)\n                  response.contents = encodeUTF8(contents);\n                if (resolveDir != null)\n                  response.resolveDir = resolveDir;\n                if (pluginData != null)\n                  response.pluginData = stash.store(pluginData);\n                if (loader != null)\n                  response.loader = loader;\n                if (errors != null)\n                  response.errors = sanitizeMessages(errors, \"errors\", stash, name);\n                if (warnings != null)\n                  response.warnings = sanitizeMessages(warnings, \"warnings\", stash, name);\n                if (watchFiles != null)\n                  response.watchFiles = sanitizeStringArray(watchFiles, \"watchFiles\");\n                if (watchDirs != null)\n                  response.watchDirs = sanitizeStringArray(watchDirs, \"watchDirs\");\n                break;\n              }\n            } catch (e) {\n              return { id, errors: [extractErrorMessageV8(e, streamIn, stash, note && note(), name)] };\n            }\n          }\n          return response;\n        }\n        default:\n          throw new Error(`Invalid command: ` + request.command);\n      }\n    });\n    let runOnEndCallbacks = (result, logPluginError, done) => done();\n    if (onEndCallbacks.length > 0) {\n      runOnEndCallbacks = (result, logPluginError, done) => {\n        (() => __async(this, null, function* () {\n          for (const { name, callback: callback2, note } of onEndCallbacks) {\n            try {\n              yield callback2(result);\n            } catch (e) {\n              result.errors.push(yield new Promise((resolve) => logPluginError(e, name, note && note(), resolve)));\n            }\n          }\n        }))().then(done);\n      };\n    }\n    isSetupDone = true;\n    let refCount = 0;\n    return {\n      ok: true,\n      requestPlugins,\n      runOnEndCallbacks,\n      pluginRefs: {\n        ref() {\n          if (++refCount === 1)\n            pluginCallbacks.set(buildKey, callback);\n        },\n        unref() {\n          if (--refCount === 0)\n            pluginCallbacks.delete(buildKey);\n        }\n      }\n    };\n  });\n  let buildServeData = (refs, options, request, key) => {\n    let keys = {};\n    let port = getFlag(options, keys, \"port\", mustBeInteger);\n    let host = getFlag(options, keys, \"host\", mustBeString);\n    let servedir = getFlag(options, keys, \"servedir\", mustBeString);\n    let onRequest = getFlag(options, keys, \"onRequest\", mustBeFunction);\n    let onWait;\n    let wait = new Promise((resolve, reject) => {\n      onWait = (error) => {\n        serveCallbacks.delete(key);\n        if (error !== null)\n          reject(new Error(error));\n        else\n          resolve();\n      };\n    });\n    request.serve = {};\n    checkForInvalidFlags(options, keys, `in serve() call`);\n    if (port !== void 0)\n      request.serve.port = port;\n    if (host !== void 0)\n      request.serve.host = host;\n    if (servedir !== void 0)\n      request.serve.servedir = servedir;\n    serveCallbacks.set(key, {\n      onRequest,\n      onWait\n    });\n    return {\n      wait,\n      stop() {\n        sendRequest(refs, { command: \"serve-stop\", key }, () => {\n        });\n      }\n    };\n  };\n  const buildLogLevelDefault = \"warning\";\n  const transformLogLevelDefault = \"silent\";\n  let buildOrServe = (args) => {\n    let key = nextBuildKey++;\n    const details = createObjectStash();\n    let plugins;\n    let { refs, options, isTTY, callback } = args;\n    if (typeof options === \"object\") {\n      let value = options.plugins;\n      if (value !== void 0) {\n        if (!Array.isArray(value))\n          throw new Error(`\"plugins\" must be an array`);\n        plugins = value;\n      }\n    }\n    let logPluginError = (e, pluginName, note, done) => {\n      let flags = [];\n      try {\n        pushLogFlags(flags, options, {}, isTTY, buildLogLevelDefault);\n      } catch (e2) {\n      }\n      const message = extractErrorMessageV8(e, streamIn, details, note, pluginName);\n      sendRequest(refs, { command: \"error\", flags, error: message }, () => {\n        message.detail = details.load(message.detail);\n        done(message);\n      });\n    };\n    let handleError = (e, pluginName) => {\n      logPluginError(e, pluginName, void 0, (error) => {\n        callback(failureErrorWithLog(\"Build failed\", [error], []), null);\n      });\n    };\n    if (plugins && plugins.length > 0) {\n      if (streamIn.isSync)\n        return handleError(new Error(\"Cannot use plugins in synchronous API calls\"), \"\");\n      handlePlugins(options, plugins, key, details, refs).then(\n        (result) => {\n          if (!result.ok) {\n            handleError(result.error, result.pluginName);\n          } else {\n            try {\n              buildOrServeContinue(__spreadProps(__spreadValues({}, args), {\n                key,\n                details,\n                logPluginError,\n                requestPlugins: result.requestPlugins,\n                runOnEndCallbacks: result.runOnEndCallbacks,\n                pluginRefs: result.pluginRefs\n              }));\n            } catch (e) {\n              handleError(e, \"\");\n            }\n          }\n        },\n        (e) => handleError(e, \"\")\n      );\n    } else {\n      try {\n        buildOrServeContinue(__spreadProps(__spreadValues({}, args), {\n          key,\n          details,\n          logPluginError,\n          requestPlugins: null,\n          runOnEndCallbacks: (result, logPluginError2, done) => done(),\n          pluginRefs: null\n        }));\n      } catch (e) {\n        handleError(e, \"\");\n      }\n    }\n  };\n  let buildOrServeContinue = ({\n    callName,\n    refs: callerRefs,\n    serveOptions,\n    options,\n    isTTY,\n    defaultWD,\n    callback,\n    key,\n    details,\n    logPluginError,\n    requestPlugins,\n    runOnEndCallbacks,\n    pluginRefs\n  }) => {\n    const refs = {\n      ref() {\n        if (pluginRefs)\n          pluginRefs.ref();\n        if (callerRefs)\n          callerRefs.ref();\n      },\n      unref() {\n        if (pluginRefs)\n          pluginRefs.unref();\n        if (callerRefs)\n          callerRefs.unref();\n      }\n    };\n    let writeDefault = !streamIn.isWriteUnavailable;\n    let {\n      entries,\n      flags,\n      write,\n      stdinContents,\n      stdinResolveDir,\n      absWorkingDir,\n      incremental,\n      nodePaths,\n      watch,\n      mangleCache\n    } = flagsForBuildOptions(callName, options, isTTY, buildLogLevelDefault, writeDefault);\n    let request = {\n      command: \"build\",\n      key,\n      entries,\n      flags,\n      write,\n      stdinContents,\n      stdinResolveDir,\n      absWorkingDir: absWorkingDir || defaultWD,\n      incremental,\n      nodePaths\n    };\n    if (requestPlugins)\n      request.plugins = requestPlugins;\n    if (mangleCache)\n      request.mangleCache = mangleCache;\n    let serve2 = serveOptions && buildServeData(refs, serveOptions, request, key);\n    let rebuild;\n    let stop;\n    let copyResponseToResult = (response, result) => {\n      if (response.outputFiles)\n        result.outputFiles = response.outputFiles.map(convertOutputFiles);\n      if (response.metafile)\n        result.metafile = JSON.parse(response.metafile);\n      if (response.mangleCache)\n        result.mangleCache = response.mangleCache;\n      if (response.writeToStdout !== void 0)\n        console.log(decodeUTF8(response.writeToStdout).replace(/\\n$/, \"\"));\n    };\n    let buildResponseToResult = (response, callback2) => {\n      let result = {\n        errors: replaceDetailsInMessages(response.errors, details),\n        warnings: replaceDetailsInMessages(response.warnings, details)\n      };\n      copyResponseToResult(response, result);\n      runOnEndCallbacks(result, logPluginError, () => {\n        if (result.errors.length > 0) {\n          return callback2(failureErrorWithLog(\"Build failed\", result.errors, result.warnings), null);\n        }\n        if (response.rebuild) {\n          if (!rebuild) {\n            let isDisposed = false;\n            rebuild = () => new Promise((resolve, reject) => {\n              if (isDisposed || closeData)\n                throw new Error(\"Cannot rebuild\");\n              sendRequest(\n                refs,\n                { command: \"rebuild\", key },\n                (error2, response2) => {\n                  if (error2) {\n                    const message = { id: \"\", pluginName: \"\", text: error2, location: null, notes: [], detail: void 0 };\n                    return callback2(failureErrorWithLog(\"Build failed\", [message], []), null);\n                  }\n                  buildResponseToResult(response2, (error3, result3) => {\n                    if (error3)\n                      reject(error3);\n                    else\n                      resolve(result3);\n                  });\n                }\n              );\n            });\n            refs.ref();\n            rebuild.dispose = () => {\n              if (isDisposed)\n                return;\n              isDisposed = true;\n              sendRequest(refs, { command: \"rebuild-dispose\", key }, () => {\n              });\n              refs.unref();\n            };\n          }\n          result.rebuild = rebuild;\n        }\n        if (response.watch) {\n          if (!stop) {\n            let isStopped = false;\n            refs.ref();\n            stop = () => {\n              if (isStopped)\n                return;\n              isStopped = true;\n              watchCallbacks.delete(key);\n              sendRequest(refs, { command: \"watch-stop\", key }, () => {\n              });\n              refs.unref();\n            };\n            if (watch) {\n              watchCallbacks.set(key, (serviceStopError, watchResponse) => {\n                if (serviceStopError) {\n                  if (watch.onRebuild)\n                    watch.onRebuild(serviceStopError, null);\n                  return;\n                }\n                let result2 = {\n                  errors: replaceDetailsInMessages(watchResponse.errors, details),\n                  warnings: replaceDetailsInMessages(watchResponse.warnings, details)\n                };\n                copyResponseToResult(watchResponse, result2);\n                runOnEndCallbacks(result2, logPluginError, () => {\n                  if (result2.errors.length > 0) {\n                    if (watch.onRebuild)\n                      watch.onRebuild(failureErrorWithLog(\"Build failed\", result2.errors, result2.warnings), null);\n                    return;\n                  }\n                  if (watchResponse.rebuildID !== void 0)\n                    result2.rebuild = rebuild;\n                  result2.stop = stop;\n                  if (watch.onRebuild)\n                    watch.onRebuild(null, result2);\n                });\n              });\n            }\n          }\n          result.stop = stop;\n        }\n        callback2(null, result);\n      });\n    };\n    if (write && streamIn.isWriteUnavailable)\n      throw new Error(`The \"write\" option is unavailable in this environment`);\n    if (incremental && streamIn.isSync)\n      throw new Error(`Cannot use \"incremental\" with a synchronous build`);\n    if (watch && streamIn.isSync)\n      throw new Error(`Cannot use \"watch\" with a synchronous build`);\n    sendRequest(refs, request, (error, response) => {\n      if (error)\n        return callback(new Error(error), null);\n      if (serve2) {\n        let serveResponse = response;\n        let isStopped = false;\n        refs.ref();\n        let result = {\n          port: serveResponse.port,\n          host: serveResponse.host,\n          wait: serve2.wait,\n          stop() {\n            if (isStopped)\n              return;\n            isStopped = true;\n            serve2.stop();\n            refs.unref();\n          }\n        };\n        refs.ref();\n        serve2.wait.then(refs.unref, refs.unref);\n        return callback(null, result);\n      }\n      return buildResponseToResult(response, callback);\n    });\n  };\n  let transform2 = ({ callName, refs, input, options, isTTY, fs, callback }) => {\n    const details = createObjectStash();\n    let start = (inputPath) => {\n      try {\n        if (typeof input !== \"string\" && !(input instanceof Uint8Array))\n          throw new Error('The input to \"transform\" must be a string or a Uint8Array');\n        let {\n          flags,\n          mangleCache\n        } = flagsForTransformOptions(callName, options, isTTY, transformLogLevelDefault);\n        let request = {\n          command: \"transform\",\n          flags,\n          inputFS: inputPath !== null,\n          input: inputPath !== null ? encodeUTF8(inputPath) : typeof input === \"string\" ? encodeUTF8(input) : input\n        };\n        if (mangleCache)\n          request.mangleCache = mangleCache;\n        sendRequest(refs, request, (error, response) => {\n          if (error)\n            return callback(new Error(error), null);\n          let errors = replaceDetailsInMessages(response.errors, details);\n          let warnings = replaceDetailsInMessages(response.warnings, details);\n          let outstanding = 1;\n          let next = () => {\n            if (--outstanding === 0) {\n              let result = { warnings, code: response.code, map: response.map };\n              if (response.mangleCache)\n                result.mangleCache = response == null ? void 0 : response.mangleCache;\n              callback(null, result);\n            }\n          };\n          if (errors.length > 0)\n            return callback(failureErrorWithLog(\"Transform failed\", errors, warnings), null);\n          if (response.codeFS) {\n            outstanding++;\n            fs.readFile(response.code, (err, contents) => {\n              if (err !== null) {\n                callback(err, null);\n              } else {\n                response.code = contents;\n                next();\n              }\n            });\n          }\n          if (response.mapFS) {\n            outstanding++;\n            fs.readFile(response.map, (err, contents) => {\n              if (err !== null) {\n                callback(err, null);\n              } else {\n                response.map = contents;\n                next();\n              }\n            });\n          }\n          next();\n        });\n      } catch (e) {\n        let flags = [];\n        try {\n          pushLogFlags(flags, options, {}, isTTY, transformLogLevelDefault);\n        } catch (e2) {\n        }\n        const error = extractErrorMessageV8(e, streamIn, details, void 0, \"\");\n        sendRequest(refs, { command: \"error\", flags, error }, () => {\n          error.detail = details.load(error.detail);\n          callback(failureErrorWithLog(\"Transform failed\", [error], []), null);\n        });\n      }\n    };\n    if ((typeof input === \"string\" || input instanceof Uint8Array) && input.length > 1024 * 1024) {\n      let next = start;\n      start = () => fs.writeFile(input, next);\n    }\n    start(null);\n  };\n  let formatMessages2 = ({ callName, refs, messages, options, callback }) => {\n    let result = sanitizeMessages(messages, \"messages\", null, \"\");\n    if (!options)\n      throw new Error(`Missing second argument in ${callName}() call`);\n    let keys = {};\n    let kind = getFlag(options, keys, \"kind\", mustBeString);\n    let color = getFlag(options, keys, \"color\", mustBeBoolean);\n    let terminalWidth = getFlag(options, keys, \"terminalWidth\", mustBeInteger);\n    checkForInvalidFlags(options, keys, `in ${callName}() call`);\n    if (kind === void 0)\n      throw new Error(`Missing \"kind\" in ${callName}() call`);\n    if (kind !== \"error\" && kind !== \"warning\")\n      throw new Error(`Expected \"kind\" to be \"error\" or \"warning\" in ${callName}() call`);\n    let request = {\n      command: \"format-msgs\",\n      messages: result,\n      isWarning: kind === \"warning\"\n    };\n    if (color !== void 0)\n      request.color = color;\n    if (terminalWidth !== void 0)\n      request.terminalWidth = terminalWidth;\n    sendRequest(refs, request, (error, response) => {\n      if (error)\n        return callback(new Error(error), null);\n      callback(null, response.messages);\n    });\n  };\n  let analyzeMetafile2 = ({ callName, refs, metafile, options, callback }) => {\n    if (options === void 0)\n      options = {};\n    let keys = {};\n    let color = getFlag(options, keys, \"color\", mustBeBoolean);\n    let verbose = getFlag(options, keys, \"verbose\", mustBeBoolean);\n    checkForInvalidFlags(options, keys, `in ${callName}() call`);\n    let request = {\n      command: \"analyze-metafile\",\n      metafile\n    };\n    if (color !== void 0)\n      request.color = color;\n    if (verbose !== void 0)\n      request.verbose = verbose;\n    sendRequest(refs, request, (error, response) => {\n      if (error)\n        return callback(new Error(error), null);\n      callback(null, response.result);\n    });\n  };\n  return {\n    readFromStdout,\n    afterClose,\n    service: {\n      buildOrServe,\n      transform: transform2,\n      formatMessages: formatMessages2,\n      analyzeMetafile: analyzeMetafile2\n    }\n  };\n}\nfunction createObjectStash() {\n  const map = /* @__PURE__ */ new Map();\n  let nextID = 0;\n  return {\n    load(id) {\n      return map.get(id);\n    },\n    store(value) {\n      if (value === void 0)\n        return -1;\n      const id = nextID++;\n      map.set(id, value);\n      return id;\n    }\n  };\n}\nfunction extractCallerV8(e, streamIn, ident) {\n  let note;\n  let tried = false;\n  return () => {\n    if (tried)\n      return note;\n    tried = true;\n    try {\n      let lines = (e.stack + \"\").split(\"\\n\");\n      lines.splice(1, 1);\n      let location = parseStackLinesV8(streamIn, lines, ident);\n      if (location) {\n        note = { text: e.message, location };\n        return note;\n      }\n    } catch (e2) {\n    }\n  };\n}\nfunction extractErrorMessageV8(e, streamIn, stash, note, pluginName) {\n  let text = \"Internal error\";\n  let location = null;\n  try {\n    text = (e && e.message || e) + \"\";\n  } catch (e2) {\n  }\n  try {\n    location = parseStackLinesV8(streamIn, (e.stack + \"\").split(\"\\n\"), \"\");\n  } catch (e2) {\n  }\n  return { id: \"\", pluginName, text, location, notes: note ? [note] : [], detail: stash ? stash.store(e) : -1 };\n}\nfunction parseStackLinesV8(streamIn, lines, ident) {\n  let at = \"    at \";\n  if (streamIn.readFileSync && !lines[0].startsWith(at) && lines[1].startsWith(at)) {\n    for (let i = 1; i < lines.length; i++) {\n      let line = lines[i];\n      if (!line.startsWith(at))\n        continue;\n      line = line.slice(at.length);\n      while (true) {\n        let match = /^(?:new |async )?\\S+ \\((.*)\\)$/.exec(line);\n        if (match) {\n          line = match[1];\n          continue;\n        }\n        match = /^eval at \\S+ \\((.*)\\)(?:, \\S+:\\d+:\\d+)?$/.exec(line);\n        if (match) {\n          line = match[1];\n          continue;\n        }\n        match = /^(\\S+):(\\d+):(\\d+)$/.exec(line);\n        if (match) {\n          let contents;\n          try {\n            contents = streamIn.readFileSync(match[1], \"utf8\");\n          } catch (e) {\n            break;\n          }\n          let lineText = contents.split(/\\r\\n|\\r|\\n|\\u2028|\\u2029/)[+match[2] - 1] || \"\";\n          let column = +match[3] - 1;\n          let length = lineText.slice(column, column + ident.length) === ident ? ident.length : 0;\n          return {\n            file: match[1],\n            namespace: \"file\",\n            line: +match[2],\n            column: encodeUTF8(lineText.slice(0, column)).length,\n            length: encodeUTF8(lineText.slice(column, column + length)).length,\n            lineText: lineText + \"\\n\" + lines.slice(1).join(\"\\n\"),\n            suggestion: \"\"\n          };\n        }\n        break;\n      }\n    }\n  }\n  return null;\n}\nfunction failureErrorWithLog(text, errors, warnings) {\n  let limit = 5;\n  let summary = errors.length < 1 ? \"\" : ` with ${errors.length} error${errors.length < 2 ? \"\" : \"s\"}:` + errors.slice(0, limit + 1).map((e, i) => {\n    if (i === limit)\n      return \"\\n...\";\n    if (!e.location)\n      return `\nerror: ${e.text}`;\n    let { file, line, column } = e.location;\n    let pluginText = e.pluginName ? `[plugin: ${e.pluginName}] ` : \"\";\n    return `\n${file}:${line}:${column}: ERROR: ${pluginText}${e.text}`;\n  }).join(\"\");\n  let error = new Error(`${text}${summary}`);\n  error.errors = errors;\n  error.warnings = warnings;\n  return error;\n}\nfunction replaceDetailsInMessages(messages, stash) {\n  for (const message of messages) {\n    message.detail = stash.load(message.detail);\n  }\n  return messages;\n}\nfunction sanitizeLocation(location, where) {\n  if (location == null)\n    return null;\n  let keys = {};\n  let file = getFlag(location, keys, \"file\", mustBeString);\n  let namespace = getFlag(location, keys, \"namespace\", mustBeString);\n  let line = getFlag(location, keys, \"line\", mustBeInteger);\n  let column = getFlag(location, keys, \"column\", mustBeInteger);\n  let length = getFlag(location, keys, \"length\", mustBeInteger);\n  let lineText = getFlag(location, keys, \"lineText\", mustBeString);\n  let suggestion = getFlag(location, keys, \"suggestion\", mustBeString);\n  checkForInvalidFlags(location, keys, where);\n  return {\n    file: file || \"\",\n    namespace: namespace || \"\",\n    line: line || 0,\n    column: column || 0,\n    length: length || 0,\n    lineText: lineText || \"\",\n    suggestion: suggestion || \"\"\n  };\n}\nfunction sanitizeMessages(messages, property, stash, fallbackPluginName) {\n  let messagesClone = [];\n  let index = 0;\n  for (const message of messages) {\n    let keys = {};\n    let id = getFlag(message, keys, \"id\", mustBeString);\n    let pluginName = getFlag(message, keys, \"pluginName\", mustBeString);\n    let text = getFlag(message, keys, \"text\", mustBeString);\n    let location = getFlag(message, keys, \"location\", mustBeObjectOrNull);\n    let notes = getFlag(message, keys, \"notes\", mustBeArray);\n    let detail = getFlag(message, keys, \"detail\", canBeAnything);\n    let where = `in element ${index} of \"${property}\"`;\n    checkForInvalidFlags(message, keys, where);\n    let notesClone = [];\n    if (notes) {\n      for (const note of notes) {\n        let noteKeys = {};\n        let noteText = getFlag(note, noteKeys, \"text\", mustBeString);\n        let noteLocation = getFlag(note, noteKeys, \"location\", mustBeObjectOrNull);\n        checkForInvalidFlags(note, noteKeys, where);\n        notesClone.push({\n          text: noteText || \"\",\n          location: sanitizeLocation(noteLocation, where)\n        });\n      }\n    }\n    messagesClone.push({\n      id: id || \"\",\n      pluginName: pluginName || fallbackPluginName,\n      text: text || \"\",\n      location: sanitizeLocation(location, where),\n      notes: notesClone,\n      detail: stash ? stash.store(detail) : -1\n    });\n    index++;\n  }\n  return messagesClone;\n}\nfunction sanitizeStringArray(values, property) {\n  const result = [];\n  for (const value of values) {\n    if (typeof value !== \"string\")\n      throw new Error(`${JSON.stringify(property)} must be an array of strings`);\n    result.push(value);\n  }\n  return result;\n}\nfunction convertOutputFiles({ path, contents }) {\n  let text = null;\n  return {\n    path,\n    contents,\n    get text() {\n      const binary = this.contents;\n      if (text === null || binary !== contents) {\n        contents = binary;\n        text = decodeUTF8(binary);\n      }\n      return text;\n    }\n  };\n}\n\n// lib/npm/browser.ts\nvar version = \"0.15.5\";\nvar build = (options) => ensureServiceIsRunning().build(options);\nvar serve = () => {\n  throw new Error(`The \"serve\" API only works in node`);\n};\nvar transform = (input, options) => ensureServiceIsRunning().transform(input, options);\nvar formatMessages = (messages, options) => ensureServiceIsRunning().formatMessages(messages, options);\nvar analyzeMetafile = (metafile, options) => ensureServiceIsRunning().analyzeMetafile(metafile, options);\nvar buildSync = () => {\n  throw new Error(`The \"buildSync\" API only works in node`);\n};\nvar transformSync = () => {\n  throw new Error(`The \"transformSync\" API only works in node`);\n};\nvar formatMessagesSync = () => {\n  throw new Error(`The \"formatMessagesSync\" API only works in node`);\n};\nvar analyzeMetafileSync = () => {\n  throw new Error(`The \"analyzeMetafileSync\" API only works in node`);\n};\nvar initializePromise;\nvar longLivedService;\nvar ensureServiceIsRunning = () => {\n  if (longLivedService)\n    return longLivedService;\n  if (initializePromise)\n    throw new Error('You need to wait for the promise returned from \"initialize\" to be resolved before calling this');\n  throw new Error('You need to call \"initialize\" before calling this');\n};\nvar initialize = (options) => {\n  options = validateInitializeOptions(options || {});\n  let wasmURL = options.wasmURL;\n  let wasmModule = options.wasmModule;\n  let useWorker = options.worker !== false;\n  if (!wasmURL && !wasmModule)\n    throw new Error('Must provide either the \"wasmURL\" option or the \"wasmModule\" option');\n  if (initializePromise)\n    throw new Error('Cannot call \"initialize\" more than once');\n  initializePromise = startRunningService(wasmURL || \"\", wasmModule, useWorker);\n  initializePromise.catch(() => {\n    initializePromise = void 0;\n  });\n  return initializePromise;\n};\nvar startRunningService = (wasmURL, wasmModule, useWorker) => __async(void 0, null, function* () {\n  let wasm;\n  if (wasmModule) {\n    wasm = wasmModule;\n  } else {\n    let res = yield fetch(wasmURL);\n    if (!res.ok)\n      throw new Error(`Failed to download ${JSON.stringify(wasmURL)}`);\n    wasm = yield res.arrayBuffer();\n  }\n  let worker;\n  if (useWorker) {\n    let blob = new Blob([`onmessage=${'((postMessage) => {\\n      // Copyright 2018 The Go Authors. All rights reserved.\\n      // Use of this source code is governed by a BSD-style\\n      // license that can be found in the LICENSE file.\\n      var __async = (__this, __arguments, generator) => {\\n        return new Promise((resolve, reject) => {\\n          var fulfilled = (value) => {\\n            try {\\n              step(generator.next(value));\\n            } catch (e) {\\n              reject(e);\\n            }\\n          };\\n          var rejected = (value) => {\\n            try {\\n              step(generator.throw(value));\\n            } catch (e) {\\n              reject(e);\\n            }\\n          };\\n          var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\\n          step((generator = generator.apply(__this, __arguments)).next());\\n        });\\n      };\\n      let onmessage;\\n      let globalThis = {};\\n      for (let o = self; o; o = Object.getPrototypeOf(o))\\n        for (let k of Object.getOwnPropertyNames(o))\\n          if (!(k in globalThis))\\n            Object.defineProperty(globalThis, k, { get: () => self[k] });\\n      \"use strict\";\\n      (() => {\\n        const enosys = () => {\\n          const err = new Error(\"not implemented\");\\n          err.code = \"ENOSYS\";\\n          return err;\\n        };\\n        if (!globalThis.fs) {\\n          let outputBuf = \"\";\\n          globalThis.fs = {\\n            constants: { O_WRONLY: -1, O_RDWR: -1, O_CREAT: -1, O_TRUNC: -1, O_APPEND: -1, O_EXCL: -1 },\\n            writeSync(fd, buf) {\\n              outputBuf += decoder.decode(buf);\\n              const nl = outputBuf.lastIndexOf(\"\\\\n\");\\n              if (nl != -1) {\\n                console.log(outputBuf.substr(0, nl));\\n                outputBuf = outputBuf.substr(nl + 1);\\n              }\\n              return buf.length;\\n            },\\n            write(fd, buf, offset, length, position, callback) {\\n              if (offset !== 0 || length !== buf.length || position !== null) {\\n                callback(enosys());\\n                return;\\n              }\\n              const n = this.writeSync(fd, buf);\\n              callback(null, n);\\n            },\\n            chmod(path, mode, callback) {\\n              callback(enosys());\\n            },\\n            chown(path, uid, gid, callback) {\\n              callback(enosys());\\n            },\\n            close(fd, callback) {\\n              callback(enosys());\\n            },\\n            fchmod(fd, mode, callback) {\\n              callback(enosys());\\n            },\\n            fchown(fd, uid, gid, callback) {\\n              callback(enosys());\\n            },\\n            fstat(fd, callback) {\\n              callback(enosys());\\n            },\\n            fsync(fd, callback) {\\n              callback(null);\\n            },\\n            ftruncate(fd, length, callback) {\\n              callback(enosys());\\n            },\\n            lchown(path, uid, gid, callback) {\\n              callback(enosys());\\n            },\\n            link(path, link, callback) {\\n              callback(enosys());\\n            },\\n            lstat(path, callback) {\\n              callback(enosys());\\n            },\\n            mkdir(path, perm, callback) {\\n              callback(enosys());\\n            },\\n            open(path, flags, mode, callback) {\\n              callback(enosys());\\n            },\\n            read(fd, buffer, offset, length, position, callback) {\\n              callback(enosys());\\n            },\\n            readdir(path, callback) {\\n              callback(enosys());\\n            },\\n            readlink(path, callback) {\\n              callback(enosys());\\n            },\\n            rename(from, to, callback) {\\n              callback(enosys());\\n            },\\n            rmdir(path, callback) {\\n              callback(enosys());\\n            },\\n            stat(path, callback) {\\n              callback(enosys());\\n            },\\n            symlink(path, link, callback) {\\n              callback(enosys());\\n            },\\n            truncate(path, length, callback) {\\n              callback(enosys());\\n            },\\n            unlink(path, callback) {\\n              callback(enosys());\\n            },\\n            utimes(path, atime, mtime, callback) {\\n              callback(enosys());\\n            }\\n          };\\n        }\\n        if (!globalThis.process) {\\n          globalThis.process = {\\n            getuid() {\\n              return -1;\\n            },\\n            getgid() {\\n              return -1;\\n            },\\n            geteuid() {\\n              return -1;\\n            },\\n            getegid() {\\n              return -1;\\n            },\\n            getgroups() {\\n              throw enosys();\\n            },\\n            pid: -1,\\n            ppid: -1,\\n            umask() {\\n              throw enosys();\\n            },\\n            cwd() {\\n              throw enosys();\\n            },\\n            chdir() {\\n              throw enosys();\\n            }\\n          };\\n        }\\n        if (!globalThis.crypto) {\\n          throw new Error(\"globalThis.crypto is not available, polyfill required (crypto.getRandomValues only)\");\\n        }\\n        if (!globalThis.performance) {\\n          throw new Error(\"globalThis.performance is not available, polyfill required (performance.now only)\");\\n        }\\n        if (!globalThis.TextEncoder) {\\n          throw new Error(\"globalThis.TextEncoder is not available, polyfill required\");\\n        }\\n        if (!globalThis.TextDecoder) {\\n          throw new Error(\"globalThis.TextDecoder is not available, polyfill required\");\\n        }\\n        const encoder = new TextEncoder(\"utf-8\");\\n        const decoder = new TextDecoder(\"utf-8\");\\n        globalThis.Go = class {\\n          constructor() {\\n            this.argv = [\"js\"];\\n            this.env = {};\\n            this.exit = (code) => {\\n              if (code !== 0) {\\n                console.warn(\"exit code:\", code);\\n              }\\n            };\\n            this._exitPromise = new Promise((resolve) => {\\n              this._resolveExitPromise = resolve;\\n            });\\n            this._pendingEvent = null;\\n            this._scheduledTimeouts = /* @__PURE__ */ new Map();\\n            this._nextCallbackTimeoutID = 1;\\n            const setInt64 = (addr, v) => {\\n              this.mem.setUint32(addr + 0, v, true);\\n              this.mem.setUint32(addr + 4, Math.floor(v / 4294967296), true);\\n            };\\n            const getInt64 = (addr) => {\\n              const low = this.mem.getUint32(addr + 0, true);\\n              const high = this.mem.getInt32(addr + 4, true);\\n              return low + high * 4294967296;\\n            };\\n            const loadValue = (addr) => {\\n              const f = this.mem.getFloat64(addr, true);\\n              if (f === 0) {\\n                return void 0;\\n              }\\n              if (!isNaN(f)) {\\n                return f;\\n              }\\n              const id = this.mem.getUint32(addr, true);\\n              return this._values[id];\\n            };\\n            const storeValue = (addr, v) => {\\n              const nanHead = 2146959360;\\n              if (typeof v === \"number\" && v !== 0) {\\n                if (isNaN(v)) {\\n                  this.mem.setUint32(addr + 4, nanHead, true);\\n                  this.mem.setUint32(addr, 0, true);\\n                  return;\\n                }\\n                this.mem.setFloat64(addr, v, true);\\n                return;\\n              }\\n              if (v === void 0) {\\n                this.mem.setFloat64(addr, 0, true);\\n                return;\\n              }\\n              let id = this._ids.get(v);\\n              if (id === void 0) {\\n                id = this._idPool.pop();\\n                if (id === void 0) {\\n                  id = this._values.length;\\n                }\\n                this._values[id] = v;\\n                this._goRefCounts[id] = 0;\\n                this._ids.set(v, id);\\n              }\\n              this._goRefCounts[id]++;\\n              let typeFlag = 0;\\n              switch (typeof v) {\\n                case \"object\":\\n                  if (v !== null) {\\n                    typeFlag = 1;\\n                  }\\n                  break;\\n                case \"string\":\\n                  typeFlag = 2;\\n                  break;\\n                case \"symbol\":\\n                  typeFlag = 3;\\n                  break;\\n                case \"function\":\\n                  typeFlag = 4;\\n                  break;\\n              }\\n              this.mem.setUint32(addr + 4, nanHead | typeFlag, true);\\n              this.mem.setUint32(addr, id, true);\\n            };\\n            const loadSlice = (addr) => {\\n              const array = getInt64(addr + 0);\\n              const len = getInt64(addr + 8);\\n              return new Uint8Array(this._inst.exports.mem.buffer, array, len);\\n            };\\n            const loadSliceOfValues = (addr) => {\\n              const array = getInt64(addr + 0);\\n              const len = getInt64(addr + 8);\\n              const a = new Array(len);\\n              for (let i = 0; i < len; i++) {\\n                a[i] = loadValue(array + i * 8);\\n              }\\n              return a;\\n            };\\n            const loadString = (addr) => {\\n              const saddr = getInt64(addr + 0);\\n              const len = getInt64(addr + 8);\\n              return decoder.decode(new DataView(this._inst.exports.mem.buffer, saddr, len));\\n            };\\n            const timeOrigin = Date.now() - performance.now();\\n            this.importObject = {\\n              go: {\\n                \"runtime.wasmExit\": (sp) => {\\n                  sp >>>= 0;\\n                  const code = this.mem.getInt32(sp + 8, true);\\n                  this.exited = true;\\n                  delete this._inst;\\n                  delete this._values;\\n                  delete this._goRefCounts;\\n                  delete this._ids;\\n                  delete this._idPool;\\n                  this.exit(code);\\n                },\\n                \"runtime.wasmWrite\": (sp) => {\\n                  sp >>>= 0;\\n                  const fd = getInt64(sp + 8);\\n                  const p = getInt64(sp + 16);\\n                  const n = this.mem.getInt32(sp + 24, true);\\n                  globalThis.fs.writeSync(fd, new Uint8Array(this._inst.exports.mem.buffer, p, n));\\n                },\\n                \"runtime.resetMemoryDataView\": (sp) => {\\n                  sp >>>= 0;\\n                  this.mem = new DataView(this._inst.exports.mem.buffer);\\n                },\\n                \"runtime.nanotime1\": (sp) => {\\n                  sp >>>= 0;\\n                  setInt64(sp + 8, (timeOrigin + performance.now()) * 1e6);\\n                },\\n                \"runtime.walltime\": (sp) => {\\n                  sp >>>= 0;\\n                  const msec = new Date().getTime();\\n                  setInt64(sp + 8, msec / 1e3);\\n                  this.mem.setInt32(sp + 16, msec % 1e3 * 1e6, true);\\n                },\\n                \"runtime.scheduleTimeoutEvent\": (sp) => {\\n                  sp >>>= 0;\\n                  const id = this._nextCallbackTimeoutID;\\n                  this._nextCallbackTimeoutID++;\\n                  this._scheduledTimeouts.set(id, setTimeout(\\n                    () => {\\n                      this._resume();\\n                      while (this._scheduledTimeouts.has(id)) {\\n                        console.warn(\"scheduleTimeoutEvent: missed timeout event\");\\n                        this._resume();\\n                      }\\n                    },\\n                    getInt64(sp + 8) + 1\\n                  ));\\n                  this.mem.setInt32(sp + 16, id, true);\\n                },\\n                \"runtime.clearTimeoutEvent\": (sp) => {\\n                  sp >>>= 0;\\n                  const id = this.mem.getInt32(sp + 8, true);\\n                  clearTimeout(this._scheduledTimeouts.get(id));\\n                  this._scheduledTimeouts.delete(id);\\n                },\\n                \"runtime.getRandomData\": (sp) => {\\n                  sp >>>= 0;\\n                  crypto.getRandomValues(loadSlice(sp + 8));\\n                },\\n                \"syscall/js.finalizeRef\": (sp) => {\\n                  sp >>>= 0;\\n                  const id = this.mem.getUint32(sp + 8, true);\\n                  this._goRefCounts[id]--;\\n                  if (this._goRefCounts[id] === 0) {\\n                    const v = this._values[id];\\n                    this._values[id] = null;\\n                    this._ids.delete(v);\\n                    this._idPool.push(id);\\n                  }\\n                },\\n                \"syscall/js.stringVal\": (sp) => {\\n                  sp >>>= 0;\\n                  storeValue(sp + 24, loadString(sp + 8));\\n                },\\n                \"syscall/js.valueGet\": (sp) => {\\n                  sp >>>= 0;\\n                  const result = Reflect.get(loadValue(sp + 8), loadString(sp + 16));\\n                  sp = this._inst.exports.getsp() >>> 0;\\n                  storeValue(sp + 32, result);\\n                },\\n                \"syscall/js.valueSet\": (sp) => {\\n                  sp >>>= 0;\\n                  Reflect.set(loadValue(sp + 8), loadString(sp + 16), loadValue(sp + 32));\\n                },\\n                \"syscall/js.valueDelete\": (sp) => {\\n                  sp >>>= 0;\\n                  Reflect.deleteProperty(loadValue(sp + 8), loadString(sp + 16));\\n                },\\n                \"syscall/js.valueIndex\": (sp) => {\\n                  sp >>>= 0;\\n                  storeValue(sp + 24, Reflect.get(loadValue(sp + 8), getInt64(sp + 16)));\\n                },\\n                \"syscall/js.valueSetIndex\": (sp) => {\\n                  sp >>>= 0;\\n                  Reflect.set(loadValue(sp + 8), getInt64(sp + 16), loadValue(sp + 24));\\n                },\\n                \"syscall/js.valueCall\": (sp) => {\\n                  sp >>>= 0;\\n                  try {\\n                    const v = loadValue(sp + 8);\\n                    const m = Reflect.get(v, loadString(sp + 16));\\n                    const args = loadSliceOfValues(sp + 32);\\n                    const result = Reflect.apply(m, v, args);\\n                    sp = this._inst.exports.getsp() >>> 0;\\n                    storeValue(sp + 56, result);\\n                    this.mem.setUint8(sp + 64, 1);\\n                  } catch (err) {\\n                    sp = this._inst.exports.getsp() >>> 0;\\n                    storeValue(sp + 56, err);\\n                    this.mem.setUint8(sp + 64, 0);\\n                  }\\n                },\\n                \"syscall/js.valueInvoke\": (sp) => {\\n                  sp >>>= 0;\\n                  try {\\n                    const v = loadValue(sp + 8);\\n                    const args = loadSliceOfValues(sp + 16);\\n                    const result = Reflect.apply(v, void 0, args);\\n                    sp = this._inst.exports.getsp() >>> 0;\\n                    storeValue(sp + 40, result);\\n                    this.mem.setUint8(sp + 48, 1);\\n                  } catch (err) {\\n                    sp = this._inst.exports.getsp() >>> 0;\\n                    storeValue(sp + 40, err);\\n                    this.mem.setUint8(sp + 48, 0);\\n                  }\\n                },\\n                \"syscall/js.valueNew\": (sp) => {\\n                  sp >>>= 0;\\n                  try {\\n                    const v = loadValue(sp + 8);\\n                    const args = loadSliceOfValues(sp + 16);\\n                    const result = Reflect.construct(v, args);\\n                    sp = this._inst.exports.getsp() >>> 0;\\n                    storeValue(sp + 40, result);\\n                    this.mem.setUint8(sp + 48, 1);\\n                  } catch (err) {\\n                    sp = this._inst.exports.getsp() >>> 0;\\n                    storeValue(sp + 40, err);\\n                    this.mem.setUint8(sp + 48, 0);\\n                  }\\n                },\\n                \"syscall/js.valueLength\": (sp) => {\\n                  sp >>>= 0;\\n                  setInt64(sp + 16, parseInt(loadValue(sp + 8).length));\\n                },\\n                \"syscall/js.valuePrepareString\": (sp) => {\\n                  sp >>>= 0;\\n                  const str = encoder.encode(String(loadValue(sp + 8)));\\n                  storeValue(sp + 16, str);\\n                  setInt64(sp + 24, str.length);\\n                },\\n                \"syscall/js.valueLoadString\": (sp) => {\\n                  sp >>>= 0;\\n                  const str = loadValue(sp + 8);\\n                  loadSlice(sp + 16).set(str);\\n                },\\n                \"syscall/js.valueInstanceOf\": (sp) => {\\n                  sp >>>= 0;\\n                  this.mem.setUint8(sp + 24, loadValue(sp + 8) instanceof loadValue(sp + 16) ? 1 : 0);\\n                },\\n                \"syscall/js.copyBytesToGo\": (sp) => {\\n                  sp >>>= 0;\\n                  const dst = loadSlice(sp + 8);\\n                  const src = loadValue(sp + 32);\\n                  if (!(src instanceof Uint8Array || src instanceof Uint8ClampedArray)) {\\n                    this.mem.setUint8(sp + 48, 0);\\n                    return;\\n                  }\\n                  const toCopy = src.subarray(0, dst.length);\\n                  dst.set(toCopy);\\n                  setInt64(sp + 40, toCopy.length);\\n                  this.mem.setUint8(sp + 48, 1);\\n                },\\n                \"syscall/js.copyBytesToJS\": (sp) => {\\n                  sp >>>= 0;\\n                  const dst = loadValue(sp + 8);\\n                  const src = loadSlice(sp + 16);\\n                  if (!(dst instanceof Uint8Array || dst instanceof Uint8ClampedArray)) {\\n                    this.mem.setUint8(sp + 48, 0);\\n                    return;\\n                  }\\n                  const toCopy = src.subarray(0, dst.length);\\n                  dst.set(toCopy);\\n                  setInt64(sp + 40, toCopy.length);\\n                  this.mem.setUint8(sp + 48, 1);\\n                },\\n                \"debug\": (value) => {\\n                  console.log(value);\\n                }\\n              }\\n            };\\n          }\\n          run(instance) {\\n            return __async(this, null, function* () {\\n              if (!(instance instanceof WebAssembly.Instance)) {\\n                throw new Error(\"Go.run: WebAssembly.Instance expected\");\\n              }\\n              this._inst = instance;\\n              this.mem = new DataView(this._inst.exports.mem.buffer);\\n              this._values = [\\n                NaN,\\n                0,\\n                null,\\n                true,\\n                false,\\n                globalThis,\\n                this\\n              ];\\n              this._goRefCounts = new Array(this._values.length).fill(Infinity);\\n              this._ids = /* @__PURE__ */ new Map([\\n                [0, 1],\\n                [null, 2],\\n                [true, 3],\\n                [false, 4],\\n                [globalThis, 5],\\n                [this, 6]\\n              ]);\\n              this._idPool = [];\\n              this.exited = false;\\n              let offset = 4096;\\n              const strPtr = (str) => {\\n                const ptr = offset;\\n                const bytes = encoder.encode(str + \"\\\\0\");\\n                new Uint8Array(this.mem.buffer, offset, bytes.length).set(bytes);\\n                offset += bytes.length;\\n                if (offset % 8 !== 0) {\\n                  offset += 8 - offset % 8;\\n                }\\n                return ptr;\\n              };\\n              const argc = this.argv.length;\\n              const argvPtrs = [];\\n              this.argv.forEach((arg) => {\\n                argvPtrs.push(strPtr(arg));\\n              });\\n              argvPtrs.push(0);\\n              const keys = Object.keys(this.env).sort();\\n              keys.forEach((key) => {\\n                argvPtrs.push(strPtr(`${key}=${this.env[key]}`));\\n              });\\n              argvPtrs.push(0);\\n              const argv = offset;\\n              argvPtrs.forEach((ptr) => {\\n                this.mem.setUint32(offset, ptr, true);\\n                this.mem.setUint32(offset + 4, 0, true);\\n                offset += 8;\\n              });\\n              const wasmMinDataAddr = 4096 + 8192;\\n              if (offset >= wasmMinDataAddr) {\\n                throw new Error(\"total length of command line and environment variables exceeds limit\");\\n              }\\n              this._inst.exports.run(argc, argv);\\n              if (this.exited) {\\n                this._resolveExitPromise();\\n              }\\n              yield this._exitPromise;\\n            });\\n          }\\n          _resume() {\\n            if (this.exited) {\\n              throw new Error(\"Go program has already exited\");\\n            }\\n            this._inst.exports.resume();\\n            if (this.exited) {\\n              this._resolveExitPromise();\\n            }\\n          }\\n          _makeFuncWrapper(id) {\\n            const go = this;\\n            return function() {\\n              const event = { id, this: this, args: arguments };\\n              go._pendingEvent = event;\\n              go._resume();\\n              return event.result;\\n            };\\n          }\\n        };\\n      })();\\n      onmessage = ({ data: wasm }) => {\\n        let decoder = new TextDecoder();\\n        let fs = globalThis.fs;\\n        let stderr = \"\";\\n        fs.writeSync = (fd, buffer) => {\\n          if (fd === 1) {\\n            postMessage(buffer);\\n          } else if (fd === 2) {\\n            stderr += decoder.decode(buffer);\\n            let parts = stderr.split(\"\\\\n\");\\n            if (parts.length > 1)\\n              console.log(parts.slice(0, -1).join(\"\\\\n\"));\\n            stderr = parts[parts.length - 1];\\n          } else {\\n            throw new Error(\"Bad write\");\\n          }\\n          return buffer.length;\\n        };\\n        let stdin = [];\\n        let resumeStdin;\\n        let stdinPos = 0;\\n        onmessage = ({ data }) => {\\n          if (data.length > 0) {\\n            stdin.push(data);\\n            if (resumeStdin)\\n              resumeStdin();\\n          }\\n        };\\n        fs.read = (fd, buffer, offset, length, position, callback) => {\\n          if (fd !== 0 || offset !== 0 || length !== buffer.length || position !== null) {\\n            throw new Error(\"Bad read\");\\n          }\\n          if (stdin.length === 0) {\\n            resumeStdin = () => fs.read(fd, buffer, offset, length, position, callback);\\n            return;\\n          }\\n          let first = stdin[0];\\n          let count = Math.max(0, Math.min(length, first.length - stdinPos));\\n          buffer.set(first.subarray(stdinPos, stdinPos + count), offset);\\n          stdinPos += count;\\n          if (stdinPos === first.length) {\\n            stdin.shift();\\n            stdinPos = 0;\\n          }\\n          callback(null, count);\\n        };\\n        let go = new globalThis.Go();\\n        go.argv = [\"\", `--service=${\"0.15.5\"}`];\\n        if (wasm instanceof WebAssembly.Module) {\\n          WebAssembly.instantiate(wasm, go.importObject).then((instance) => go.run(instance));\\n        } else {\\n          WebAssembly.instantiate(wasm, go.importObject).then(({ instance }) => go.run(instance));\\n        }\\n      };\\n      return (m) => onmessage(m);\\n    })'}(postMessage)`], { type: \"text/javascript\" });\n    worker = new Worker(URL.createObjectURL(blob));\n  } else {\n    let onmessage = ((postMessage) => {\n      // Copyright 2018 The Go Authors. All rights reserved.\n      // Use of this source code is governed by a BSD-style\n      // license that can be found in the LICENSE file.\n      var __async = (__this, __arguments, generator) => {\n        return new Promise((resolve, reject) => {\n          var fulfilled = (value) => {\n            try {\n              step(generator.next(value));\n            } catch (e) {\n              reject(e);\n            }\n          };\n          var rejected = (value) => {\n            try {\n              step(generator.throw(value));\n            } catch (e) {\n              reject(e);\n            }\n          };\n          var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n          step((generator = generator.apply(__this, __arguments)).next());\n        });\n      };\n      let onmessage;\n      let globalThis = {};\n      for (let o = self; o; o = Object.getPrototypeOf(o))\n        for (let k of Object.getOwnPropertyNames(o))\n          if (!(k in globalThis))\n            Object.defineProperty(globalThis, k, { get: () => self[k] });\n      \"use strict\";\n      (() => {\n        const enosys = () => {\n          const err = new Error(\"not implemented\");\n          err.code = \"ENOSYS\";\n          return err;\n        };\n        if (!globalThis.fs) {\n          let outputBuf = \"\";\n          globalThis.fs = {\n            constants: { O_WRONLY: -1, O_RDWR: -1, O_CREAT: -1, O_TRUNC: -1, O_APPEND: -1, O_EXCL: -1 },\n            writeSync(fd, buf) {\n              outputBuf += decoder.decode(buf);\n              const nl = outputBuf.lastIndexOf(\"\\n\");\n              if (nl != -1) {\n                console.log(outputBuf.substr(0, nl));\n                outputBuf = outputBuf.substr(nl + 1);\n              }\n              return buf.length;\n            },\n            write(fd, buf, offset, length, position, callback) {\n              if (offset !== 0 || length !== buf.length || position !== null) {\n                callback(enosys());\n                return;\n              }\n              const n = this.writeSync(fd, buf);\n              callback(null, n);\n            },\n            chmod(path, mode, callback) {\n              callback(enosys());\n            },\n            chown(path, uid, gid, callback) {\n              callback(enosys());\n            },\n            close(fd, callback) {\n              callback(enosys());\n            },\n            fchmod(fd, mode, callback) {\n              callback(enosys());\n            },\n            fchown(fd, uid, gid, callback) {\n              callback(enosys());\n            },\n            fstat(fd, callback) {\n              callback(enosys());\n            },\n            fsync(fd, callback) {\n              callback(null);\n            },\n            ftruncate(fd, length, callback) {\n              callback(enosys());\n            },\n            lchown(path, uid, gid, callback) {\n              callback(enosys());\n            },\n            link(path, link, callback) {\n              callback(enosys());\n            },\n            lstat(path, callback) {\n              callback(enosys());\n            },\n            mkdir(path, perm, callback) {\n              callback(enosys());\n            },\n            open(path, flags, mode, callback) {\n              callback(enosys());\n            },\n            read(fd, buffer, offset, length, position, callback) {\n              callback(enosys());\n            },\n            readdir(path, callback) {\n              callback(enosys());\n            },\n            readlink(path, callback) {\n              callback(enosys());\n            },\n            rename(from, to, callback) {\n              callback(enosys());\n            },\n            rmdir(path, callback) {\n              callback(enosys());\n            },\n            stat(path, callback) {\n              callback(enosys());\n            },\n            symlink(path, link, callback) {\n              callback(enosys());\n            },\n            truncate(path, length, callback) {\n              callback(enosys());\n            },\n            unlink(path, callback) {\n              callback(enosys());\n            },\n            utimes(path, atime, mtime, callback) {\n              callback(enosys());\n            }\n          };\n        }\n        if (!globalThis.process) {\n          globalThis.process = {\n            getuid() {\n              return -1;\n            },\n            getgid() {\n              return -1;\n            },\n            geteuid() {\n              return -1;\n            },\n            getegid() {\n              return -1;\n            },\n            getgroups() {\n              throw enosys();\n            },\n            pid: -1,\n            ppid: -1,\n            umask() {\n              throw enosys();\n            },\n            cwd() {\n              throw enosys();\n            },\n            chdir() {\n              throw enosys();\n            }\n          };\n        }\n        if (!globalThis.crypto) {\n          throw new Error(\"globalThis.crypto is not available, polyfill required (crypto.getRandomValues only)\");\n        }\n        if (!globalThis.performance) {\n          throw new Error(\"globalThis.performance is not available, polyfill required (performance.now only)\");\n        }\n        if (!globalThis.TextEncoder) {\n          throw new Error(\"globalThis.TextEncoder is not available, polyfill required\");\n        }\n        if (!globalThis.TextDecoder) {\n          throw new Error(\"globalThis.TextDecoder is not available, polyfill required\");\n        }\n        const encoder = new TextEncoder(\"utf-8\");\n        const decoder = new TextDecoder(\"utf-8\");\n        globalThis.Go = class {\n          constructor() {\n            this.argv = [\"js\"];\n            this.env = {};\n            this.exit = (code) => {\n              if (code !== 0) {\n                console.warn(\"exit code:\", code);\n              }\n            };\n            this._exitPromise = new Promise((resolve) => {\n              this._resolveExitPromise = resolve;\n            });\n            this._pendingEvent = null;\n            this._scheduledTimeouts = /* @__PURE__ */ new Map();\n            this._nextCallbackTimeoutID = 1;\n            const setInt64 = (addr, v) => {\n              this.mem.setUint32(addr + 0, v, true);\n              this.mem.setUint32(addr + 4, Math.floor(v / 4294967296), true);\n            };\n            const getInt64 = (addr) => {\n              const low = this.mem.getUint32(addr + 0, true);\n              const high = this.mem.getInt32(addr + 4, true);\n              return low + high * 4294967296;\n            };\n            const loadValue = (addr) => {\n              const f = this.mem.getFloat64(addr, true);\n              if (f === 0) {\n                return void 0;\n              }\n              if (!isNaN(f)) {\n                return f;\n              }\n              const id = this.mem.getUint32(addr, true);\n              return this._values[id];\n            };\n            const storeValue = (addr, v) => {\n              const nanHead = 2146959360;\n              if (typeof v === \"number\" && v !== 0) {\n                if (isNaN(v)) {\n                  this.mem.setUint32(addr + 4, nanHead, true);\n                  this.mem.setUint32(addr, 0, true);\n                  return;\n                }\n                this.mem.setFloat64(addr, v, true);\n                return;\n              }\n              if (v === void 0) {\n                this.mem.setFloat64(addr, 0, true);\n                return;\n              }\n              let id = this._ids.get(v);\n              if (id === void 0) {\n                id = this._idPool.pop();\n                if (id === void 0) {\n                  id = this._values.length;\n                }\n                this._values[id] = v;\n                this._goRefCounts[id] = 0;\n                this._ids.set(v, id);\n              }\n              this._goRefCounts[id]++;\n              let typeFlag = 0;\n              switch (typeof v) {\n                case \"object\":\n                  if (v !== null) {\n                    typeFlag = 1;\n                  }\n                  break;\n                case \"string\":\n                  typeFlag = 2;\n                  break;\n                case \"symbol\":\n                  typeFlag = 3;\n                  break;\n                case \"function\":\n                  typeFlag = 4;\n                  break;\n              }\n              this.mem.setUint32(addr + 4, nanHead | typeFlag, true);\n              this.mem.setUint32(addr, id, true);\n            };\n            const loadSlice = (addr) => {\n              const array = getInt64(addr + 0);\n              const len = getInt64(addr + 8);\n              return new Uint8Array(this._inst.exports.mem.buffer, array, len);\n            };\n            const loadSliceOfValues = (addr) => {\n              const array = getInt64(addr + 0);\n              const len = getInt64(addr + 8);\n              const a = new Array(len);\n              for (let i = 0; i < len; i++) {\n                a[i] = loadValue(array + i * 8);\n              }\n              return a;\n            };\n            const loadString = (addr) => {\n              const saddr = getInt64(addr + 0);\n              const len = getInt64(addr + 8);\n              return decoder.decode(new DataView(this._inst.exports.mem.buffer, saddr, len));\n            };\n            const timeOrigin = Date.now() - performance.now();\n            this.importObject = {\n              go: {\n                \"runtime.wasmExit\": (sp) => {\n                  sp >>>= 0;\n                  const code = this.mem.getInt32(sp + 8, true);\n                  this.exited = true;\n                  delete this._inst;\n                  delete this._values;\n                  delete this._goRefCounts;\n                  delete this._ids;\n                  delete this._idPool;\n                  this.exit(code);\n                },\n                \"runtime.wasmWrite\": (sp) => {\n                  sp >>>= 0;\n                  const fd = getInt64(sp + 8);\n                  const p = getInt64(sp + 16);\n                  const n = this.mem.getInt32(sp + 24, true);\n                  globalThis.fs.writeSync(fd, new Uint8Array(this._inst.exports.mem.buffer, p, n));\n                },\n                \"runtime.resetMemoryDataView\": (sp) => {\n                  sp >>>= 0;\n                  this.mem = new DataView(this._inst.exports.mem.buffer);\n                },\n                \"runtime.nanotime1\": (sp) => {\n                  sp >>>= 0;\n                  setInt64(sp + 8, (timeOrigin + performance.now()) * 1e6);\n                },\n                \"runtime.walltime\": (sp) => {\n                  sp >>>= 0;\n                  const msec = new Date().getTime();\n                  setInt64(sp + 8, msec / 1e3);\n                  this.mem.setInt32(sp + 16, msec % 1e3 * 1e6, true);\n                },\n                \"runtime.scheduleTimeoutEvent\": (sp) => {\n                  sp >>>= 0;\n                  const id = this._nextCallbackTimeoutID;\n                  this._nextCallbackTimeoutID++;\n                  this._scheduledTimeouts.set(id, setTimeout(\n                    () => {\n                      this._resume();\n                      while (this._scheduledTimeouts.has(id)) {\n                        console.warn(\"scheduleTimeoutEvent: missed timeout event\");\n                        this._resume();\n                      }\n                    },\n                    getInt64(sp + 8) + 1\n                  ));\n                  this.mem.setInt32(sp + 16, id, true);\n                },\n                \"runtime.clearTimeoutEvent\": (sp) => {\n                  sp >>>= 0;\n                  const id = this.mem.getInt32(sp + 8, true);\n                  clearTimeout(this._scheduledTimeouts.get(id));\n                  this._scheduledTimeouts.delete(id);\n                },\n                \"runtime.getRandomData\": (sp) => {\n                  sp >>>= 0;\n                  crypto.getRandomValues(loadSlice(sp + 8));\n                },\n                \"syscall/js.finalizeRef\": (sp) => {\n                  sp >>>= 0;\n                  const id = this.mem.getUint32(sp + 8, true);\n                  this._goRefCounts[id]--;\n                  if (this._goRefCounts[id] === 0) {\n                    const v = this._values[id];\n                    this._values[id] = null;\n                    this._ids.delete(v);\n                    this._idPool.push(id);\n                  }\n                },\n                \"syscall/js.stringVal\": (sp) => {\n                  sp >>>= 0;\n                  storeValue(sp + 24, loadString(sp + 8));\n                },\n                \"syscall/js.valueGet\": (sp) => {\n                  sp >>>= 0;\n                  const result = Reflect.get(loadValue(sp + 8), loadString(sp + 16));\n                  sp = this._inst.exports.getsp() >>> 0;\n                  storeValue(sp + 32, result);\n                },\n                \"syscall/js.valueSet\": (sp) => {\n                  sp >>>= 0;\n                  Reflect.set(loadValue(sp + 8), loadString(sp + 16), loadValue(sp + 32));\n                },\n                \"syscall/js.valueDelete\": (sp) => {\n                  sp >>>= 0;\n                  Reflect.deleteProperty(loadValue(sp + 8), loadString(sp + 16));\n                },\n                \"syscall/js.valueIndex\": (sp) => {\n                  sp >>>= 0;\n                  storeValue(sp + 24, Reflect.get(loadValue(sp + 8), getInt64(sp + 16)));\n                },\n                \"syscall/js.valueSetIndex\": (sp) => {\n                  sp >>>= 0;\n                  Reflect.set(loadValue(sp + 8), getInt64(sp + 16), loadValue(sp + 24));\n                },\n                \"syscall/js.valueCall\": (sp) => {\n                  sp >>>= 0;\n                  try {\n                    const v = loadValue(sp + 8);\n                    const m = Reflect.get(v, loadString(sp + 16));\n                    const args = loadSliceOfValues(sp + 32);\n                    const result = Reflect.apply(m, v, args);\n                    sp = this._inst.exports.getsp() >>> 0;\n                    storeValue(sp + 56, result);\n                    this.mem.setUint8(sp + 64, 1);\n                  } catch (err) {\n                    sp = this._inst.exports.getsp() >>> 0;\n                    storeValue(sp + 56, err);\n                    this.mem.setUint8(sp + 64, 0);\n                  }\n                },\n                \"syscall/js.valueInvoke\": (sp) => {\n                  sp >>>= 0;\n                  try {\n                    const v = loadValue(sp + 8);\n                    const args = loadSliceOfValues(sp + 16);\n                    const result = Reflect.apply(v, void 0, args);\n                    sp = this._inst.exports.getsp() >>> 0;\n                    storeValue(sp + 40, result);\n                    this.mem.setUint8(sp + 48, 1);\n                  } catch (err) {\n                    sp = this._inst.exports.getsp() >>> 0;\n                    storeValue(sp + 40, err);\n                    this.mem.setUint8(sp + 48, 0);\n                  }\n                },\n                \"syscall/js.valueNew\": (sp) => {\n                  sp >>>= 0;\n                  try {\n                    const v = loadValue(sp + 8);\n                    const args = loadSliceOfValues(sp + 16);\n                    const result = Reflect.construct(v, args);\n                    sp = this._inst.exports.getsp() >>> 0;\n                    storeValue(sp + 40, result);\n                    this.mem.setUint8(sp + 48, 1);\n                  } catch (err) {\n                    sp = this._inst.exports.getsp() >>> 0;\n                    storeValue(sp + 40, err);\n                    this.mem.setUint8(sp + 48, 0);\n                  }\n                },\n                \"syscall/js.valueLength\": (sp) => {\n                  sp >>>= 0;\n                  setInt64(sp + 16, parseInt(loadValue(sp + 8).length));\n                },\n                \"syscall/js.valuePrepareString\": (sp) => {\n                  sp >>>= 0;\n                  const str = encoder.encode(String(loadValue(sp + 8)));\n                  storeValue(sp + 16, str);\n                  setInt64(sp + 24, str.length);\n                },\n                \"syscall/js.valueLoadString\": (sp) => {\n                  sp >>>= 0;\n                  const str = loadValue(sp + 8);\n                  loadSlice(sp + 16).set(str);\n                },\n                \"syscall/js.valueInstanceOf\": (sp) => {\n                  sp >>>= 0;\n                  this.mem.setUint8(sp + 24, loadValue(sp + 8) instanceof loadValue(sp + 16) ? 1 : 0);\n                },\n                \"syscall/js.copyBytesToGo\": (sp) => {\n                  sp >>>= 0;\n                  const dst = loadSlice(sp + 8);\n                  const src = loadValue(sp + 32);\n                  if (!(src instanceof Uint8Array || src instanceof Uint8ClampedArray)) {\n                    this.mem.setUint8(sp + 48, 0);\n                    return;\n                  }\n                  const toCopy = src.subarray(0, dst.length);\n                  dst.set(toCopy);\n                  setInt64(sp + 40, toCopy.length);\n                  this.mem.setUint8(sp + 48, 1);\n                },\n                \"syscall/js.copyBytesToJS\": (sp) => {\n                  sp >>>= 0;\n                  const dst = loadValue(sp + 8);\n                  const src = loadSlice(sp + 16);\n                  if (!(dst instanceof Uint8Array || dst instanceof Uint8ClampedArray)) {\n                    this.mem.setUint8(sp + 48, 0);\n                    return;\n                  }\n                  const toCopy = src.subarray(0, dst.length);\n                  dst.set(toCopy);\n                  setInt64(sp + 40, toCopy.length);\n                  this.mem.setUint8(sp + 48, 1);\n                },\n                \"debug\": (value) => {\n                  console.log(value);\n                }\n              }\n            };\n          }\n          run(instance) {\n            return __async(this, null, function* () {\n              if (!(instance instanceof WebAssembly.Instance)) {\n                throw new Error(\"Go.run: WebAssembly.Instance expected\");\n              }\n              this._inst = instance;\n              this.mem = new DataView(this._inst.exports.mem.buffer);\n              this._values = [\n                NaN,\n                0,\n                null,\n                true,\n                false,\n                globalThis,\n                this\n              ];\n              this._goRefCounts = new Array(this._values.length).fill(Infinity);\n              this._ids = /* @__PURE__ */ new Map([\n                [0, 1],\n                [null, 2],\n                [true, 3],\n                [false, 4],\n                [globalThis, 5],\n                [this, 6]\n              ]);\n              this._idPool = [];\n              this.exited = false;\n              let offset = 4096;\n              const strPtr = (str) => {\n                const ptr = offset;\n                const bytes = encoder.encode(str + \"\\0\");\n                new Uint8Array(this.mem.buffer, offset, bytes.length).set(bytes);\n                offset += bytes.length;\n                if (offset % 8 !== 0) {\n                  offset += 8 - offset % 8;\n                }\n                return ptr;\n              };\n              const argc = this.argv.length;\n              const argvPtrs = [];\n              this.argv.forEach((arg) => {\n                argvPtrs.push(strPtr(arg));\n              });\n              argvPtrs.push(0);\n              const keys = Object.keys(this.env).sort();\n              keys.forEach((key) => {\n                argvPtrs.push(strPtr(`${key}=${this.env[key]}`));\n              });\n              argvPtrs.push(0);\n              const argv = offset;\n              argvPtrs.forEach((ptr) => {\n                this.mem.setUint32(offset, ptr, true);\n                this.mem.setUint32(offset + 4, 0, true);\n                offset += 8;\n              });\n              const wasmMinDataAddr = 4096 + 8192;\n              if (offset >= wasmMinDataAddr) {\n                throw new Error(\"total length of command line and environment variables exceeds limit\");\n              }\n              this._inst.exports.run(argc, argv);\n              if (this.exited) {\n                this._resolveExitPromise();\n              }\n              yield this._exitPromise;\n            });\n          }\n          _resume() {\n            if (this.exited) {\n              throw new Error(\"Go program has already exited\");\n            }\n            this._inst.exports.resume();\n            if (this.exited) {\n              this._resolveExitPromise();\n            }\n          }\n          _makeFuncWrapper(id) {\n            const go = this;\n            return function() {\n              const event = { id, this: this, args: arguments };\n              go._pendingEvent = event;\n              go._resume();\n              return event.result;\n            };\n          }\n        };\n      })();\n      onmessage = ({ data: wasm }) => {\n        let decoder = new TextDecoder();\n        let fs = globalThis.fs;\n        let stderr = \"\";\n        fs.writeSync = (fd, buffer) => {\n          if (fd === 1) {\n            postMessage(buffer);\n          } else if (fd === 2) {\n            stderr += decoder.decode(buffer);\n            let parts = stderr.split(\"\\n\");\n            if (parts.length > 1)\n              console.log(parts.slice(0, -1).join(\"\\n\"));\n            stderr = parts[parts.length - 1];\n          } else {\n            throw new Error(\"Bad write\");\n          }\n          return buffer.length;\n        };\n        let stdin = [];\n        let resumeStdin;\n        let stdinPos = 0;\n        onmessage = ({ data }) => {\n          if (data.length > 0) {\n            stdin.push(data);\n            if (resumeStdin)\n              resumeStdin();\n          }\n        };\n        fs.read = (fd, buffer, offset, length, position, callback) => {\n          if (fd !== 0 || offset !== 0 || length !== buffer.length || position !== null) {\n            throw new Error(\"Bad read\");\n          }\n          if (stdin.length === 0) {\n            resumeStdin = () => fs.read(fd, buffer, offset, length, position, callback);\n            return;\n          }\n          let first = stdin[0];\n          let count = Math.max(0, Math.min(length, first.length - stdinPos));\n          buffer.set(first.subarray(stdinPos, stdinPos + count), offset);\n          stdinPos += count;\n          if (stdinPos === first.length) {\n            stdin.shift();\n            stdinPos = 0;\n          }\n          callback(null, count);\n        };\n        let go = new globalThis.Go();\n        go.argv = [\"\", `--service=${\"0.15.5\"}`];\n        if (wasm instanceof WebAssembly.Module) {\n          WebAssembly.instantiate(wasm, go.importObject).then((instance) => go.run(instance));\n        } else {\n          WebAssembly.instantiate(wasm, go.importObject).then(({ instance }) => go.run(instance));\n        }\n      };\n      return (m) => onmessage(m);\n    })((data) => worker.onmessage({ data }));\n    worker = {\n      onmessage: null,\n      postMessage: (data) => setTimeout(() => onmessage({ data })),\n      terminate() {\n      }\n    };\n  }\n  worker.postMessage(wasm);\n  worker.onmessage = ({ data }) => readFromStdout(data);\n  let { readFromStdout, service } = createChannel({\n    writeToStdin(bytes) {\n      worker.postMessage(bytes);\n    },\n    isSync: false,\n    isWriteUnavailable: true,\n    esbuild: browser_exports\n  });\n  longLivedService = {\n    build: (options) => new Promise((resolve, reject) => service.buildOrServe({\n      callName: \"build\",\n      refs: null,\n      serveOptions: null,\n      options,\n      isTTY: false,\n      defaultWD: \"/\",\n      callback: (err, res) => err ? reject(err) : resolve(res)\n    })),\n    transform: (input, options) => new Promise((resolve, reject) => service.transform({\n      callName: \"transform\",\n      refs: null,\n      input,\n      options: options || {},\n      isTTY: false,\n      fs: {\n        readFile(_, callback) {\n          callback(new Error(\"Internal error\"), null);\n        },\n        writeFile(_, callback) {\n          callback(null);\n        }\n      },\n      callback: (err, res) => err ? reject(err) : resolve(res)\n    })),\n    formatMessages: (messages, options) => new Promise((resolve, reject) => service.formatMessages({\n      callName: \"formatMessages\",\n      refs: null,\n      messages,\n      options,\n      callback: (err, res) => err ? reject(err) : resolve(res)\n    })),\n    analyzeMetafile: (metafile, options) => new Promise((resolve, reject) => service.analyzeMetafile({\n      callName: \"analyzeMetafile\",\n      refs: null,\n      metafile: typeof metafile === \"string\" ? metafile : JSON.stringify(metafile),\n      options,\n      callback: (err, res) => err ? reject(err) : resolve(res)\n    }))\n  };\n});\nvar browser_default = browser_exports;\n})(typeof module===\"object\"?module:{set exports(x){(typeof self!==\"undefined\"?self:this).esbuild=x}});\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}