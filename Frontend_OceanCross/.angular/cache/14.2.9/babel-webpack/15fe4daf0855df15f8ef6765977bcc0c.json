{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar _asyncToGenerator = require(\"/Users/deliabarbuta/Documents/An4Sem1/PAW/Proiect/proiect-paw-tadam/Frontend_OceanCross/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SassWorkerImplementation = void 0;\n\nconst worker_threads_1 = require(\"worker_threads\");\n\nconst environment_options_1 = require(\"../utils/environment-options\");\n/**\n * The maximum number of Workers that will be created to execute render requests.\n */\n\n\nconst MAX_RENDER_WORKERS = environment_options_1.maxWorkers;\n/**\n * A Sass renderer implementation that provides an interface that can be used by Webpack's\n * `sass-loader`. The implementation uses a Worker thread to perform the Sass rendering\n * with the `dart-sass` package.  The `dart-sass` synchronous render function is used within\n * the worker which can be up to two times faster than the asynchronous variant.\n */\n\nclass SassWorkerImplementation {\n  constructor() {\n    this.workers = [];\n    this.availableWorkers = [];\n    this.requests = new Map();\n    this.idCounter = 1;\n    this.nextWorkerIndex = 0;\n  }\n  /**\n   * Provides information about the Sass implementation.\n   * This mimics enough of the `dart-sass` value to be used with the `sass-loader`.\n   */\n\n\n  get info() {\n    return 'dart-sass\\tworker';\n  }\n  /**\n   * The synchronous render function is not used by the `sass-loader`.\n   */\n\n\n  renderSync() {\n    throw new Error('Sass renderSync is not supported.');\n  }\n  /**\n   * Asynchronously request a Sass stylesheet to be renderered.\n   *\n   * @param options The `dart-sass` options to use when rendering the stylesheet.\n   * @param callback The function to execute when the rendering is complete.\n   */\n\n\n  render(options, callback) {\n    // The `functions`, `logger` and `importer` options are JavaScript functions that cannot be transferred.\n    // If any additional function options are added in the future, they must be excluded as well.\n    const {\n      functions,\n      importer,\n      logger,\n      ...serializableOptions\n    } = options; // The CLI's configuration does not use or expose the ability to defined custom Sass functions\n\n    if (functions && Object.keys(functions).length > 0) {\n      throw new Error('Sass custom functions are not supported.');\n    }\n\n    let workerIndex = this.availableWorkers.pop();\n\n    if (workerIndex === undefined) {\n      if (this.workers.length < MAX_RENDER_WORKERS) {\n        workerIndex = this.workers.length;\n        this.workers.push(this.createWorker());\n      } else {\n        workerIndex = this.nextWorkerIndex++;\n\n        if (this.nextWorkerIndex >= this.workers.length) {\n          this.nextWorkerIndex = 0;\n        }\n      }\n    }\n\n    const request = this.createRequest(workerIndex, callback, importer);\n    this.requests.set(request.id, request);\n    this.workers[workerIndex].postMessage({\n      id: request.id,\n      hasImporter: !!importer,\n      options: serializableOptions\n    });\n  }\n  /**\n   * Shutdown the Sass render worker.\n   * Executing this method will stop any pending render requests.\n   */\n\n\n  close() {\n    for (const worker of this.workers) {\n      try {\n        void worker.terminate();\n      } catch {}\n    }\n\n    this.requests.clear();\n  }\n\n  createWorker() {\n    const {\n      port1: mainImporterPort,\n      port2: workerImporterPort\n    } = new worker_threads_1.MessageChannel();\n    const importerSignal = new Int32Array(new SharedArrayBuffer(4));\n\n    const workerPath = require.resolve('./worker');\n\n    const worker = new worker_threads_1.Worker(workerPath, {\n      workerData: {\n        workerImporterPort,\n        importerSignal\n      },\n      transferList: [workerImporterPort]\n    });\n    worker.on('message', response => {\n      const request = this.requests.get(response.id);\n\n      if (!request) {\n        return;\n      }\n\n      this.requests.delete(response.id);\n      this.availableWorkers.push(request.workerIndex);\n\n      if (response.result) {\n        // The results are expected to be Node.js `Buffer` objects but will each be transferred as\n        // a Uint8Array that does not have the expected `toString` behavior of a `Buffer`.\n        const {\n          css,\n          map,\n          stats\n        } = response.result;\n        const result = {\n          // This `Buffer.from` override will use the memory directly and avoid making a copy\n          css: Buffer.from(css.buffer, css.byteOffset, css.byteLength),\n          stats\n        };\n\n        if (map) {\n          // This `Buffer.from` override will use the memory directly and avoid making a copy\n          result.map = Buffer.from(map.buffer, map.byteOffset, map.byteLength);\n        }\n\n        request.callback(undefined, result);\n      } else {\n        request.callback(response.error);\n      }\n    });\n    mainImporterPort.on('message', ({\n      id,\n      url,\n      prev,\n      fromImport\n    }) => {\n      const request = this.requests.get(id);\n\n      if (!(request === null || request === void 0 ? void 0 : request.importers)) {\n        mainImporterPort.postMessage(null);\n        Atomics.store(importerSignal, 0, 1);\n        Atomics.notify(importerSignal, 0);\n        return;\n      }\n\n      this.processImporters(request.importers, url, prev, fromImport).then(result => {\n        mainImporterPort.postMessage(result);\n      }).catch(error => {\n        mainImporterPort.postMessage(error);\n      }).finally(() => {\n        Atomics.store(importerSignal, 0, 1);\n        Atomics.notify(importerSignal, 0);\n      });\n    });\n    mainImporterPort.unref();\n    return worker;\n  }\n\n  processImporters(importers, url, prev, fromImport) {\n    return _asyncToGenerator(function* () {\n      let result = null;\n\n      for (const importer of importers) {\n        result = yield new Promise(resolve => {\n          // Importers can be both sync and async\n          const innerResult = importer.call({\n            fromImport\n          }, url, prev, resolve);\n\n          if (innerResult !== undefined) {\n            resolve(innerResult);\n          }\n        });\n\n        if (result) {\n          break;\n        }\n      }\n\n      return result;\n    })();\n  }\n\n  createRequest(workerIndex, callback, importer) {\n    return {\n      id: this.idCounter++,\n      workerIndex,\n      callback,\n      importers: !importer || Array.isArray(importer) ? importer : [importer]\n    };\n  }\n\n}\n\nexports.SassWorkerImplementation = SassWorkerImplementation;","map":{"version":3,"names":["Object","defineProperty","exports","value","SassWorkerImplementation","worker_threads_1","require","environment_options_1","MAX_RENDER_WORKERS","maxWorkers","constructor","workers","availableWorkers","requests","Map","idCounter","nextWorkerIndex","info","renderSync","Error","render","options","callback","functions","importer","logger","serializableOptions","keys","length","workerIndex","pop","undefined","push","createWorker","request","createRequest","set","id","postMessage","hasImporter","close","worker","terminate","clear","port1","mainImporterPort","port2","workerImporterPort","MessageChannel","importerSignal","Int32Array","SharedArrayBuffer","workerPath","resolve","Worker","workerData","transferList","on","response","get","delete","result","css","map","stats","Buffer","from","buffer","byteOffset","byteLength","error","url","prev","fromImport","importers","Atomics","store","notify","processImporters","then","catch","finally","unref","Promise","innerResult","call","Array","isArray"],"sources":["/Users/deliabarbuta/Documents/An4Sem1/PAW/Proiect/proiect-paw-tadam/Frontend_OceanCross/node_modules/@angular-devkit/build-angular/src/sass/sass-service.js"],"sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SassWorkerImplementation = void 0;\nconst worker_threads_1 = require(\"worker_threads\");\nconst environment_options_1 = require(\"../utils/environment-options\");\n/**\n * The maximum number of Workers that will be created to execute render requests.\n */\nconst MAX_RENDER_WORKERS = environment_options_1.maxWorkers;\n/**\n * A Sass renderer implementation that provides an interface that can be used by Webpack's\n * `sass-loader`. The implementation uses a Worker thread to perform the Sass rendering\n * with the `dart-sass` package.  The `dart-sass` synchronous render function is used within\n * the worker which can be up to two times faster than the asynchronous variant.\n */\nclass SassWorkerImplementation {\n    constructor() {\n        this.workers = [];\n        this.availableWorkers = [];\n        this.requests = new Map();\n        this.idCounter = 1;\n        this.nextWorkerIndex = 0;\n    }\n    /**\n     * Provides information about the Sass implementation.\n     * This mimics enough of the `dart-sass` value to be used with the `sass-loader`.\n     */\n    get info() {\n        return 'dart-sass\\tworker';\n    }\n    /**\n     * The synchronous render function is not used by the `sass-loader`.\n     */\n    renderSync() {\n        throw new Error('Sass renderSync is not supported.');\n    }\n    /**\n     * Asynchronously request a Sass stylesheet to be renderered.\n     *\n     * @param options The `dart-sass` options to use when rendering the stylesheet.\n     * @param callback The function to execute when the rendering is complete.\n     */\n    render(options, callback) {\n        // The `functions`, `logger` and `importer` options are JavaScript functions that cannot be transferred.\n        // If any additional function options are added in the future, they must be excluded as well.\n        const { functions, importer, logger, ...serializableOptions } = options;\n        // The CLI's configuration does not use or expose the ability to defined custom Sass functions\n        if (functions && Object.keys(functions).length > 0) {\n            throw new Error('Sass custom functions are not supported.');\n        }\n        let workerIndex = this.availableWorkers.pop();\n        if (workerIndex === undefined) {\n            if (this.workers.length < MAX_RENDER_WORKERS) {\n                workerIndex = this.workers.length;\n                this.workers.push(this.createWorker());\n            }\n            else {\n                workerIndex = this.nextWorkerIndex++;\n                if (this.nextWorkerIndex >= this.workers.length) {\n                    this.nextWorkerIndex = 0;\n                }\n            }\n        }\n        const request = this.createRequest(workerIndex, callback, importer);\n        this.requests.set(request.id, request);\n        this.workers[workerIndex].postMessage({\n            id: request.id,\n            hasImporter: !!importer,\n            options: serializableOptions,\n        });\n    }\n    /**\n     * Shutdown the Sass render worker.\n     * Executing this method will stop any pending render requests.\n     */\n    close() {\n        for (const worker of this.workers) {\n            try {\n                void worker.terminate();\n            }\n            catch { }\n        }\n        this.requests.clear();\n    }\n    createWorker() {\n        const { port1: mainImporterPort, port2: workerImporterPort } = new worker_threads_1.MessageChannel();\n        const importerSignal = new Int32Array(new SharedArrayBuffer(4));\n        const workerPath = require.resolve('./worker');\n        const worker = new worker_threads_1.Worker(workerPath, {\n            workerData: { workerImporterPort, importerSignal },\n            transferList: [workerImporterPort],\n        });\n        worker.on('message', (response) => {\n            const request = this.requests.get(response.id);\n            if (!request) {\n                return;\n            }\n            this.requests.delete(response.id);\n            this.availableWorkers.push(request.workerIndex);\n            if (response.result) {\n                // The results are expected to be Node.js `Buffer` objects but will each be transferred as\n                // a Uint8Array that does not have the expected `toString` behavior of a `Buffer`.\n                const { css, map, stats } = response.result;\n                const result = {\n                    // This `Buffer.from` override will use the memory directly and avoid making a copy\n                    css: Buffer.from(css.buffer, css.byteOffset, css.byteLength),\n                    stats,\n                };\n                if (map) {\n                    // This `Buffer.from` override will use the memory directly and avoid making a copy\n                    result.map = Buffer.from(map.buffer, map.byteOffset, map.byteLength);\n                }\n                request.callback(undefined, result);\n            }\n            else {\n                request.callback(response.error);\n            }\n        });\n        mainImporterPort.on('message', ({ id, url, prev, fromImport, }) => {\n            const request = this.requests.get(id);\n            if (!(request === null || request === void 0 ? void 0 : request.importers)) {\n                mainImporterPort.postMessage(null);\n                Atomics.store(importerSignal, 0, 1);\n                Atomics.notify(importerSignal, 0);\n                return;\n            }\n            this.processImporters(request.importers, url, prev, fromImport)\n                .then((result) => {\n                mainImporterPort.postMessage(result);\n            })\n                .catch((error) => {\n                mainImporterPort.postMessage(error);\n            })\n                .finally(() => {\n                Atomics.store(importerSignal, 0, 1);\n                Atomics.notify(importerSignal, 0);\n            });\n        });\n        mainImporterPort.unref();\n        return worker;\n    }\n    async processImporters(importers, url, prev, fromImport) {\n        let result = null;\n        for (const importer of importers) {\n            result = await new Promise((resolve) => {\n                // Importers can be both sync and async\n                const innerResult = importer.call({ fromImport }, url, prev, resolve);\n                if (innerResult !== undefined) {\n                    resolve(innerResult);\n                }\n            });\n            if (result) {\n                break;\n            }\n        }\n        return result;\n    }\n    createRequest(workerIndex, callback, importer) {\n        return {\n            id: this.idCounter++,\n            workerIndex,\n            callback,\n            importers: !importer || Array.isArray(importer) ? importer : [importer],\n        };\n    }\n}\nexports.SassWorkerImplementation = SassWorkerImplementation;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}