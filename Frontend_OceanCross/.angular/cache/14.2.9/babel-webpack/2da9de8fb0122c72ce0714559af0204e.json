{"ast":null,"code":"import { decodedMappings, traceSegment, TraceMap } from '@jridgewell/trace-mapping';\nimport { GenMapping, addSegment, setSourceContent, decodedMap, encodedMap } from '@jridgewell/gen-mapping';\nconst SOURCELESS_MAPPING = {\n  source: null,\n  column: null,\n  line: null,\n  name: null,\n  content: null\n};\nconst EMPTY_SOURCES = [];\n\nfunction Source(map, sources, source, content) {\n  return {\n    map,\n    sources,\n    source,\n    content\n  };\n}\n/**\n * MapSource represents a single sourcemap, with the ability to trace mappings into its child nodes\n * (which may themselves be SourceMapTrees).\n */\n\n\nfunction MapSource(map, sources) {\n  return Source(map, sources, '', null);\n}\n/**\n * A \"leaf\" node in the sourcemap tree, representing an original, unmodified source file. Recursive\n * segment tracing ends at the `OriginalSource`.\n */\n\n\nfunction OriginalSource(source, content) {\n  return Source(null, EMPTY_SOURCES, source, content);\n}\n/**\n * traceMappings is only called on the root level SourceMapTree, and begins the process of\n * resolving each mapping in terms of the original source files.\n */\n\n\nfunction traceMappings(tree) {\n  const gen = new GenMapping({\n    file: tree.map.file\n  });\n  const {\n    sources: rootSources,\n    map\n  } = tree;\n  const rootNames = map.names;\n  const rootMappings = decodedMappings(map);\n\n  for (let i = 0; i < rootMappings.length; i++) {\n    const segments = rootMappings[i];\n    let lastSource = null;\n    let lastSourceLine = null;\n    let lastSourceColumn = null;\n\n    for (let j = 0; j < segments.length; j++) {\n      const segment = segments[j];\n      const genCol = segment[0];\n      let traced = SOURCELESS_MAPPING; // 1-length segments only move the current generated column, there's no source information\n      // to gather from it.\n\n      if (segment.length !== 1) {\n        const source = rootSources[segment[1]];\n        traced = originalPositionFor(source, segment[2], segment[3], segment.length === 5 ? rootNames[segment[4]] : ''); // If the trace is invalid, then the trace ran into a sourcemap that doesn't contain a\n        // respective segment into an original source.\n\n        if (traced == null) continue;\n      } // So we traced a segment down into its original source file. Now push a\n      // new segment pointing to this location.\n\n\n      const {\n        column,\n        line,\n        name,\n        content,\n        source\n      } = traced;\n\n      if (line === lastSourceLine && column === lastSourceColumn && source === lastSource) {\n        continue;\n      }\n\n      lastSourceLine = line;\n      lastSourceColumn = column;\n      lastSource = source; // Sigh, TypeScript can't figure out source/line/column are either all null, or all non-null...\n\n      addSegment(gen, i, genCol, source, line, column, name);\n      if (content != null) setSourceContent(gen, source, content);\n    }\n  }\n\n  return gen;\n}\n/**\n * originalPositionFor is only called on children SourceMapTrees. It recurses down into its own\n * child SourceMapTrees, until we find the original source map.\n */\n\n\nfunction originalPositionFor(source, line, column, name) {\n  if (!source.map) {\n    return {\n      column,\n      line,\n      name,\n      source: source.source,\n      content: source.content\n    };\n  }\n\n  const segment = traceSegment(source.map, line, column); // If we couldn't find a segment, then this doesn't exist in the sourcemap.\n\n  if (segment == null) return null; // 1-length segments only move the current generated column, there's no source information\n  // to gather from it.\n\n  if (segment.length === 1) return SOURCELESS_MAPPING;\n  return originalPositionFor(source.sources[segment[1]], segment[2], segment[3], segment.length === 5 ? source.map.names[segment[4]] : name);\n}\n\nfunction asArray(value) {\n  if (Array.isArray(value)) return value;\n  return [value];\n}\n/**\n * Recursively builds a tree structure out of sourcemap files, with each node\n * being either an `OriginalSource` \"leaf\" or a `SourceMapTree` composed of\n * `OriginalSource`s and `SourceMapTree`s.\n *\n * Every sourcemap is composed of a collection of source files and mappings\n * into locations of those source files. When we generate a `SourceMapTree` for\n * the sourcemap, we attempt to load each source file's own sourcemap. If it\n * does not have an associated sourcemap, it is considered an original,\n * unmodified source file.\n */\n\n\nfunction buildSourceMapTree(input, loader) {\n  const maps = asArray(input).map(m => new TraceMap(m, ''));\n  const map = maps.pop();\n\n  for (let i = 0; i < maps.length; i++) {\n    if (maps[i].sources.length > 1) {\n      throw new Error(`Transformation map ${i} must have exactly one source file.\\n` + 'Did you specify these with the most recent transformation maps first?');\n    }\n  }\n\n  let tree = build(map, loader, '', 0);\n\n  for (let i = maps.length - 1; i >= 0; i--) {\n    tree = MapSource(maps[i], [tree]);\n  }\n\n  return tree;\n}\n\nfunction build(map, loader, importer, importerDepth) {\n  const {\n    resolvedSources,\n    sourcesContent\n  } = map;\n  const depth = importerDepth + 1;\n  const children = resolvedSources.map((sourceFile, i) => {\n    // The loading context gives the loader more information about why this file is being loaded\n    // (eg, from which importer). It also allows the loader to override the location of the loaded\n    // sourcemap/original source, or to override the content in the sourcesContent field if it's\n    // an unmodified source file.\n    const ctx = {\n      importer,\n      depth,\n      source: sourceFile || '',\n      content: undefined\n    }; // Use the provided loader callback to retrieve the file's sourcemap.\n    // TODO: We should eventually support async loading of sourcemap files.\n\n    const sourceMap = loader(ctx.source, ctx);\n    const {\n      source,\n      content\n    } = ctx; // If there is a sourcemap, then we need to recurse into it to load its source files.\n\n    if (sourceMap) return build(new TraceMap(sourceMap, source), loader, source, depth); // Else, it's an an unmodified source file.\n    // The contents of this unmodified source file can be overridden via the loader context,\n    // allowing it to be explicitly null or a string. If it remains undefined, we fall back to\n    // the importing sourcemap's `sourcesContent` field.\n\n    const sourceContent = content !== undefined ? content : sourcesContent ? sourcesContent[i] : null;\n    return OriginalSource(source, sourceContent);\n  });\n  return MapSource(map, children);\n}\n/**\n * A SourceMap v3 compatible sourcemap, which only includes fields that were\n * provided to it.\n */\n\n\nclass SourceMap {\n  constructor(map, options) {\n    const out = options.decodedMappings ? decodedMap(map) : encodedMap(map);\n    this.version = out.version; // SourceMap spec says this should be first.\n\n    this.file = out.file;\n    this.mappings = out.mappings;\n    this.names = out.names;\n    this.sourceRoot = out.sourceRoot;\n    this.sources = out.sources;\n\n    if (!options.excludeContent) {\n      this.sourcesContent = out.sourcesContent;\n    }\n  }\n\n  toString() {\n    return JSON.stringify(this);\n  }\n\n}\n/**\n * Traces through all the mappings in the root sourcemap, through the sources\n * (and their sourcemaps), all the way back to the original source location.\n *\n * `loader` will be called every time we encounter a source file. If it returns\n * a sourcemap, we will recurse into that sourcemap to continue the trace. If\n * it returns a falsey value, that source file is treated as an original,\n * unmodified source file.\n *\n * Pass `excludeContent` to exclude any self-containing source file content\n * from the output sourcemap.\n *\n * Pass `decodedMappings` to receive a SourceMap with decoded (instead of\n * VLQ encoded) mappings.\n */\n\n\nfunction remapping(input, loader, options) {\n  const opts = typeof options === 'object' ? options : {\n    excludeContent: !!options,\n    decodedMappings: false\n  };\n  const tree = buildSourceMapTree(input, loader);\n  return new SourceMap(traceMappings(tree), opts);\n}\n\nexport { remapping as default };","map":{"version":3,"names":["decodedMappings","traceSegment","TraceMap","GenMapping","addSegment","setSourceContent","decodedMap","encodedMap","SOURCELESS_MAPPING","source","column","line","name","content","EMPTY_SOURCES","Source","map","sources","MapSource","OriginalSource","traceMappings","tree","gen","file","rootSources","rootNames","names","rootMappings","i","length","segments","lastSource","lastSourceLine","lastSourceColumn","j","segment","genCol","traced","originalPositionFor","asArray","value","Array","isArray","buildSourceMapTree","input","loader","maps","m","pop","Error","build","importer","importerDepth","resolvedSources","sourcesContent","depth","children","sourceFile","ctx","undefined","sourceMap","sourceContent","SourceMap","constructor","options","out","version","mappings","sourceRoot","excludeContent","toString","JSON","stringify","remapping","opts","default"],"sources":["/Users/deliabarbuta/Documents/An4Sem1/PAW/Proiect/proiect-paw-tadam/Frontend_OceanCross/node_modules/@ampproject/remapping/dist/remapping.mjs"],"sourcesContent":["import { decodedMappings, traceSegment, TraceMap } from '@jridgewell/trace-mapping';\nimport { GenMapping, addSegment, setSourceContent, decodedMap, encodedMap } from '@jridgewell/gen-mapping';\n\nconst SOURCELESS_MAPPING = {\n    source: null,\n    column: null,\n    line: null,\n    name: null,\n    content: null,\n};\nconst EMPTY_SOURCES = [];\nfunction Source(map, sources, source, content) {\n    return {\n        map,\n        sources,\n        source,\n        content,\n    };\n}\n/**\n * MapSource represents a single sourcemap, with the ability to trace mappings into its child nodes\n * (which may themselves be SourceMapTrees).\n */\nfunction MapSource(map, sources) {\n    return Source(map, sources, '', null);\n}\n/**\n * A \"leaf\" node in the sourcemap tree, representing an original, unmodified source file. Recursive\n * segment tracing ends at the `OriginalSource`.\n */\nfunction OriginalSource(source, content) {\n    return Source(null, EMPTY_SOURCES, source, content);\n}\n/**\n * traceMappings is only called on the root level SourceMapTree, and begins the process of\n * resolving each mapping in terms of the original source files.\n */\nfunction traceMappings(tree) {\n    const gen = new GenMapping({ file: tree.map.file });\n    const { sources: rootSources, map } = tree;\n    const rootNames = map.names;\n    const rootMappings = decodedMappings(map);\n    for (let i = 0; i < rootMappings.length; i++) {\n        const segments = rootMappings[i];\n        let lastSource = null;\n        let lastSourceLine = null;\n        let lastSourceColumn = null;\n        for (let j = 0; j < segments.length; j++) {\n            const segment = segments[j];\n            const genCol = segment[0];\n            let traced = SOURCELESS_MAPPING;\n            // 1-length segments only move the current generated column, there's no source information\n            // to gather from it.\n            if (segment.length !== 1) {\n                const source = rootSources[segment[1]];\n                traced = originalPositionFor(source, segment[2], segment[3], segment.length === 5 ? rootNames[segment[4]] : '');\n                // If the trace is invalid, then the trace ran into a sourcemap that doesn't contain a\n                // respective segment into an original source.\n                if (traced == null)\n                    continue;\n            }\n            // So we traced a segment down into its original source file. Now push a\n            // new segment pointing to this location.\n            const { column, line, name, content, source } = traced;\n            if (line === lastSourceLine && column === lastSourceColumn && source === lastSource) {\n                continue;\n            }\n            lastSourceLine = line;\n            lastSourceColumn = column;\n            lastSource = source;\n            // Sigh, TypeScript can't figure out source/line/column are either all null, or all non-null...\n            addSegment(gen, i, genCol, source, line, column, name);\n            if (content != null)\n                setSourceContent(gen, source, content);\n        }\n    }\n    return gen;\n}\n/**\n * originalPositionFor is only called on children SourceMapTrees. It recurses down into its own\n * child SourceMapTrees, until we find the original source map.\n */\nfunction originalPositionFor(source, line, column, name) {\n    if (!source.map) {\n        return { column, line, name, source: source.source, content: source.content };\n    }\n    const segment = traceSegment(source.map, line, column);\n    // If we couldn't find a segment, then this doesn't exist in the sourcemap.\n    if (segment == null)\n        return null;\n    // 1-length segments only move the current generated column, there's no source information\n    // to gather from it.\n    if (segment.length === 1)\n        return SOURCELESS_MAPPING;\n    return originalPositionFor(source.sources[segment[1]], segment[2], segment[3], segment.length === 5 ? source.map.names[segment[4]] : name);\n}\n\nfunction asArray(value) {\n    if (Array.isArray(value))\n        return value;\n    return [value];\n}\n/**\n * Recursively builds a tree structure out of sourcemap files, with each node\n * being either an `OriginalSource` \"leaf\" or a `SourceMapTree` composed of\n * `OriginalSource`s and `SourceMapTree`s.\n *\n * Every sourcemap is composed of a collection of source files and mappings\n * into locations of those source files. When we generate a `SourceMapTree` for\n * the sourcemap, we attempt to load each source file's own sourcemap. If it\n * does not have an associated sourcemap, it is considered an original,\n * unmodified source file.\n */\nfunction buildSourceMapTree(input, loader) {\n    const maps = asArray(input).map((m) => new TraceMap(m, ''));\n    const map = maps.pop();\n    for (let i = 0; i < maps.length; i++) {\n        if (maps[i].sources.length > 1) {\n            throw new Error(`Transformation map ${i} must have exactly one source file.\\n` +\n                'Did you specify these with the most recent transformation maps first?');\n        }\n    }\n    let tree = build(map, loader, '', 0);\n    for (let i = maps.length - 1; i >= 0; i--) {\n        tree = MapSource(maps[i], [tree]);\n    }\n    return tree;\n}\nfunction build(map, loader, importer, importerDepth) {\n    const { resolvedSources, sourcesContent } = map;\n    const depth = importerDepth + 1;\n    const children = resolvedSources.map((sourceFile, i) => {\n        // The loading context gives the loader more information about why this file is being loaded\n        // (eg, from which importer). It also allows the loader to override the location of the loaded\n        // sourcemap/original source, or to override the content in the sourcesContent field if it's\n        // an unmodified source file.\n        const ctx = {\n            importer,\n            depth,\n            source: sourceFile || '',\n            content: undefined,\n        };\n        // Use the provided loader callback to retrieve the file's sourcemap.\n        // TODO: We should eventually support async loading of sourcemap files.\n        const sourceMap = loader(ctx.source, ctx);\n        const { source, content } = ctx;\n        // If there is a sourcemap, then we need to recurse into it to load its source files.\n        if (sourceMap)\n            return build(new TraceMap(sourceMap, source), loader, source, depth);\n        // Else, it's an an unmodified source file.\n        // The contents of this unmodified source file can be overridden via the loader context,\n        // allowing it to be explicitly null or a string. If it remains undefined, we fall back to\n        // the importing sourcemap's `sourcesContent` field.\n        const sourceContent = content !== undefined ? content : sourcesContent ? sourcesContent[i] : null;\n        return OriginalSource(source, sourceContent);\n    });\n    return MapSource(map, children);\n}\n\n/**\n * A SourceMap v3 compatible sourcemap, which only includes fields that were\n * provided to it.\n */\nclass SourceMap {\n    constructor(map, options) {\n        const out = options.decodedMappings ? decodedMap(map) : encodedMap(map);\n        this.version = out.version; // SourceMap spec says this should be first.\n        this.file = out.file;\n        this.mappings = out.mappings;\n        this.names = out.names;\n        this.sourceRoot = out.sourceRoot;\n        this.sources = out.sources;\n        if (!options.excludeContent) {\n            this.sourcesContent = out.sourcesContent;\n        }\n    }\n    toString() {\n        return JSON.stringify(this);\n    }\n}\n\n/**\n * Traces through all the mappings in the root sourcemap, through the sources\n * (and their sourcemaps), all the way back to the original source location.\n *\n * `loader` will be called every time we encounter a source file. If it returns\n * a sourcemap, we will recurse into that sourcemap to continue the trace. If\n * it returns a falsey value, that source file is treated as an original,\n * unmodified source file.\n *\n * Pass `excludeContent` to exclude any self-containing source file content\n * from the output sourcemap.\n *\n * Pass `decodedMappings` to receive a SourceMap with decoded (instead of\n * VLQ encoded) mappings.\n */\nfunction remapping(input, loader, options) {\n    const opts = typeof options === 'object' ? options : { excludeContent: !!options, decodedMappings: false };\n    const tree = buildSourceMapTree(input, loader);\n    return new SourceMap(traceMappings(tree), opts);\n}\n\nexport { remapping as default };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}