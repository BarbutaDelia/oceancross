{"ast":null,"code":"\"use strict\";\n\nconst WebSocket = require(\"ws\");\n\nconst BaseServer = require(\"./BaseServer\");\n/** @typedef {import(\"../Server\").WebSocketServerConfiguration} WebSocketServerConfiguration */\n\n/** @typedef {import(\"../Server\").ClientConnection} ClientConnection */\n\n\nmodule.exports = class WebsocketServer extends BaseServer {\n  static heartbeatInterval = 1000;\n  /**\n   * @param {import(\"../Server\")} server\n   */\n\n  constructor(server) {\n    super(server);\n    /** @type {import(\"ws\").ServerOptions} */\n\n    const options = { ...\n      /** @type {WebSocketServerConfiguration} */\n      this.server.options.webSocketServer.options,\n      clientTracking: false\n    };\n    const isNoServerMode = typeof options.port === \"undefined\" && typeof options.server === \"undefined\";\n\n    if (isNoServerMode) {\n      options.noServer = true;\n    }\n\n    this.implementation = new WebSocket.Server(options);\n    /** @type {import(\"http\").Server} */\n\n    this.server.server.on(\"upgrade\",\n    /**\n     * @param {import(\"http\").IncomingMessage} req\n     * @param {import(\"stream\").Duplex} sock\n     * @param {Buffer} head\n     */\n    (req, sock, head) => {\n      if (!this.implementation.shouldHandle(req)) {\n        return;\n      }\n\n      this.implementation.handleUpgrade(req, sock, head, connection => {\n        this.implementation.emit(\"connection\", connection, req);\n      });\n    });\n    this.implementation.on(\"error\",\n    /**\n     * @param {Error} err\n     */\n    err => {\n      this.server.logger.error(err.message);\n    });\n    const interval = setInterval(() => {\n      this.clients.forEach(\n      /**\n       * @param {ClientConnection} client\n       */\n      client => {\n        if (client.isAlive === false) {\n          client.terminate();\n          return;\n        }\n\n        client.isAlive = false;\n        client.ping(() => {});\n      });\n    }, WebsocketServer.heartbeatInterval);\n    this.implementation.on(\"connection\",\n    /**\n     * @param {ClientConnection} client\n     */\n    client => {\n      this.clients.push(client);\n      client.isAlive = true;\n      client.on(\"pong\", () => {\n        client.isAlive = true;\n      });\n      client.on(\"close\", () => {\n        this.clients.splice(this.clients.indexOf(client), 1);\n      });\n    });\n    this.implementation.on(\"close\", () => {\n      clearInterval(interval);\n    });\n  }\n\n};","map":{"version":3,"names":["WebSocket","require","BaseServer","module","exports","WebsocketServer","heartbeatInterval","constructor","server","options","webSocketServer","clientTracking","isNoServerMode","port","noServer","implementation","Server","on","req","sock","head","shouldHandle","handleUpgrade","connection","emit","err","logger","error","message","interval","setInterval","clients","forEach","client","isAlive","terminate","ping","push","splice","indexOf","clearInterval"],"sources":["/Users/deliabarbuta/Documents/An4Sem1/PAW/Proiect/proiect-paw-tadam/Frontend_OceanCross/node_modules/webpack-dev-server/lib/servers/WebsocketServer.js"],"sourcesContent":["\"use strict\";\n\nconst WebSocket = require(\"ws\");\nconst BaseServer = require(\"./BaseServer\");\n\n/** @typedef {import(\"../Server\").WebSocketServerConfiguration} WebSocketServerConfiguration */\n/** @typedef {import(\"../Server\").ClientConnection} ClientConnection */\n\nmodule.exports = class WebsocketServer extends BaseServer {\n  static heartbeatInterval = 1000;\n\n  /**\n   * @param {import(\"../Server\")} server\n   */\n  constructor(server) {\n    super(server);\n\n    /** @type {import(\"ws\").ServerOptions} */\n    const options = {\n      .../** @type {WebSocketServerConfiguration} */\n      (this.server.options.webSocketServer).options,\n      clientTracking: false,\n    };\n    const isNoServerMode =\n      typeof options.port === \"undefined\" &&\n      typeof options.server === \"undefined\";\n\n    if (isNoServerMode) {\n      options.noServer = true;\n    }\n\n    this.implementation = new WebSocket.Server(options);\n\n    /** @type {import(\"http\").Server} */\n    (this.server.server).on(\n      \"upgrade\",\n      /**\n       * @param {import(\"http\").IncomingMessage} req\n       * @param {import(\"stream\").Duplex} sock\n       * @param {Buffer} head\n       */\n      (req, sock, head) => {\n        if (!this.implementation.shouldHandle(req)) {\n          return;\n        }\n\n        this.implementation.handleUpgrade(req, sock, head, (connection) => {\n          this.implementation.emit(\"connection\", connection, req);\n        });\n      }\n    );\n\n    this.implementation.on(\n      \"error\",\n      /**\n       * @param {Error} err\n       */\n      (err) => {\n        this.server.logger.error(err.message);\n      }\n    );\n\n    const interval = setInterval(() => {\n      this.clients.forEach(\n        /**\n         * @param {ClientConnection} client\n         */\n        (client) => {\n          if (client.isAlive === false) {\n            client.terminate();\n\n            return;\n          }\n\n          client.isAlive = false;\n          client.ping(() => {});\n        }\n      );\n    }, WebsocketServer.heartbeatInterval);\n\n    this.implementation.on(\n      \"connection\",\n      /**\n       * @param {ClientConnection} client\n       */\n      (client) => {\n        this.clients.push(client);\n\n        client.isAlive = true;\n\n        client.on(\"pong\", () => {\n          client.isAlive = true;\n        });\n\n        client.on(\"close\", () => {\n          this.clients.splice(this.clients.indexOf(client), 1);\n        });\n      }\n    );\n\n    this.implementation.on(\"close\", () => {\n      clearInterval(interval);\n    });\n  }\n};\n"],"mappings":"AAAA;;AAEA,MAAMA,SAAS,GAAGC,OAAO,CAAC,IAAD,CAAzB;;AACA,MAAMC,UAAU,GAAGD,OAAO,CAAC,cAAD,CAA1B;AAEA;;AACA;;;AAEAE,MAAM,CAACC,OAAP,GAAiB,MAAMC,eAAN,SAA8BH,UAA9B,CAAyC;EAChC,OAAjBI,iBAAiB,GAAG,IAAH;EAExB;AACF;AACA;;EACEC,WAAW,CAACC,MAAD,EAAS;IAClB,MAAMA,MAAN;IAEA;;IACA,MAAMC,OAAO,GAAG,EACd;MAAG;MACF,KAAKD,MAAL,CAAYC,OAAZ,CAAoBC,eAArB,CAAsCD,OAFxB;MAGdE,cAAc,EAAE;IAHF,CAAhB;IAKA,MAAMC,cAAc,GAClB,OAAOH,OAAO,CAACI,IAAf,KAAwB,WAAxB,IACA,OAAOJ,OAAO,CAACD,MAAf,KAA0B,WAF5B;;IAIA,IAAII,cAAJ,EAAoB;MAClBH,OAAO,CAACK,QAAR,GAAmB,IAAnB;IACD;;IAED,KAAKC,cAAL,GAAsB,IAAIf,SAAS,CAACgB,MAAd,CAAqBP,OAArB,CAAtB;IAEA;;IACC,KAAKD,MAAL,CAAYA,MAAb,CAAqBS,EAArB,CACE,SADF;IAEE;AACN;AACA;AACA;AACA;IACM,CAACC,GAAD,EAAMC,IAAN,EAAYC,IAAZ,KAAqB;MACnB,IAAI,CAAC,KAAKL,cAAL,CAAoBM,YAApB,CAAiCH,GAAjC,CAAL,EAA4C;QAC1C;MACD;;MAED,KAAKH,cAAL,CAAoBO,aAApB,CAAkCJ,GAAlC,EAAuCC,IAAvC,EAA6CC,IAA7C,EAAoDG,UAAD,IAAgB;QACjE,KAAKR,cAAL,CAAoBS,IAApB,CAAyB,YAAzB,EAAuCD,UAAvC,EAAmDL,GAAnD;MACD,CAFD;IAGD,CAfH;IAkBA,KAAKH,cAAL,CAAoBE,EAApB,CACE,OADF;IAEE;AACN;AACA;IACOQ,GAAD,IAAS;MACP,KAAKjB,MAAL,CAAYkB,MAAZ,CAAmBC,KAAnB,CAAyBF,GAAG,CAACG,OAA7B;IACD,CAPH;IAUA,MAAMC,QAAQ,GAAGC,WAAW,CAAC,MAAM;MACjC,KAAKC,OAAL,CAAaC,OAAb;MACE;AACR;AACA;MACSC,MAAD,IAAY;QACV,IAAIA,MAAM,CAACC,OAAP,KAAmB,KAAvB,EAA8B;UAC5BD,MAAM,CAACE,SAAP;UAEA;QACD;;QAEDF,MAAM,CAACC,OAAP,GAAiB,KAAjB;QACAD,MAAM,CAACG,IAAP,CAAY,MAAM,CAAE,CAApB;MACD,CAbH;IAeD,CAhB2B,EAgBzB/B,eAAe,CAACC,iBAhBS,CAA5B;IAkBA,KAAKS,cAAL,CAAoBE,EAApB,CACE,YADF;IAEE;AACN;AACA;IACOgB,MAAD,IAAY;MACV,KAAKF,OAAL,CAAaM,IAAb,CAAkBJ,MAAlB;MAEAA,MAAM,CAACC,OAAP,GAAiB,IAAjB;MAEAD,MAAM,CAAChB,EAAP,CAAU,MAAV,EAAkB,MAAM;QACtBgB,MAAM,CAACC,OAAP,GAAiB,IAAjB;MACD,CAFD;MAIAD,MAAM,CAAChB,EAAP,CAAU,OAAV,EAAmB,MAAM;QACvB,KAAKc,OAAL,CAAaO,MAAb,CAAoB,KAAKP,OAAL,CAAaQ,OAAb,CAAqBN,MAArB,CAApB,EAAkD,CAAlD;MACD,CAFD;IAGD,CAjBH;IAoBA,KAAKlB,cAAL,CAAoBE,EAApB,CAAuB,OAAvB,EAAgC,MAAM;MACpCuB,aAAa,CAACX,QAAD,CAAb;IACD,CAFD;EAGD;;AA/FuD,CAA1D"},"metadata":{},"sourceType":"script"}