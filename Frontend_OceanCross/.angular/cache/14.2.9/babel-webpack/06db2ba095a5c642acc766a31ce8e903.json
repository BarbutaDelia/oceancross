{"ast":null,"code":"const path = require('path');\n\nconst log = require('../logger').create('launcher');\n\nconst env = process.env;\n\nfunction ProcessLauncher(spawn, tempDir, timer, processKillTimeout) {\n  const self = this;\n  let onExitCallback;\n  const killTimeout = processKillTimeout || 2000; // Will hold output from the spawned child process\n\n  const streamedOutputs = {\n    stdout: '',\n    stderr: ''\n  };\n  this._tempDir = tempDir.getPath(`/karma-${this.id.toString()}`);\n  this.on('start', function (url) {\n    tempDir.create(self._tempDir);\n\n    self._start(url);\n  });\n  this.on('kill', function (done) {\n    if (!self._process) {\n      return process.nextTick(done);\n    }\n\n    onExitCallback = done;\n\n    self._process.kill();\n\n    self._killTimer = timer.setTimeout(self._onKillTimeout, killTimeout);\n  });\n\n  this._start = function (url) {\n    self._execCommand(self._getCommand(), self._getOptions(url));\n  };\n\n  this._getCommand = function () {\n    return env[self.ENV_CMD] || self.DEFAULT_CMD[process.platform];\n  };\n\n  this._getOptions = function (url) {\n    return [url];\n  }; // Normalize the command, remove quotes (spawn does not like them).\n\n\n  this._normalizeCommand = function (cmd) {\n    if (cmd.charAt(0) === cmd.charAt(cmd.length - 1) && '\\'`\"'.includes(cmd.charAt(0))) {\n      cmd = cmd.slice(1, -1);\n      log.warn(`The path should not be quoted.\\n  Normalized the path to ${cmd}`);\n    }\n\n    return path.normalize(cmd);\n  };\n\n  this._onStdout = function (data) {\n    streamedOutputs.stdout += data;\n  };\n\n  this._onStderr = function (data) {\n    streamedOutputs.stderr += data;\n  };\n\n  this._execCommand = function (cmd, args) {\n    if (!cmd) {\n      log.error(`No binary for ${self.name} browser on your platform.\\n  Please, set \"${self.ENV_CMD}\" env variable.`); // disable restarting\n\n      self._retryLimit = -1;\n      return self._clearTempDirAndReportDone('no binary');\n    }\n\n    cmd = this._normalizeCommand(cmd);\n    log.debug(cmd + ' ' + args.join(' '));\n    self._process = spawn(cmd, args);\n    let errorOutput = '';\n\n    self._process.stdout.on('data', self._onStdout);\n\n    self._process.stderr.on('data', self._onStderr);\n\n    self._process.on('exit', function (code, signal) {\n      self._onProcessExit(code, signal, errorOutput);\n    });\n\n    self._process.on('error', function (err) {\n      if (err.code === 'ENOENT') {\n        self._retryLimit = -1;\n        errorOutput = `Can not find the binary ${cmd}\\n\\tPlease set env variable ${self.ENV_CMD}`;\n      } else if (err.code === 'EACCES') {\n        self._retryLimit = -1;\n        errorOutput = `Permission denied accessing the binary ${cmd}\\n\\tMaybe it's a directory?`;\n      } else {\n        errorOutput += err.toString();\n      }\n\n      self._onProcessExit(-1, null, errorOutput);\n    });\n\n    self._process.stderr.on('data', function (errBuff) {\n      errorOutput += errBuff.toString();\n    });\n  };\n\n  this._onProcessExit = function (code, signal, errorOutput) {\n    if (!self._process) {\n      // Both exit and error events trigger _onProcessExit(), but we only need one cleanup.\n      return;\n    }\n\n    log.debug(`Process ${self.name} exited with code ${code} and signal ${signal}`);\n    let error = null;\n\n    if (self.state === self.STATE_BEING_CAPTURED) {\n      log.error(`Cannot start ${self.name}\\n\\t${errorOutput}`);\n      error = 'cannot start';\n    }\n\n    if (self.state === self.STATE_CAPTURED) {\n      log.error(`${self.name} crashed.\\n\\t${errorOutput}`);\n      error = 'crashed';\n    }\n\n    if (error) {\n      log.error(`${self.name} stdout: ${streamedOutputs.stdout}`);\n      log.error(`${self.name} stderr: ${streamedOutputs.stderr}`);\n    }\n\n    self._process = null;\n    streamedOutputs.stdout = '';\n    streamedOutputs.stderr = '';\n\n    if (self._killTimer) {\n      timer.clearTimeout(self._killTimer);\n      self._killTimer = null;\n    }\n\n    self._clearTempDirAndReportDone(error);\n  };\n\n  this._clearTempDirAndReportDone = function (error) {\n    tempDir.remove(self._tempDir, function () {\n      self._done(error);\n\n      if (onExitCallback) {\n        onExitCallback();\n        onExitCallback = null;\n      }\n    });\n  };\n\n  this._onKillTimeout = function () {\n    if (self.state !== self.STATE_BEING_KILLED && self.state !== self.STATE_BEING_FORCE_KILLED) {\n      return;\n    }\n\n    log.warn(`${self.name} was not killed in ${killTimeout} ms, sending SIGKILL.`);\n\n    self._process.kill('SIGKILL'); // NOTE: https://github.com/karma-runner/karma/pull/1184\n    // NOTE: SIGKILL is just a signal.  Processes should never ignore it, but they can.\n    // If a process gets into a state where it doesn't respond in a reasonable amount of time\n    // Karma should warn, and continue as though the kill succeeded.\n    // This a certainly suboptimal, but it is better than having the test harness hang waiting\n    // for a zombie child process to exit.\n\n\n    self._killTimer = timer.setTimeout(function () {\n      log.warn(`${self.name} was not killed by SIGKILL in ${killTimeout} ms, continuing.`);\n\n      self._onProcessExit(-1, null, '');\n    }, killTimeout);\n  };\n}\n\nProcessLauncher.decoratorFactory = function (timer) {\n  return function (launcher, processKillTimeout) {\n    const spawn = require('child_process').spawn;\n\n    function spawnWithoutOutput() {\n      const proc = spawn.apply(null, arguments);\n      proc.stdout.resume();\n      proc.stderr.resume();\n      return proc;\n    }\n\n    ProcessLauncher.call(launcher, spawnWithoutOutput, require('../temp_dir'), timer, processKillTimeout);\n  };\n};\n\nmodule.exports = ProcessLauncher;","map":{"version":3,"names":["path","require","log","create","env","process","ProcessLauncher","spawn","tempDir","timer","processKillTimeout","self","onExitCallback","killTimeout","streamedOutputs","stdout","stderr","_tempDir","getPath","id","toString","on","url","_start","done","_process","nextTick","kill","_killTimer","setTimeout","_onKillTimeout","_execCommand","_getCommand","_getOptions","ENV_CMD","DEFAULT_CMD","platform","_normalizeCommand","cmd","charAt","length","includes","slice","warn","normalize","_onStdout","data","_onStderr","args","error","name","_retryLimit","_clearTempDirAndReportDone","debug","join","errorOutput","code","signal","_onProcessExit","err","errBuff","state","STATE_BEING_CAPTURED","STATE_CAPTURED","clearTimeout","remove","_done","STATE_BEING_KILLED","STATE_BEING_FORCE_KILLED","decoratorFactory","launcher","spawnWithoutOutput","proc","apply","arguments","resume","call","module","exports"],"sources":["/Users/deliabarbuta/Documents/An4Sem1/PAW/Proiect/proiect-paw-tadam/Frontend_OceanCross/node_modules/karma/lib/launchers/process.js"],"sourcesContent":["const path = require('path')\nconst log = require('../logger').create('launcher')\nconst env = process.env\n\nfunction ProcessLauncher (spawn, tempDir, timer, processKillTimeout) {\n  const self = this\n  let onExitCallback\n  const killTimeout = processKillTimeout || 2000\n  // Will hold output from the spawned child process\n  const streamedOutputs = {\n    stdout: '',\n    stderr: ''\n  }\n\n  this._tempDir = tempDir.getPath(`/karma-${this.id.toString()}`)\n\n  this.on('start', function (url) {\n    tempDir.create(self._tempDir)\n    self._start(url)\n  })\n\n  this.on('kill', function (done) {\n    if (!self._process) {\n      return process.nextTick(done)\n    }\n\n    onExitCallback = done\n    self._process.kill()\n    self._killTimer = timer.setTimeout(self._onKillTimeout, killTimeout)\n  })\n\n  this._start = function (url) {\n    self._execCommand(self._getCommand(), self._getOptions(url))\n  }\n\n  this._getCommand = function () {\n    return env[self.ENV_CMD] || self.DEFAULT_CMD[process.platform]\n  }\n\n  this._getOptions = function (url) {\n    return [url]\n  }\n\n  // Normalize the command, remove quotes (spawn does not like them).\n  this._normalizeCommand = function (cmd) {\n    if (cmd.charAt(0) === cmd.charAt(cmd.length - 1) && '\\'`\"'.includes(cmd.charAt(0))) {\n      cmd = cmd.slice(1, -1)\n      log.warn(`The path should not be quoted.\\n  Normalized the path to ${cmd}`)\n    }\n\n    return path.normalize(cmd)\n  }\n\n  this._onStdout = function (data) {\n    streamedOutputs.stdout += data\n  }\n\n  this._onStderr = function (data) {\n    streamedOutputs.stderr += data\n  }\n\n  this._execCommand = function (cmd, args) {\n    if (!cmd) {\n      log.error(`No binary for ${self.name} browser on your platform.\\n  Please, set \"${self.ENV_CMD}\" env variable.`)\n\n      // disable restarting\n      self._retryLimit = -1\n\n      return self._clearTempDirAndReportDone('no binary')\n    }\n\n    cmd = this._normalizeCommand(cmd)\n\n    log.debug(cmd + ' ' + args.join(' '))\n    self._process = spawn(cmd, args)\n    let errorOutput = ''\n\n    self._process.stdout.on('data', self._onStdout)\n\n    self._process.stderr.on('data', self._onStderr)\n\n    self._process.on('exit', function (code, signal) {\n      self._onProcessExit(code, signal, errorOutput)\n    })\n\n    self._process.on('error', function (err) {\n      if (err.code === 'ENOENT') {\n        self._retryLimit = -1\n        errorOutput = `Can not find the binary ${cmd}\\n\\tPlease set env variable ${self.ENV_CMD}`\n      } else if (err.code === 'EACCES') {\n        self._retryLimit = -1\n        errorOutput = `Permission denied accessing the binary ${cmd}\\n\\tMaybe it's a directory?`\n      } else {\n        errorOutput += err.toString()\n      }\n      self._onProcessExit(-1, null, errorOutput)\n    })\n\n    self._process.stderr.on('data', function (errBuff) {\n      errorOutput += errBuff.toString()\n    })\n  }\n\n  this._onProcessExit = function (code, signal, errorOutput) {\n    if (!self._process) {\n      // Both exit and error events trigger _onProcessExit(), but we only need one cleanup.\n      return\n    }\n    log.debug(`Process ${self.name} exited with code ${code} and signal ${signal}`)\n\n    let error = null\n\n    if (self.state === self.STATE_BEING_CAPTURED) {\n      log.error(`Cannot start ${self.name}\\n\\t${errorOutput}`)\n      error = 'cannot start'\n    }\n\n    if (self.state === self.STATE_CAPTURED) {\n      log.error(`${self.name} crashed.\\n\\t${errorOutput}`)\n      error = 'crashed'\n    }\n\n    if (error) {\n      log.error(`${self.name} stdout: ${streamedOutputs.stdout}`)\n      log.error(`${self.name} stderr: ${streamedOutputs.stderr}`)\n    }\n\n    self._process = null\n    streamedOutputs.stdout = ''\n    streamedOutputs.stderr = ''\n    if (self._killTimer) {\n      timer.clearTimeout(self._killTimer)\n      self._killTimer = null\n    }\n    self._clearTempDirAndReportDone(error)\n  }\n\n  this._clearTempDirAndReportDone = function (error) {\n    tempDir.remove(self._tempDir, function () {\n      self._done(error)\n      if (onExitCallback) {\n        onExitCallback()\n        onExitCallback = null\n      }\n    })\n  }\n\n  this._onKillTimeout = function () {\n    if (self.state !== self.STATE_BEING_KILLED && self.state !== self.STATE_BEING_FORCE_KILLED) {\n      return\n    }\n\n    log.warn(`${self.name} was not killed in ${killTimeout} ms, sending SIGKILL.`)\n    self._process.kill('SIGKILL')\n\n    // NOTE: https://github.com/karma-runner/karma/pull/1184\n    // NOTE: SIGKILL is just a signal.  Processes should never ignore it, but they can.\n    // If a process gets into a state where it doesn't respond in a reasonable amount of time\n    // Karma should warn, and continue as though the kill succeeded.\n    // This a certainly suboptimal, but it is better than having the test harness hang waiting\n    // for a zombie child process to exit.\n    self._killTimer = timer.setTimeout(function () {\n      log.warn(`${self.name} was not killed by SIGKILL in ${killTimeout} ms, continuing.`)\n      self._onProcessExit(-1, null, '')\n    }, killTimeout)\n  }\n}\n\nProcessLauncher.decoratorFactory = function (timer) {\n  return function (launcher, processKillTimeout) {\n    const spawn = require('child_process').spawn\n\n    function spawnWithoutOutput () {\n      const proc = spawn.apply(null, arguments)\n      proc.stdout.resume()\n      proc.stderr.resume()\n\n      return proc\n    }\n\n    ProcessLauncher.call(launcher, spawnWithoutOutput, require('../temp_dir'), timer, processKillTimeout)\n  }\n}\n\nmodule.exports = ProcessLauncher\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}