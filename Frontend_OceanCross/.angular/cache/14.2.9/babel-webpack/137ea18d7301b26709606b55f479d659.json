{"ast":null,"code":"'use strict';\n\nconst {\n  Transform\n} = require('stream');\n\nconst Tokenizer = require('parse5/lib/tokenizer');\n\nconst LocationInfoTokenizerMixin = require('parse5/lib/extensions/location-info/tokenizer-mixin');\n\nconst Mixin = require('parse5/lib/utils/mixin');\n\nconst mergeOptions = require('parse5/lib/utils/merge-options');\n\nconst DevNullStream = require('./dev-null-stream');\n\nconst ParserFeedbackSimulator = require('./parser-feedback-simulator');\n\nconst DEFAULT_OPTIONS = {\n  sourceCodeLocationInfo: false\n};\n\nclass SAXParser extends Transform {\n  constructor(options) {\n    super({\n      encoding: 'utf8',\n      decodeStrings: false\n    });\n    this.options = mergeOptions(DEFAULT_OPTIONS, options);\n    this.tokenizer = new Tokenizer(options);\n    this.locInfoMixin = null;\n\n    if (this.options.sourceCodeLocationInfo) {\n      this.locInfoMixin = Mixin.install(this.tokenizer, LocationInfoTokenizerMixin);\n    }\n\n    this.parserFeedbackSimulator = new ParserFeedbackSimulator(this.tokenizer);\n    this.pendingText = null;\n    this.lastChunkWritten = false;\n    this.stopped = false; // NOTE: always pipe stream to the /dev/null stream to avoid\n    // `highWaterMark` hit even if we don't have consumers.\n    // (see: https://github.com/inikulin/parse5/issues/97#issuecomment-171940774)\n\n    this.pipe(new DevNullStream());\n  } //TransformStream implementation\n\n\n  _transform(chunk, encoding, callback) {\n    if (typeof chunk !== 'string') {\n      throw new TypeError('Parser can work only with string streams.');\n    }\n\n    callback(null, this._transformChunk(chunk));\n  }\n\n  _final(callback) {\n    this.lastChunkWritten = true;\n    callback(null, this._transformChunk(''));\n  }\n\n  stop() {\n    this.stopped = true;\n  } //Internals\n\n\n  _transformChunk(chunk) {\n    if (!this.stopped) {\n      this.tokenizer.write(chunk, this.lastChunkWritten);\n\n      this._runParsingLoop();\n    }\n\n    return chunk;\n  }\n\n  _runParsingLoop() {\n    let token = null;\n\n    do {\n      token = this.parserFeedbackSimulator.getNextToken();\n\n      if (token.type === Tokenizer.HIBERNATION_TOKEN) {\n        break;\n      }\n\n      if (token.type === Tokenizer.CHARACTER_TOKEN || token.type === Tokenizer.WHITESPACE_CHARACTER_TOKEN || token.type === Tokenizer.NULL_CHARACTER_TOKEN) {\n        if (this.pendingText === null) {\n          token.type = Tokenizer.CHARACTER_TOKEN;\n          this.pendingText = token;\n        } else {\n          this.pendingText.chars += token.chars;\n\n          if (this.options.sourceCodeLocationInfo) {\n            const {\n              endLine,\n              endCol,\n              endOffset\n            } = token.location;\n            Object.assign(this.pendingText.location, {\n              endLine,\n              endCol,\n              endOffset\n            });\n          }\n        }\n      } else {\n        this._emitPendingText();\n\n        this._handleToken(token);\n      }\n    } while (!this.stopped && token.type !== Tokenizer.EOF_TOKEN);\n  }\n\n  _handleToken(token) {\n    if (token.type === Tokenizer.EOF_TOKEN) {\n      return true;\n    }\n\n    const {\n      eventName,\n      reshapeToken\n    } = TOKEN_EMISSION_HELPERS[token.type];\n\n    if (this.listenerCount(eventName) === 0) {\n      return false;\n    }\n\n    this._emitToken(eventName, reshapeToken(token));\n\n    return true;\n  }\n\n  _emitToken(eventName, token) {\n    this.emit(eventName, token);\n  }\n\n  _emitPendingText() {\n    if (this.pendingText !== null) {\n      this._handleToken(this.pendingText);\n\n      this.pendingText = null;\n    }\n  }\n\n}\n\nconst TOKEN_EMISSION_HELPERS = {\n  [Tokenizer.START_TAG_TOKEN]: {\n    eventName: 'startTag',\n    reshapeToken: origToken => ({\n      tagName: origToken.tagName,\n      attrs: origToken.attrs,\n      selfClosing: origToken.selfClosing,\n      sourceCodeLocation: origToken.location\n    })\n  },\n  [Tokenizer.END_TAG_TOKEN]: {\n    eventName: 'endTag',\n    reshapeToken: origToken => ({\n      tagName: origToken.tagName,\n      sourceCodeLocation: origToken.location\n    })\n  },\n  [Tokenizer.COMMENT_TOKEN]: {\n    eventName: 'comment',\n    reshapeToken: origToken => ({\n      text: origToken.data,\n      sourceCodeLocation: origToken.location\n    })\n  },\n  [Tokenizer.DOCTYPE_TOKEN]: {\n    eventName: 'doctype',\n    reshapeToken: origToken => ({\n      name: origToken.name,\n      publicId: origToken.publicId,\n      systemId: origToken.systemId,\n      sourceCodeLocation: origToken.location\n    })\n  },\n  [Tokenizer.CHARACTER_TOKEN]: {\n    eventName: 'text',\n    reshapeToken: origToken => ({\n      text: origToken.chars,\n      sourceCodeLocation: origToken.location\n    })\n  }\n};\nmodule.exports = SAXParser;","map":{"version":3,"names":["Transform","require","Tokenizer","LocationInfoTokenizerMixin","Mixin","mergeOptions","DevNullStream","ParserFeedbackSimulator","DEFAULT_OPTIONS","sourceCodeLocationInfo","SAXParser","constructor","options","encoding","decodeStrings","tokenizer","locInfoMixin","install","parserFeedbackSimulator","pendingText","lastChunkWritten","stopped","pipe","_transform","chunk","callback","TypeError","_transformChunk","_final","stop","write","_runParsingLoop","token","getNextToken","type","HIBERNATION_TOKEN","CHARACTER_TOKEN","WHITESPACE_CHARACTER_TOKEN","NULL_CHARACTER_TOKEN","chars","endLine","endCol","endOffset","location","Object","assign","_emitPendingText","_handleToken","EOF_TOKEN","eventName","reshapeToken","TOKEN_EMISSION_HELPERS","listenerCount","_emitToken","emit","START_TAG_TOKEN","origToken","tagName","attrs","selfClosing","sourceCodeLocation","END_TAG_TOKEN","COMMENT_TOKEN","text","data","DOCTYPE_TOKEN","name","publicId","systemId","module","exports"],"sources":["/Users/deliabarbuta/Documents/An4Sem1/PAW/Proiect/proiect-paw-tadam/Frontend_OceanCross/node_modules/parse5-sax-parser/lib/index.js"],"sourcesContent":["'use strict';\n\nconst { Transform } = require('stream');\nconst Tokenizer = require('parse5/lib/tokenizer');\nconst LocationInfoTokenizerMixin = require('parse5/lib/extensions/location-info/tokenizer-mixin');\nconst Mixin = require('parse5/lib/utils/mixin');\nconst mergeOptions = require('parse5/lib/utils/merge-options');\nconst DevNullStream = require('./dev-null-stream');\nconst ParserFeedbackSimulator = require('./parser-feedback-simulator');\n\nconst DEFAULT_OPTIONS = {\n    sourceCodeLocationInfo: false\n};\n\nclass SAXParser extends Transform {\n    constructor(options) {\n        super({ encoding: 'utf8', decodeStrings: false });\n\n        this.options = mergeOptions(DEFAULT_OPTIONS, options);\n\n        this.tokenizer = new Tokenizer(options);\n        this.locInfoMixin = null;\n\n        if (this.options.sourceCodeLocationInfo) {\n            this.locInfoMixin = Mixin.install(this.tokenizer, LocationInfoTokenizerMixin);\n        }\n\n        this.parserFeedbackSimulator = new ParserFeedbackSimulator(this.tokenizer);\n\n        this.pendingText = null;\n\n        this.lastChunkWritten = false;\n        this.stopped = false;\n\n        // NOTE: always pipe stream to the /dev/null stream to avoid\n        // `highWaterMark` hit even if we don't have consumers.\n        // (see: https://github.com/inikulin/parse5/issues/97#issuecomment-171940774)\n        this.pipe(new DevNullStream());\n    }\n\n    //TransformStream implementation\n    _transform(chunk, encoding, callback) {\n        if (typeof chunk !== 'string') {\n            throw new TypeError('Parser can work only with string streams.');\n        }\n\n        callback(null, this._transformChunk(chunk));\n    }\n\n    _final(callback) {\n        this.lastChunkWritten = true;\n        callback(null, this._transformChunk(''));\n    }\n\n    stop() {\n        this.stopped = true;\n    }\n\n    //Internals\n    _transformChunk(chunk) {\n        if (!this.stopped) {\n            this.tokenizer.write(chunk, this.lastChunkWritten);\n            this._runParsingLoop();\n        }\n        return chunk;\n    }\n\n    _runParsingLoop() {\n        let token = null;\n\n        do {\n            token = this.parserFeedbackSimulator.getNextToken();\n\n            if (token.type === Tokenizer.HIBERNATION_TOKEN) {\n                break;\n            }\n\n            if (\n                token.type === Tokenizer.CHARACTER_TOKEN ||\n                token.type === Tokenizer.WHITESPACE_CHARACTER_TOKEN ||\n                token.type === Tokenizer.NULL_CHARACTER_TOKEN\n            ) {\n                if (this.pendingText === null) {\n                    token.type = Tokenizer.CHARACTER_TOKEN;\n                    this.pendingText = token;\n                } else {\n                    this.pendingText.chars += token.chars;\n\n                    if (this.options.sourceCodeLocationInfo) {\n                        const { endLine, endCol, endOffset } = token.location;\n                        Object.assign(this.pendingText.location, {\n                            endLine,\n                            endCol,\n                            endOffset\n                        });\n                    }\n                }\n            } else {\n                this._emitPendingText();\n                this._handleToken(token);\n            }\n        } while (!this.stopped && token.type !== Tokenizer.EOF_TOKEN);\n    }\n\n    _handleToken(token) {\n        if (token.type === Tokenizer.EOF_TOKEN) {\n            return true;\n        }\n\n        const { eventName, reshapeToken } = TOKEN_EMISSION_HELPERS[token.type];\n\n        if (this.listenerCount(eventName) === 0) {\n            return false;\n        }\n\n        this._emitToken(eventName, reshapeToken(token));\n\n        return true;\n    }\n\n    _emitToken(eventName, token) {\n        this.emit(eventName, token);\n    }\n\n    _emitPendingText() {\n        if (this.pendingText !== null) {\n            this._handleToken(this.pendingText);\n            this.pendingText = null;\n        }\n    }\n}\n\nconst TOKEN_EMISSION_HELPERS = {\n    [Tokenizer.START_TAG_TOKEN]: {\n        eventName: 'startTag',\n        reshapeToken: origToken => ({\n            tagName: origToken.tagName,\n            attrs: origToken.attrs,\n            selfClosing: origToken.selfClosing,\n            sourceCodeLocation: origToken.location\n        })\n    },\n    [Tokenizer.END_TAG_TOKEN]: {\n        eventName: 'endTag',\n        reshapeToken: origToken => ({ tagName: origToken.tagName, sourceCodeLocation: origToken.location })\n    },\n    [Tokenizer.COMMENT_TOKEN]: {\n        eventName: 'comment',\n        reshapeToken: origToken => ({ text: origToken.data, sourceCodeLocation: origToken.location })\n    },\n    [Tokenizer.DOCTYPE_TOKEN]: {\n        eventName: 'doctype',\n        reshapeToken: origToken => ({\n            name: origToken.name,\n            publicId: origToken.publicId,\n            systemId: origToken.systemId,\n            sourceCodeLocation: origToken.location\n        })\n    },\n    [Tokenizer.CHARACTER_TOKEN]: {\n        eventName: 'text',\n        reshapeToken: origToken => ({ text: origToken.chars, sourceCodeLocation: origToken.location })\n    }\n};\n\nmodule.exports = SAXParser;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}