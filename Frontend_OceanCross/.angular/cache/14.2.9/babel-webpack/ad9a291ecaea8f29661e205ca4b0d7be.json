{"ast":null,"code":"\"use strict\"; // builtin tooling\n\nconst path = require(\"path\"); // internal tooling\n\n\nconst joinMedia = require(\"./lib/join-media\");\n\nconst joinLayer = require(\"./lib/join-layer\");\n\nconst resolveId = require(\"./lib/resolve-id\");\n\nconst loadContent = require(\"./lib/load-content\");\n\nconst processContent = require(\"./lib/process-content\");\n\nconst parseStatements = require(\"./lib/parse-statements\");\n\nfunction AtImport(options) {\n  options = {\n    root: process.cwd(),\n    path: [],\n    skipDuplicates: true,\n    resolve: resolveId,\n    load: loadContent,\n    plugins: [],\n    addModulesDirectories: [],\n    nameLayer: null,\n    ...options\n  };\n  options.root = path.resolve(options.root); // convert string to an array of a single element\n\n  if (typeof options.path === \"string\") options.path = [options.path];\n  if (!Array.isArray(options.path)) options.path = [];\n  options.path = options.path.map(p => path.resolve(options.root, p));\n  return {\n    postcssPlugin: \"postcss-import\",\n\n    Once(styles, {\n      result,\n      atRule,\n      postcss\n    }) {\n      const state = {\n        importedFiles: {},\n        hashFiles: {},\n        rootFilename: null,\n        anonymousLayerCounter: 0\n      };\n\n      if (styles.source?.input?.file) {\n        state.rootFilename = styles.source.input.file;\n        state.importedFiles[styles.source.input.file] = {};\n      }\n\n      if (options.plugins && !Array.isArray(options.plugins)) {\n        throw new Error(\"plugins option must be an array\");\n      }\n\n      if (options.nameLayer && typeof options.nameLayer !== \"function\") {\n        throw new Error(\"nameLayer option must be a function\");\n      }\n\n      return parseStyles(result, styles, options, state, [], []).then(bundle => {\n        applyRaws(bundle);\n        applyMedia(bundle);\n        applyStyles(bundle, styles);\n      });\n\n      function applyRaws(bundle) {\n        bundle.forEach((stmt, index) => {\n          if (index === 0) return;\n\n          if (stmt.parent) {\n            const {\n              before\n            } = stmt.parent.node.raws;\n            if (stmt.type === \"nodes\") stmt.nodes[0].raws.before = before;else stmt.node.raws.before = before;\n          } else if (stmt.type === \"nodes\") {\n            stmt.nodes[0].raws.before = stmt.nodes[0].raws.before || \"\\n\";\n          }\n        });\n      }\n\n      function applyMedia(bundle) {\n        bundle.forEach(stmt => {\n          if (!stmt.media.length && !stmt.layer.length || stmt.type === \"charset\") {\n            return;\n          }\n\n          if (stmt.type === \"import\") {\n            stmt.node.params = `${stmt.fullUri} ${stmt.media.join(\", \")}`;\n          } else if (stmt.type === \"media\") {\n            if (stmt.layer.length) {\n              const layerNode = atRule({\n                name: \"layer\",\n                params: stmt.layer.filter(layer => layer !== \"\").join(\".\"),\n                source: stmt.node.source\n              });\n\n              if (stmt.parentMedia?.length) {\n                const mediaNode = atRule({\n                  name: \"media\",\n                  params: stmt.parentMedia.join(\", \"),\n                  source: stmt.node.source\n                });\n                mediaNode.append(layerNode);\n                layerNode.append(stmt.node);\n                stmt.node = mediaNode;\n              } else {\n                layerNode.append(stmt.node);\n                stmt.node = layerNode;\n              }\n            } else {\n              stmt.node.params = stmt.media.join(\", \");\n            }\n          } else {\n            const {\n              nodes\n            } = stmt;\n            const {\n              parent\n            } = nodes[0];\n            let outerAtRule;\n            let innerAtRule;\n\n            if (stmt.media.length && stmt.layer.length) {\n              const mediaNode = atRule({\n                name: \"media\",\n                params: stmt.media.join(\", \"),\n                source: parent.source\n              });\n              const layerNode = atRule({\n                name: \"layer\",\n                params: stmt.layer.filter(layer => layer !== \"\").join(\".\"),\n                source: parent.source\n              });\n              mediaNode.append(layerNode);\n              innerAtRule = layerNode;\n              outerAtRule = mediaNode;\n            } else if (stmt.media.length) {\n              const mediaNode = atRule({\n                name: \"media\",\n                params: stmt.media.join(\", \"),\n                source: parent.source\n              });\n              innerAtRule = mediaNode;\n              outerAtRule = mediaNode;\n            } else if (stmt.layer.length) {\n              const layerNode = atRule({\n                name: \"layer\",\n                params: stmt.layer.filter(layer => layer !== \"\").join(\".\"),\n                source: parent.source\n              });\n              innerAtRule = layerNode;\n              outerAtRule = layerNode;\n            }\n\n            parent.insertBefore(nodes[0], outerAtRule); // remove nodes\n\n            nodes.forEach(node => {\n              node.parent = undefined;\n            }); // better output\n\n            nodes[0].raws.before = nodes[0].raws.before || \"\\n\"; // wrap new rules with media query and/or layer at rule\n\n            innerAtRule.append(nodes);\n            stmt.type = \"media\";\n            stmt.node = outerAtRule;\n            delete stmt.nodes;\n          }\n        });\n      }\n\n      function applyStyles(bundle, styles) {\n        styles.nodes = []; // Strip additional statements.\n\n        bundle.forEach(stmt => {\n          if ([\"charset\", \"import\", \"media\"].includes(stmt.type)) {\n            stmt.node.parent = undefined;\n            styles.append(stmt.node);\n          } else if (stmt.type === \"nodes\") {\n            stmt.nodes.forEach(node => {\n              node.parent = undefined;\n              styles.append(node);\n            });\n          }\n        });\n      }\n\n      function parseStyles(result, styles, options, state, media, layer) {\n        const statements = parseStatements(result, styles);\n        return Promise.resolve(statements).then(stmts => {\n          // process each statement in series\n          return stmts.reduce((promise, stmt) => {\n            return promise.then(() => {\n              stmt.media = joinMedia(media, stmt.media || []);\n              stmt.parentMedia = media;\n              stmt.layer = joinLayer(layer, stmt.layer || []); // skip protocol base uri (protocol://url) or protocol-relative\n\n              if (stmt.type !== \"import\" || /^(?:[a-z]+:)?\\/\\//i.test(stmt.uri)) {\n                return;\n              }\n\n              if (options.filter && !options.filter(stmt.uri)) {\n                // rejected by filter\n                return;\n              }\n\n              return resolveImportId(result, stmt, options, state);\n            });\n          }, Promise.resolve());\n        }).then(() => {\n          let charset;\n          const imports = [];\n          const bundle = [];\n\n          function handleCharset(stmt) {\n            if (!charset) charset = stmt; // charsets aren't case-sensitive, so convert to lower case to compare\n            else if (stmt.node.params.toLowerCase() !== charset.node.params.toLowerCase()) {\n              throw new Error(`Incompatable @charset statements:\n  ${stmt.node.params} specified in ${stmt.node.source.input.file}\n  ${charset.node.params} specified in ${charset.node.source.input.file}`);\n            }\n          } // squash statements and their children\n\n\n          statements.forEach(stmt => {\n            if (stmt.type === \"charset\") handleCharset(stmt);else if (stmt.type === \"import\") {\n              if (stmt.children) {\n                stmt.children.forEach((child, index) => {\n                  if (child.type === \"import\") imports.push(child);else if (child.type === \"charset\") handleCharset(child);else bundle.push(child); // For better output\n\n                  if (index === 0) child.parent = stmt;\n                });\n              } else imports.push(stmt);\n            } else if (stmt.type === \"media\" || stmt.type === \"nodes\") {\n              bundle.push(stmt);\n            }\n          });\n          return charset ? [charset, ...imports.concat(bundle)] : imports.concat(bundle);\n        });\n      }\n\n      function resolveImportId(result, stmt, options, state) {\n        const atRule = stmt.node;\n        let sourceFile;\n\n        if (atRule.source?.input?.file) {\n          sourceFile = atRule.source.input.file;\n        }\n\n        const base = sourceFile ? path.dirname(atRule.source.input.file) : options.root;\n        return Promise.resolve(options.resolve(stmt.uri, base, options)).then(paths => {\n          if (!Array.isArray(paths)) paths = [paths]; // Ensure that each path is absolute:\n\n          return Promise.all(paths.map(file => {\n            return !path.isAbsolute(file) ? resolveId(file, base, options) : file;\n          }));\n        }).then(resolved => {\n          // Add dependency messages:\n          resolved.forEach(file => {\n            result.messages.push({\n              type: \"dependency\",\n              plugin: \"postcss-import\",\n              file,\n              parent: sourceFile\n            });\n          });\n          return Promise.all(resolved.map(file => {\n            return loadImportContent(result, stmt, file, options, state);\n          }));\n        }).then(result => {\n          // Merge loaded statements\n          stmt.children = result.reduce((result, statements) => {\n            return statements ? result.concat(statements) : result;\n          }, []);\n        });\n      }\n\n      function loadImportContent(result, stmt, filename, options, state) {\n        const atRule = stmt.node;\n        const {\n          media,\n          layer\n        } = stmt;\n        layer.forEach((layerPart, i) => {\n          if (layerPart === \"\") {\n            if (options.nameLayer) {\n              layer[i] = options.nameLayer(state.anonymousLayerCounter++, state.rootFilename).toString();\n            } else {\n              throw atRule.error(`When using anonymous layers in @import you must also set the \"nameLayer\" plugin option`);\n            }\n          }\n        });\n\n        if (options.skipDuplicates) {\n          // skip files already imported at the same scope\n          if (state.importedFiles[filename]?.[media]?.[layer]) {\n            return;\n          } // save imported files to skip them next time\n\n\n          if (!state.importedFiles[filename]) {\n            state.importedFiles[filename] = {};\n          }\n\n          if (!state.importedFiles[filename][media]) {\n            state.importedFiles[filename][media] = {};\n          }\n\n          state.importedFiles[filename][media][layer] = true;\n        }\n\n        return Promise.resolve(options.load(filename, options)).then(content => {\n          if (content.trim() === \"\") {\n            result.warn(`${filename} is empty`, {\n              node: atRule\n            });\n            return;\n          } // skip previous imported files not containing @import rules\n\n\n          if (state.hashFiles[content]?.[media]?.[layer]) {\n            return;\n          }\n\n          return processContent(result, content, filename, options, postcss).then(importedResult => {\n            const styles = importedResult.root;\n            result.messages = result.messages.concat(importedResult.messages);\n\n            if (options.skipDuplicates) {\n              const hasImport = styles.some(child => {\n                return child.type === \"atrule\" && child.name === \"import\";\n              });\n\n              if (!hasImport) {\n                // save hash files to skip them next time\n                if (!state.hashFiles[content]) {\n                  state.hashFiles[content] = {};\n                }\n\n                if (!state.hashFiles[content][media]) {\n                  state.hashFiles[content][media] = {};\n                }\n\n                state.hashFiles[content][media][layer] = true;\n              }\n            } // recursion: import @import from imported file\n\n\n            return parseStyles(result, styles, options, state, media, layer);\n          });\n        });\n      }\n    }\n\n  };\n}\n\nAtImport.postcss = true;\nmodule.exports = AtImport;","map":{"version":3,"names":["path","require","joinMedia","joinLayer","resolveId","loadContent","processContent","parseStatements","AtImport","options","root","process","cwd","skipDuplicates","resolve","load","plugins","addModulesDirectories","nameLayer","Array","isArray","map","p","postcssPlugin","Once","styles","result","atRule","postcss","state","importedFiles","hashFiles","rootFilename","anonymousLayerCounter","source","input","file","Error","parseStyles","then","bundle","applyRaws","applyMedia","applyStyles","forEach","stmt","index","parent","before","node","raws","type","nodes","media","length","layer","params","fullUri","join","layerNode","name","filter","parentMedia","mediaNode","append","outerAtRule","innerAtRule","insertBefore","undefined","includes","statements","Promise","stmts","reduce","promise","test","uri","resolveImportId","charset","imports","handleCharset","toLowerCase","children","child","push","concat","sourceFile","base","dirname","paths","all","isAbsolute","resolved","messages","plugin","loadImportContent","filename","layerPart","i","toString","error","content","trim","warn","importedResult","hasImport","some","module","exports"],"sources":["/Users/deliabarbuta/Documents/An4Sem1/PAW/Proiect/proiect-paw-tadam/Frontend_OceanCross/node_modules/postcss-import/index.js"],"sourcesContent":["\"use strict\"\n// builtin tooling\nconst path = require(\"path\")\n\n// internal tooling\nconst joinMedia = require(\"./lib/join-media\")\nconst joinLayer = require(\"./lib/join-layer\")\nconst resolveId = require(\"./lib/resolve-id\")\nconst loadContent = require(\"./lib/load-content\")\nconst processContent = require(\"./lib/process-content\")\nconst parseStatements = require(\"./lib/parse-statements\")\n\nfunction AtImport(options) {\n  options = {\n    root: process.cwd(),\n    path: [],\n    skipDuplicates: true,\n    resolve: resolveId,\n    load: loadContent,\n    plugins: [],\n    addModulesDirectories: [],\n    nameLayer: null,\n    ...options,\n  }\n\n  options.root = path.resolve(options.root)\n\n  // convert string to an array of a single element\n  if (typeof options.path === \"string\") options.path = [options.path]\n\n  if (!Array.isArray(options.path)) options.path = []\n\n  options.path = options.path.map(p => path.resolve(options.root, p))\n\n  return {\n    postcssPlugin: \"postcss-import\",\n    Once(styles, { result, atRule, postcss }) {\n      const state = {\n        importedFiles: {},\n        hashFiles: {},\n        rootFilename: null,\n        anonymousLayerCounter: 0,\n      }\n\n      if (styles.source?.input?.file) {\n        state.rootFilename = styles.source.input.file\n        state.importedFiles[styles.source.input.file] = {}\n      }\n\n      if (options.plugins && !Array.isArray(options.plugins)) {\n        throw new Error(\"plugins option must be an array\")\n      }\n\n      if (options.nameLayer && typeof options.nameLayer !== \"function\") {\n        throw new Error(\"nameLayer option must be a function\")\n      }\n\n      return parseStyles(result, styles, options, state, [], []).then(\n        bundle => {\n          applyRaws(bundle)\n          applyMedia(bundle)\n          applyStyles(bundle, styles)\n        }\n      )\n\n      function applyRaws(bundle) {\n        bundle.forEach((stmt, index) => {\n          if (index === 0) return\n\n          if (stmt.parent) {\n            const { before } = stmt.parent.node.raws\n            if (stmt.type === \"nodes\") stmt.nodes[0].raws.before = before\n            else stmt.node.raws.before = before\n          } else if (stmt.type === \"nodes\") {\n            stmt.nodes[0].raws.before = stmt.nodes[0].raws.before || \"\\n\"\n          }\n        })\n      }\n\n      function applyMedia(bundle) {\n        bundle.forEach(stmt => {\n          if (\n            (!stmt.media.length && !stmt.layer.length) ||\n            stmt.type === \"charset\"\n          ) {\n            return\n          }\n\n          if (stmt.type === \"import\") {\n            stmt.node.params = `${stmt.fullUri} ${stmt.media.join(\", \")}`\n          } else if (stmt.type === \"media\") {\n            if (stmt.layer.length) {\n              const layerNode = atRule({\n                name: \"layer\",\n                params: stmt.layer.filter(layer => layer !== \"\").join(\".\"),\n                source: stmt.node.source,\n              })\n\n              if (stmt.parentMedia?.length) {\n                const mediaNode = atRule({\n                  name: \"media\",\n                  params: stmt.parentMedia.join(\", \"),\n                  source: stmt.node.source,\n                })\n\n                mediaNode.append(layerNode)\n                layerNode.append(stmt.node)\n                stmt.node = mediaNode\n              } else {\n                layerNode.append(stmt.node)\n                stmt.node = layerNode\n              }\n            } else {\n              stmt.node.params = stmt.media.join(\", \")\n            }\n          } else {\n            const { nodes } = stmt\n            const { parent } = nodes[0]\n\n            let outerAtRule\n            let innerAtRule\n            if (stmt.media.length && stmt.layer.length) {\n              const mediaNode = atRule({\n                name: \"media\",\n                params: stmt.media.join(\", \"),\n                source: parent.source,\n              })\n\n              const layerNode = atRule({\n                name: \"layer\",\n                params: stmt.layer.filter(layer => layer !== \"\").join(\".\"),\n                source: parent.source,\n              })\n\n              mediaNode.append(layerNode)\n              innerAtRule = layerNode\n              outerAtRule = mediaNode\n            } else if (stmt.media.length) {\n              const mediaNode = atRule({\n                name: \"media\",\n                params: stmt.media.join(\", \"),\n                source: parent.source,\n              })\n\n              innerAtRule = mediaNode\n              outerAtRule = mediaNode\n            } else if (stmt.layer.length) {\n              const layerNode = atRule({\n                name: \"layer\",\n                params: stmt.layer.filter(layer => layer !== \"\").join(\".\"),\n                source: parent.source,\n              })\n\n              innerAtRule = layerNode\n              outerAtRule = layerNode\n            }\n\n            parent.insertBefore(nodes[0], outerAtRule)\n\n            // remove nodes\n            nodes.forEach(node => {\n              node.parent = undefined\n            })\n\n            // better output\n            nodes[0].raws.before = nodes[0].raws.before || \"\\n\"\n\n            // wrap new rules with media query and/or layer at rule\n            innerAtRule.append(nodes)\n\n            stmt.type = \"media\"\n            stmt.node = outerAtRule\n            delete stmt.nodes\n          }\n        })\n      }\n\n      function applyStyles(bundle, styles) {\n        styles.nodes = []\n\n        // Strip additional statements.\n        bundle.forEach(stmt => {\n          if ([\"charset\", \"import\", \"media\"].includes(stmt.type)) {\n            stmt.node.parent = undefined\n            styles.append(stmt.node)\n          } else if (stmt.type === \"nodes\") {\n            stmt.nodes.forEach(node => {\n              node.parent = undefined\n              styles.append(node)\n            })\n          }\n        })\n      }\n\n      function parseStyles(result, styles, options, state, media, layer) {\n        const statements = parseStatements(result, styles)\n\n        return Promise.resolve(statements)\n          .then(stmts => {\n            // process each statement in series\n            return stmts.reduce((promise, stmt) => {\n              return promise.then(() => {\n                stmt.media = joinMedia(media, stmt.media || [])\n                stmt.parentMedia = media\n                stmt.layer = joinLayer(layer, stmt.layer || [])\n\n                // skip protocol base uri (protocol://url) or protocol-relative\n                if (\n                  stmt.type !== \"import\" ||\n                  /^(?:[a-z]+:)?\\/\\//i.test(stmt.uri)\n                ) {\n                  return\n                }\n\n                if (options.filter && !options.filter(stmt.uri)) {\n                  // rejected by filter\n                  return\n                }\n\n                return resolveImportId(result, stmt, options, state)\n              })\n            }, Promise.resolve())\n          })\n          .then(() => {\n            let charset\n            const imports = []\n            const bundle = []\n\n            function handleCharset(stmt) {\n              if (!charset) charset = stmt\n              // charsets aren't case-sensitive, so convert to lower case to compare\n              else if (\n                stmt.node.params.toLowerCase() !==\n                charset.node.params.toLowerCase()\n              ) {\n                throw new Error(\n                  `Incompatable @charset statements:\n  ${stmt.node.params} specified in ${stmt.node.source.input.file}\n  ${charset.node.params} specified in ${charset.node.source.input.file}`\n                )\n              }\n            }\n\n            // squash statements and their children\n            statements.forEach(stmt => {\n              if (stmt.type === \"charset\") handleCharset(stmt)\n              else if (stmt.type === \"import\") {\n                if (stmt.children) {\n                  stmt.children.forEach((child, index) => {\n                    if (child.type === \"import\") imports.push(child)\n                    else if (child.type === \"charset\") handleCharset(child)\n                    else bundle.push(child)\n                    // For better output\n                    if (index === 0) child.parent = stmt\n                  })\n                } else imports.push(stmt)\n              } else if (stmt.type === \"media\" || stmt.type === \"nodes\") {\n                bundle.push(stmt)\n              }\n            })\n\n            return charset\n              ? [charset, ...imports.concat(bundle)]\n              : imports.concat(bundle)\n          })\n      }\n\n      function resolveImportId(result, stmt, options, state) {\n        const atRule = stmt.node\n        let sourceFile\n        if (atRule.source?.input?.file) {\n          sourceFile = atRule.source.input.file\n        }\n        const base = sourceFile\n          ? path.dirname(atRule.source.input.file)\n          : options.root\n\n        return Promise.resolve(options.resolve(stmt.uri, base, options))\n          .then(paths => {\n            if (!Array.isArray(paths)) paths = [paths]\n            // Ensure that each path is absolute:\n            return Promise.all(\n              paths.map(file => {\n                return !path.isAbsolute(file)\n                  ? resolveId(file, base, options)\n                  : file\n              })\n            )\n          })\n          .then(resolved => {\n            // Add dependency messages:\n            resolved.forEach(file => {\n              result.messages.push({\n                type: \"dependency\",\n                plugin: \"postcss-import\",\n                file,\n                parent: sourceFile,\n              })\n            })\n\n            return Promise.all(\n              resolved.map(file => {\n                return loadImportContent(result, stmt, file, options, state)\n              })\n            )\n          })\n          .then(result => {\n            // Merge loaded statements\n            stmt.children = result.reduce((result, statements) => {\n              return statements ? result.concat(statements) : result\n            }, [])\n          })\n      }\n\n      function loadImportContent(result, stmt, filename, options, state) {\n        const atRule = stmt.node\n        const { media, layer } = stmt\n        layer.forEach((layerPart, i) => {\n          if (layerPart === \"\") {\n            if (options.nameLayer) {\n              layer[i] = options\n                .nameLayer(state.anonymousLayerCounter++, state.rootFilename)\n                .toString()\n            } else {\n              throw atRule.error(\n                `When using anonymous layers in @import you must also set the \"nameLayer\" plugin option`\n              )\n            }\n          }\n        })\n\n        if (options.skipDuplicates) {\n          // skip files already imported at the same scope\n          if (state.importedFiles[filename]?.[media]?.[layer]) {\n            return\n          }\n\n          // save imported files to skip them next time\n          if (!state.importedFiles[filename]) {\n            state.importedFiles[filename] = {}\n          }\n          if (!state.importedFiles[filename][media]) {\n            state.importedFiles[filename][media] = {}\n          }\n          state.importedFiles[filename][media][layer] = true\n        }\n\n        return Promise.resolve(options.load(filename, options)).then(\n          content => {\n            if (content.trim() === \"\") {\n              result.warn(`${filename} is empty`, { node: atRule })\n              return\n            }\n\n            // skip previous imported files not containing @import rules\n            if (state.hashFiles[content]?.[media]?.[layer]) {\n              return\n            }\n\n            return processContent(\n              result,\n              content,\n              filename,\n              options,\n              postcss\n            ).then(importedResult => {\n              const styles = importedResult.root\n              result.messages = result.messages.concat(importedResult.messages)\n\n              if (options.skipDuplicates) {\n                const hasImport = styles.some(child => {\n                  return child.type === \"atrule\" && child.name === \"import\"\n                })\n                if (!hasImport) {\n                  // save hash files to skip them next time\n                  if (!state.hashFiles[content]) {\n                    state.hashFiles[content] = {}\n                  }\n                  if (!state.hashFiles[content][media]) {\n                    state.hashFiles[content][media] = {}\n                  }\n                  state.hashFiles[content][media][layer] = true\n                }\n              }\n\n              // recursion: import @import from imported file\n              return parseStyles(result, styles, options, state, media, layer)\n            })\n          }\n        )\n      }\n    },\n  }\n}\n\nAtImport.postcss = true\n\nmodule.exports = AtImport\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}