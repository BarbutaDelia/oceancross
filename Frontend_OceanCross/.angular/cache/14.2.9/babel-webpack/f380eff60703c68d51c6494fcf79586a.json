{"ast":null,"code":"'use strict';\n\nconst Jobs = require('qjobs');\n\nconst log = require('./logger').create('launcher');\n\nconst baseDecorator = require('./launchers/base').decoratorFactory;\n\nconst captureTimeoutDecorator = require('./launchers/capture_timeout').decoratorFactory;\n\nconst retryDecorator = require('./launchers/retry').decoratorFactory;\n\nconst processDecorator = require('./launchers/process').decoratorFactory; // TODO(vojta): remove once nobody uses it\n\n\nconst baseBrowserDecoratorFactory = function (baseLauncherDecorator, captureTimeoutLauncherDecorator, retryLauncherDecorator, processLauncherDecorator, processKillTimeout) {\n  return function (launcher) {\n    baseLauncherDecorator(launcher);\n    captureTimeoutLauncherDecorator(launcher);\n    retryLauncherDecorator(launcher);\n    processLauncherDecorator(launcher, processKillTimeout);\n  };\n};\n\nclass Launcher {\n  constructor(server, emitter, injector) {\n    this._server = server;\n    this._emitter = emitter;\n    this._injector = injector;\n    this._browsers = [];\n    this._lastStartTime = null; // Attach list of dependency injection parameters to methods.\n\n    this.launch.$inject = ['config.browsers', 'config.concurrency'];\n    this.launchSingle.$inject = ['config.protocol', 'config.hostname', 'config.port', 'config.urlRoot', 'config.upstreamProxy', 'config.processKillTimeout'];\n\n    this._emitter.on('exit', callback => this.killAll(callback));\n  }\n\n  getBrowserById(id) {\n    return this._browsers.find(browser => browser.id === id);\n  }\n\n  launchSingle(protocol, hostname, port, urlRoot, upstreamProxy, processKillTimeout) {\n    if (upstreamProxy) {\n      protocol = upstreamProxy.protocol;\n      hostname = upstreamProxy.hostname;\n      port = upstreamProxy.port;\n      urlRoot = upstreamProxy.path + urlRoot.slice(1);\n    }\n\n    return name => {\n      let browser;\n      const locals = {\n        id: ['value', Launcher.generateId()],\n        name: ['value', name],\n        processKillTimeout: ['value', processKillTimeout],\n        baseLauncherDecorator: ['factory', baseDecorator],\n        captureTimeoutLauncherDecorator: ['factory', captureTimeoutDecorator],\n        retryLauncherDecorator: ['factory', retryDecorator],\n        processLauncherDecorator: ['factory', processDecorator],\n        baseBrowserDecorator: ['factory', baseBrowserDecoratorFactory]\n      }; // TODO(vojta): determine script from name\n\n      if (name.includes('/')) {\n        name = 'Script';\n      }\n\n      try {\n        browser = this._injector.createChild([locals], ['launcher:' + name]).get('launcher:' + name);\n      } catch (e) {\n        if (e.message.includes(`No provider for \"launcher:${name}\"`)) {\n          log.error(`Cannot load browser \"${name}\": it is not registered! Perhaps you are missing some plugin?`);\n        } else {\n          log.error(`Cannot load browser \"${name}\"!\\n  ` + e.stack);\n        }\n\n        this._emitter.emit('load_error', 'launcher', name);\n\n        return;\n      }\n\n      this.jobs.add((args, done) => {\n        log.info(`Starting browser ${browser.displayName || browser.name}`);\n        browser.on('browser_process_failure', () => done(browser.error));\n        browser.on('done', () => {\n          if (!browser.error && browser.state !== browser.STATE_RESTARTING) {\n            done(null, browser);\n          }\n        });\n        browser.start(`${protocol}//${hostname}:${port}${urlRoot}`);\n      }, []);\n      this.jobs.run();\n\n      this._browsers.push(browser);\n    };\n  }\n\n  launch(names, concurrency) {\n    log.info(`Launching browsers ${names.join(', ')} with concurrency ${concurrency === Infinity ? 'unlimited' : concurrency}`);\n    this.jobs = new Jobs({\n      maxConcurrency: concurrency\n    });\n    this._lastStartTime = Date.now();\n\n    if (this._server.loadErrors.length) {\n      this.jobs.add((args, done) => done(), []);\n    } else {\n      names.forEach(name => this._injector.invoke(this.launchSingle, this)(name));\n    }\n\n    this.jobs.on('end', err => {\n      log.debug('Finished all browsers');\n\n      if (err) {\n        log.error(err);\n      }\n    });\n    this.jobs.run();\n    return this._browsers;\n  }\n\n  kill(id, callback) {\n    callback = callback || function () {};\n\n    const browser = this.getBrowserById(id);\n\n    if (browser) {\n      browser.forceKill().then(callback);\n      return true;\n    }\n\n    process.nextTick(callback);\n    return false;\n  }\n\n  restart(id) {\n    const browser = this.getBrowserById(id);\n\n    if (browser) {\n      browser.restart();\n      return true;\n    }\n\n    return false;\n  }\n\n  killAll(callback) {\n    callback = callback || function () {};\n\n    log.debug('Disconnecting all browsers');\n\n    if (!this._browsers.length) {\n      return process.nextTick(callback);\n    }\n\n    Promise.all(this._browsers.map(browser => browser.forceKill())).then(callback);\n  }\n\n  areAllCaptured() {\n    return this._browsers.every(browser => browser.isCaptured());\n  }\n\n  markCaptured(id) {\n    const browser = this.getBrowserById(id);\n\n    if (browser) {\n      browser.markCaptured();\n      log.debug(`${browser.name} (id ${browser.id}) captured in ${(Date.now() - this._lastStartTime) / 1000} secs`);\n    }\n  }\n\n  static generateId() {\n    return Math.floor(Math.random() * 100000000).toString();\n  }\n\n}\n\nLauncher.factory = function (server, emitter, injector) {\n  return new Launcher(server, emitter, injector);\n};\n\nLauncher.factory.$inject = ['server', 'emitter', 'injector'];\nexports.Launcher = Launcher;","map":{"version":3,"names":["Jobs","require","log","create","baseDecorator","decoratorFactory","captureTimeoutDecorator","retryDecorator","processDecorator","baseBrowserDecoratorFactory","baseLauncherDecorator","captureTimeoutLauncherDecorator","retryLauncherDecorator","processLauncherDecorator","processKillTimeout","launcher","Launcher","constructor","server","emitter","injector","_server","_emitter","_injector","_browsers","_lastStartTime","launch","$inject","launchSingle","on","callback","killAll","getBrowserById","id","find","browser","protocol","hostname","port","urlRoot","upstreamProxy","path","slice","name","locals","generateId","baseBrowserDecorator","includes","createChild","get","e","message","error","stack","emit","jobs","add","args","done","info","displayName","state","STATE_RESTARTING","start","run","push","names","concurrency","join","Infinity","maxConcurrency","Date","now","loadErrors","length","forEach","invoke","err","debug","kill","forceKill","then","process","nextTick","restart","Promise","all","map","areAllCaptured","every","isCaptured","markCaptured","Math","floor","random","toString","factory","exports"],"sources":["/Users/deliabarbuta/Documents/An4Sem1/PAW/Proiect/proiect-paw-tadam/Frontend_OceanCross/node_modules/karma/lib/launcher.js"],"sourcesContent":["'use strict'\n\nconst Jobs = require('qjobs')\n\nconst log = require('./logger').create('launcher')\n\nconst baseDecorator = require('./launchers/base').decoratorFactory\nconst captureTimeoutDecorator = require('./launchers/capture_timeout').decoratorFactory\nconst retryDecorator = require('./launchers/retry').decoratorFactory\nconst processDecorator = require('./launchers/process').decoratorFactory\n\n// TODO(vojta): remove once nobody uses it\nconst baseBrowserDecoratorFactory = function (\n  baseLauncherDecorator,\n  captureTimeoutLauncherDecorator,\n  retryLauncherDecorator,\n  processLauncherDecorator,\n  processKillTimeout\n) {\n  return function (launcher) {\n    baseLauncherDecorator(launcher)\n    captureTimeoutLauncherDecorator(launcher)\n    retryLauncherDecorator(launcher)\n    processLauncherDecorator(launcher, processKillTimeout)\n  }\n}\n\nclass Launcher {\n  constructor (server, emitter, injector) {\n    this._server = server\n    this._emitter = emitter\n    this._injector = injector\n    this._browsers = []\n    this._lastStartTime = null\n\n    // Attach list of dependency injection parameters to methods.\n    this.launch.$inject = [\n      'config.browsers',\n      'config.concurrency'\n    ]\n\n    this.launchSingle.$inject = [\n      'config.protocol',\n      'config.hostname',\n      'config.port',\n      'config.urlRoot',\n      'config.upstreamProxy',\n      'config.processKillTimeout'\n    ]\n\n    this._emitter.on('exit', (callback) => this.killAll(callback))\n  }\n\n  getBrowserById (id) {\n    return this._browsers.find((browser) => browser.id === id)\n  }\n\n  launchSingle (protocol, hostname, port, urlRoot, upstreamProxy, processKillTimeout) {\n    if (upstreamProxy) {\n      protocol = upstreamProxy.protocol\n      hostname = upstreamProxy.hostname\n      port = upstreamProxy.port\n      urlRoot = upstreamProxy.path + urlRoot.slice(1)\n    }\n\n    return (name) => {\n      let browser\n      const locals = {\n        id: ['value', Launcher.generateId()],\n        name: ['value', name],\n        processKillTimeout: ['value', processKillTimeout],\n        baseLauncherDecorator: ['factory', baseDecorator],\n        captureTimeoutLauncherDecorator: ['factory', captureTimeoutDecorator],\n        retryLauncherDecorator: ['factory', retryDecorator],\n        processLauncherDecorator: ['factory', processDecorator],\n        baseBrowserDecorator: ['factory', baseBrowserDecoratorFactory]\n      }\n\n      // TODO(vojta): determine script from name\n      if (name.includes('/')) {\n        name = 'Script'\n      }\n\n      try {\n        browser = this._injector.createChild([locals], ['launcher:' + name]).get('launcher:' + name)\n      } catch (e) {\n        if (e.message.includes(`No provider for \"launcher:${name}\"`)) {\n          log.error(`Cannot load browser \"${name}\": it is not registered! Perhaps you are missing some plugin?`)\n        } else {\n          log.error(`Cannot load browser \"${name}\"!\\n  ` + e.stack)\n        }\n\n        this._emitter.emit('load_error', 'launcher', name)\n        return\n      }\n\n      this.jobs.add((args, done) => {\n        log.info(`Starting browser ${browser.displayName || browser.name}`)\n\n        browser.on('browser_process_failure', () => done(browser.error))\n\n        browser.on('done', () => {\n          if (!browser.error && browser.state !== browser.STATE_RESTARTING) {\n            done(null, browser)\n          }\n        })\n\n        browser.start(`${protocol}//${hostname}:${port}${urlRoot}`)\n      }, [])\n\n      this.jobs.run()\n      this._browsers.push(browser)\n    }\n  }\n\n  launch (names, concurrency) {\n    log.info(`Launching browsers ${names.join(', ')} with concurrency ${concurrency === Infinity ? 'unlimited' : concurrency}`)\n    this.jobs = new Jobs({ maxConcurrency: concurrency })\n\n    this._lastStartTime = Date.now()\n\n    if (this._server.loadErrors.length) {\n      this.jobs.add((args, done) => done(), [])\n    } else {\n      names.forEach((name) => this._injector.invoke(this.launchSingle, this)(name))\n    }\n\n    this.jobs.on('end', (err) => {\n      log.debug('Finished all browsers')\n\n      if (err) {\n        log.error(err)\n      }\n    })\n\n    this.jobs.run()\n\n    return this._browsers\n  }\n\n  kill (id, callback) {\n    callback = callback || function () {}\n    const browser = this.getBrowserById(id)\n\n    if (browser) {\n      browser.forceKill().then(callback)\n      return true\n    }\n    process.nextTick(callback)\n    return false\n  }\n\n  restart (id) {\n    const browser = this.getBrowserById(id)\n    if (browser) {\n      browser.restart()\n      return true\n    }\n    return false\n  }\n\n  killAll (callback) {\n    callback = callback || function () {}\n    log.debug('Disconnecting all browsers')\n\n    if (!this._browsers.length) {\n      return process.nextTick(callback)\n    }\n\n    Promise.all(\n      this._browsers\n        .map((browser) => browser.forceKill())\n    ).then(callback)\n  }\n\n  areAllCaptured () {\n    return this._browsers.every((browser) => browser.isCaptured())\n  }\n\n  markCaptured (id) {\n    const browser = this.getBrowserById(id)\n    if (browser) {\n      browser.markCaptured()\n      log.debug(`${browser.name} (id ${browser.id}) captured in ${(Date.now() - this._lastStartTime) / 1000} secs`)\n    }\n  }\n\n  static generateId () {\n    return Math.floor(Math.random() * 100000000).toString()\n  }\n}\n\nLauncher.factory = function (server, emitter, injector) {\n  return new Launcher(server, emitter, injector)\n}\n\nLauncher.factory.$inject = ['server', 'emitter', 'injector']\n\nexports.Launcher = Launcher\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}