{"ast":null,"code":"/* eslint no-underscore-dangle: [\"error\", { \"allow\": [\"_log\"] }] */\nconst debug = require('debug')('log4js:logger');\n\nconst LoggingEvent = require('./LoggingEvent');\n\nconst levels = require('./levels');\n\nconst clustering = require('./clustering');\n\nconst categories = require('./categories');\n\nconst configuration = require('./configuration');\n\nconst stackReg = /at (?:(.+)\\s+\\()?(?:(.+?):(\\d+)(?::(\\d+))?|([^)]+))\\)?/;\n/**\n * The top entry is the Error\n */\n\nconst baseCallStackSkip = 1;\n/**\n * The _log function is 3 levels deep, we need to skip those to make it to the callSite\n */\n\nconst defaultErrorCallStackSkip = 3;\n/**\n *\n * @param {Error} data\n * @param {number} skipIdx\n * @returns {import('../types/log4js').CallStack | null}\n */\n\nfunction defaultParseCallStack(data, skipIdx = defaultErrorCallStackSkip + baseCallStackSkip) {\n  try {\n    const stacklines = data.stack.split('\\n').slice(skipIdx);\n\n    if (!stacklines.length) {\n      // There's no stack in this stack\n      // Should we try a previous index if skipIdx was set?\n      return null;\n    }\n\n    const lineMatch = stackReg.exec(stacklines[0]);\n    /* istanbul ignore else: failsafe */\n\n    if (lineMatch && lineMatch.length === 6) {\n      // extract class, function and alias names\n      let className = '';\n      let functionName = '';\n      let functionAlias = '';\n\n      if (lineMatch[1] && lineMatch[1] !== '') {\n        // WARN: this will unset alias if alias is not present.\n        [functionName, functionAlias] = lineMatch[1].replace(/[[\\]]/g, '').split(' as ');\n        functionAlias = functionAlias || '';\n        if (functionName.includes('.')) [className, functionName] = functionName.split('.');\n      }\n\n      return {\n        fileName: lineMatch[2],\n        lineNumber: parseInt(lineMatch[3], 10),\n        columnNumber: parseInt(lineMatch[4], 10),\n        callStack: stacklines.join('\\n'),\n        className,\n        functionName,\n        functionAlias,\n        callerName: lineMatch[1] || ''\n      }; // eslint-disable-next-line no-else-return\n    } else {\n      // will never get here unless nodejs has changes to Error\n      console.error('log4js.logger - defaultParseCallStack error'); // eslint-disable-line no-console\n    }\n  } catch (err) {\n    // will never get error unless nodejs has breaking changes to Error\n    console.error('log4js.logger - defaultParseCallStack error', err); // eslint-disable-line no-console\n  }\n\n  return null;\n}\n/**\n * Logger to log messages.\n * use {@see log4js#getLogger(String)} to get an instance.\n *\n * @name Logger\n * @namespace Log4js\n * @param name name of category to log to\n * @param level - the loglevel for the category\n * @param dispatch - the function which will receive the logevents\n *\n * @author Stephan Strittmatter\n */\n\n\nclass Logger {\n  constructor(name) {\n    if (!name) {\n      throw new Error('No category provided.');\n    }\n\n    this.category = name;\n    this.context = {};\n    /** @private */\n\n    this.callStackSkipIndex = 0;\n    /** @private */\n\n    this.parseCallStack = defaultParseCallStack;\n    debug(`Logger created (${this.category}, ${this.level})`);\n  }\n\n  get level() {\n    return levels.getLevel(categories.getLevelForCategory(this.category), levels.OFF);\n  }\n\n  set level(level) {\n    categories.setLevelForCategory(this.category, levels.getLevel(level, this.level));\n  }\n\n  get useCallStack() {\n    return categories.getEnableCallStackForCategory(this.category);\n  }\n\n  set useCallStack(bool) {\n    categories.setEnableCallStackForCategory(this.category, bool === true);\n  }\n\n  get callStackLinesToSkip() {\n    return this.callStackSkipIndex;\n  }\n\n  set callStackLinesToSkip(number) {\n    if (typeof number !== 'number') {\n      throw new TypeError('Must be a number');\n    }\n\n    if (number < 0) {\n      throw new RangeError('Must be >= 0');\n    }\n\n    this.callStackSkipIndex = number;\n  }\n\n  log(level, ...args) {\n    const logLevel = levels.getLevel(level);\n\n    if (!logLevel) {\n      if (configuration.validIdentifier(level) && args.length > 0) {\n        // logLevel not found but of valid signature, WARN before fallback to INFO\n        this.log(levels.WARN, 'log4js:logger.log: valid log-level not found as first parameter given:', level);\n        this.log(levels.INFO, `[${level}]`, ...args);\n      } else {\n        // apart from fallback, allow .log(...args) to be synonym with .log(\"INFO\", ...args)\n        this.log(levels.INFO, level, ...args);\n      }\n    } else if (this.isLevelEnabled(logLevel)) {\n      this._log(logLevel, args);\n    }\n  }\n\n  isLevelEnabled(otherLevel) {\n    return this.level.isLessThanOrEqualTo(otherLevel);\n  }\n\n  _log(level, data) {\n    debug(`sending log data (${level}) to appenders`);\n    const error = data.find(item => item instanceof Error);\n    let callStack;\n\n    if (this.useCallStack) {\n      try {\n        if (error) {\n          callStack = this.parseCallStack(error, this.callStackSkipIndex + baseCallStackSkip);\n        }\n      } catch (_err) {// Ignore Error and use the original method of creating a new Error.\n      }\n\n      callStack = callStack || this.parseCallStack(new Error(), this.callStackSkipIndex + defaultErrorCallStackSkip + baseCallStackSkip);\n    }\n\n    const loggingEvent = new LoggingEvent(this.category, level, data, this.context, callStack, error);\n    clustering.send(loggingEvent);\n  }\n\n  addContext(key, value) {\n    this.context[key] = value;\n  }\n\n  removeContext(key) {\n    delete this.context[key];\n  }\n\n  clearContext() {\n    this.context = {};\n  }\n\n  setParseCallStackFunction(parseFunction) {\n    if (typeof parseFunction === 'function') {\n      this.parseCallStack = parseFunction;\n    } else if (typeof parseFunction === 'undefined') {\n      this.parseCallStack = defaultParseCallStack;\n    } else {\n      throw new TypeError('Invalid type passed to setParseCallStackFunction');\n    }\n  }\n\n}\n\nfunction addLevelMethods(target) {\n  const level = levels.getLevel(target);\n  const levelStrLower = level.toString().toLowerCase();\n  const levelMethod = levelStrLower.replace(/_([a-z])/g, g => g[1].toUpperCase());\n  const isLevelMethod = levelMethod[0].toUpperCase() + levelMethod.slice(1);\n\n  Logger.prototype[`is${isLevelMethod}Enabled`] = function () {\n    return this.isLevelEnabled(level);\n  };\n\n  Logger.prototype[levelMethod] = function (...args) {\n    this.log(level, ...args);\n  };\n}\n\nlevels.levels.forEach(addLevelMethods);\nconfiguration.addListener(() => {\n  levels.levels.forEach(addLevelMethods);\n});\nmodule.exports = Logger;","map":{"version":3,"names":["debug","require","LoggingEvent","levels","clustering","categories","configuration","stackReg","baseCallStackSkip","defaultErrorCallStackSkip","defaultParseCallStack","data","skipIdx","stacklines","stack","split","slice","length","lineMatch","exec","className","functionName","functionAlias","replace","includes","fileName","lineNumber","parseInt","columnNumber","callStack","join","callerName","console","error","err","Logger","constructor","name","Error","category","context","callStackSkipIndex","parseCallStack","level","getLevel","getLevelForCategory","OFF","setLevelForCategory","useCallStack","getEnableCallStackForCategory","bool","setEnableCallStackForCategory","callStackLinesToSkip","number","TypeError","RangeError","log","args","logLevel","validIdentifier","WARN","INFO","isLevelEnabled","_log","otherLevel","isLessThanOrEqualTo","find","item","_err","loggingEvent","send","addContext","key","value","removeContext","clearContext","setParseCallStackFunction","parseFunction","addLevelMethods","target","levelStrLower","toString","toLowerCase","levelMethod","g","toUpperCase","isLevelMethod","prototype","forEach","addListener","module","exports"],"sources":["/Users/deliabarbuta/Documents/An4Sem1/PAW/Proiect/proiect-paw-tadam/Frontend_OceanCross/node_modules/log4js/lib/logger.js"],"sourcesContent":["/* eslint no-underscore-dangle: [\"error\", { \"allow\": [\"_log\"] }] */\n\nconst debug = require('debug')('log4js:logger');\nconst LoggingEvent = require('./LoggingEvent');\nconst levels = require('./levels');\nconst clustering = require('./clustering');\nconst categories = require('./categories');\nconst configuration = require('./configuration');\n\nconst stackReg = /at (?:(.+)\\s+\\()?(?:(.+?):(\\d+)(?::(\\d+))?|([^)]+))\\)?/;\n/**\n * The top entry is the Error\n */\nconst baseCallStackSkip = 1;\n/**\n * The _log function is 3 levels deep, we need to skip those to make it to the callSite\n */\nconst defaultErrorCallStackSkip = 3;\n\n/**\n *\n * @param {Error} data\n * @param {number} skipIdx\n * @returns {import('../types/log4js').CallStack | null}\n */\nfunction defaultParseCallStack(\n  data,\n  skipIdx = defaultErrorCallStackSkip + baseCallStackSkip\n) {\n  try {\n    const stacklines = data.stack.split('\\n').slice(skipIdx);\n    if (!stacklines.length) {\n      // There's no stack in this stack\n      // Should we try a previous index if skipIdx was set?\n      return null;\n    }\n    const lineMatch = stackReg.exec(stacklines[0]);\n    /* istanbul ignore else: failsafe */\n    if (lineMatch && lineMatch.length === 6) {\n      // extract class, function and alias names\n      let className = '';\n      let functionName = '';\n      let functionAlias = '';\n      if (lineMatch[1] && lineMatch[1] !== '') {\n        // WARN: this will unset alias if alias is not present.\n        [functionName, functionAlias] = lineMatch[1]\n          .replace(/[[\\]]/g, '')\n          .split(' as ');\n        functionAlias = functionAlias || '';\n\n        if (functionName.includes('.'))\n          [className, functionName] = functionName.split('.');\n      }\n\n      return {\n        fileName: lineMatch[2],\n        lineNumber: parseInt(lineMatch[3], 10),\n        columnNumber: parseInt(lineMatch[4], 10),\n        callStack: stacklines.join('\\n'),\n        className,\n        functionName,\n        functionAlias,\n        callerName: lineMatch[1] || '',\n      };\n      // eslint-disable-next-line no-else-return\n    } else {\n      // will never get here unless nodejs has changes to Error\n      console.error('log4js.logger - defaultParseCallStack error'); // eslint-disable-line no-console\n    }\n  } catch (err) {\n    // will never get error unless nodejs has breaking changes to Error\n    console.error('log4js.logger - defaultParseCallStack error', err); // eslint-disable-line no-console\n  }\n  return null;\n}\n\n/**\n * Logger to log messages.\n * use {@see log4js#getLogger(String)} to get an instance.\n *\n * @name Logger\n * @namespace Log4js\n * @param name name of category to log to\n * @param level - the loglevel for the category\n * @param dispatch - the function which will receive the logevents\n *\n * @author Stephan Strittmatter\n */\nclass Logger {\n  constructor(name) {\n    if (!name) {\n      throw new Error('No category provided.');\n    }\n    this.category = name;\n    this.context = {};\n    /** @private */\n    this.callStackSkipIndex = 0;\n    /** @private */\n    this.parseCallStack = defaultParseCallStack;\n    debug(`Logger created (${this.category}, ${this.level})`);\n  }\n\n  get level() {\n    return levels.getLevel(\n      categories.getLevelForCategory(this.category),\n      levels.OFF\n    );\n  }\n\n  set level(level) {\n    categories.setLevelForCategory(\n      this.category,\n      levels.getLevel(level, this.level)\n    );\n  }\n\n  get useCallStack() {\n    return categories.getEnableCallStackForCategory(this.category);\n  }\n\n  set useCallStack(bool) {\n    categories.setEnableCallStackForCategory(this.category, bool === true);\n  }\n\n  get callStackLinesToSkip() {\n    return this.callStackSkipIndex;\n  }\n\n  set callStackLinesToSkip(number) {\n    if (typeof number !== 'number') {\n      throw new TypeError('Must be a number');\n    }\n    if (number < 0) {\n      throw new RangeError('Must be >= 0');\n    }\n    this.callStackSkipIndex = number;\n  }\n\n  log(level, ...args) {\n    const logLevel = levels.getLevel(level);\n    if (!logLevel) {\n      if (configuration.validIdentifier(level) && args.length > 0) {\n        // logLevel not found but of valid signature, WARN before fallback to INFO\n        this.log(\n          levels.WARN,\n          'log4js:logger.log: valid log-level not found as first parameter given:',\n          level\n        );\n        this.log(levels.INFO, `[${level}]`, ...args);\n      } else {\n        // apart from fallback, allow .log(...args) to be synonym with .log(\"INFO\", ...args)\n        this.log(levels.INFO, level, ...args);\n      }\n    } else if (this.isLevelEnabled(logLevel)) {\n      this._log(logLevel, args);\n    }\n  }\n\n  isLevelEnabled(otherLevel) {\n    return this.level.isLessThanOrEqualTo(otherLevel);\n  }\n\n  _log(level, data) {\n    debug(`sending log data (${level}) to appenders`);\n    const error = data.find((item) => item instanceof Error);\n    let callStack;\n    if (this.useCallStack) {\n      try {\n        if (error) {\n          callStack = this.parseCallStack(\n            error,\n            this.callStackSkipIndex + baseCallStackSkip\n          );\n        }\n      } catch (_err) {\n        // Ignore Error and use the original method of creating a new Error.\n      }\n      callStack =\n        callStack ||\n        this.parseCallStack(\n          new Error(),\n          this.callStackSkipIndex +\n            defaultErrorCallStackSkip +\n            baseCallStackSkip\n        );\n    }\n    const loggingEvent = new LoggingEvent(\n      this.category,\n      level,\n      data,\n      this.context,\n      callStack,\n      error\n    );\n    clustering.send(loggingEvent);\n  }\n\n  addContext(key, value) {\n    this.context[key] = value;\n  }\n\n  removeContext(key) {\n    delete this.context[key];\n  }\n\n  clearContext() {\n    this.context = {};\n  }\n\n  setParseCallStackFunction(parseFunction) {\n    if (typeof parseFunction === 'function') {\n      this.parseCallStack = parseFunction;\n    } else if (typeof parseFunction === 'undefined') {\n      this.parseCallStack = defaultParseCallStack;\n    } else {\n      throw new TypeError('Invalid type passed to setParseCallStackFunction');\n    }\n  }\n}\n\nfunction addLevelMethods(target) {\n  const level = levels.getLevel(target);\n\n  const levelStrLower = level.toString().toLowerCase();\n  const levelMethod = levelStrLower.replace(/_([a-z])/g, (g) =>\n    g[1].toUpperCase()\n  );\n  const isLevelMethod = levelMethod[0].toUpperCase() + levelMethod.slice(1);\n\n  Logger.prototype[`is${isLevelMethod}Enabled`] = function () {\n    return this.isLevelEnabled(level);\n  };\n\n  Logger.prototype[levelMethod] = function (...args) {\n    this.log(level, ...args);\n  };\n}\n\nlevels.levels.forEach(addLevelMethods);\n\nconfiguration.addListener(() => {\n  levels.levels.forEach(addLevelMethods);\n});\n\nmodule.exports = Logger;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}