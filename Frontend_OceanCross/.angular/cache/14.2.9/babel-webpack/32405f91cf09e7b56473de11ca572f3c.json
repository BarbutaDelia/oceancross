{"ast":null,"code":"var _asyncToGenerator = require(\"/Users/deliabarbuta/Documents/An4Sem1/PAW/Proiect/proiect-paw-tadam/Frontend_OceanCross/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _asyncIterator = require(\"/Users/deliabarbuta/Documents/An4Sem1/PAW/Proiect/proiect-paw-tadam/Frontend_OceanCross/node_modules/@babel/runtime/helpers/asyncIterator.js\").default;\n\nconst {\n  isReadableStream\n} = require('./utils');\n\nconst TextDecoder = require('./text-decoder');\n\nconst STACK_OBJECT = 1;\nconst STACK_ARRAY = 2;\nconst decoder = new TextDecoder();\n\nfunction isObject(value) {\n  return value !== null && typeof value === 'object';\n}\n\nfunction adjustPosition(error, parser) {\n  if (error.name === 'SyntaxError' && parser.jsonParseOffset) {\n    error.message = error.message.replace(/at position (\\d+)/, (_, pos) => 'at position ' + (Number(pos) + parser.jsonParseOffset));\n  }\n\n  return error;\n}\n\nfunction append(array, elements) {\n  // Note: Avoid to use array.push(...elements) since it may lead to\n  // \"RangeError: Maximum call stack size exceeded\" for a long arrays\n  const initialLength = array.length;\n  array.length += elements.length;\n\n  for (let i = 0; i < elements.length; i++) {\n    array[initialLength + i] = elements[i];\n  }\n}\n\nmodule.exports = function (chunkEmitter) {\n  let parser = new ChunkParser();\n\n  if (isObject(chunkEmitter) && isReadableStream(chunkEmitter)) {\n    return new Promise((resolve, reject) => {\n      chunkEmitter.on('data', chunk => {\n        try {\n          parser.push(chunk);\n        } catch (e) {\n          reject(adjustPosition(e, parser));\n          parser = null;\n        }\n      }).on('error', e => {\n        parser = null;\n        reject(e);\n      }).on('end', () => {\n        try {\n          resolve(parser.finish());\n        } catch (e) {\n          reject(adjustPosition(e, parser));\n        } finally {\n          parser = null;\n        }\n      });\n    });\n  }\n\n  if (typeof chunkEmitter === 'function') {\n    const iterator = chunkEmitter();\n\n    if (isObject(iterator) && (Symbol.iterator in iterator || Symbol.asyncIterator in iterator)) {\n      return new Promise( /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (resolve, reject) {\n          try {\n            var _iteratorAbruptCompletion = false;\n            var _didIteratorError = false;\n\n            var _iteratorError;\n\n            try {\n              for (var _iterator = _asyncIterator(iterator), _step; _iteratorAbruptCompletion = !(_step = yield _iterator.next()).done; _iteratorAbruptCompletion = false) {\n                const chunk = _step.value;\n                parser.push(chunk);\n              }\n            } catch (err) {\n              _didIteratorError = true;\n              _iteratorError = err;\n            } finally {\n              try {\n                if (_iteratorAbruptCompletion && _iterator.return != null) {\n                  yield _iterator.return();\n                }\n              } finally {\n                if (_didIteratorError) {\n                  throw _iteratorError;\n                }\n              }\n            }\n\n            resolve(parser.finish());\n          } catch (e) {\n            reject(adjustPosition(e, parser));\n          } finally {\n            parser = null;\n          }\n        });\n\n        return function (_x, _x2) {\n          return _ref.apply(this, arguments);\n        };\n      }());\n    }\n  }\n\n  throw new Error('Chunk emitter should be readable stream, generator, ' + 'async generator or function returning an iterable object');\n};\n\nclass ChunkParser {\n  constructor() {\n    this.value = undefined;\n    this.valueStack = null;\n    this.stack = new Array(100);\n    this.lastFlushDepth = 0;\n    this.flushDepth = 0;\n    this.stateString = false;\n    this.stateStringEscape = false;\n    this.pendingByteSeq = null;\n    this.pendingChunk = null;\n    this.chunkOffset = 0;\n    this.jsonParseOffset = 0;\n  }\n\n  parseAndAppend(fragment, wrap) {\n    // Append new entries or elements\n    if (this.stack[this.lastFlushDepth - 1] === STACK_OBJECT) {\n      if (wrap) {\n        this.jsonParseOffset--;\n        fragment = '{' + fragment + '}';\n      }\n\n      Object.assign(this.valueStack.value, JSON.parse(fragment));\n    } else {\n      if (wrap) {\n        this.jsonParseOffset--;\n        fragment = '[' + fragment + ']';\n      }\n\n      append(this.valueStack.value, JSON.parse(fragment));\n    }\n  }\n\n  prepareAddition(fragment) {\n    const {\n      value\n    } = this.valueStack;\n    const expectComma = Array.isArray(value) ? value.length !== 0 : Object.keys(value).length !== 0;\n\n    if (expectComma) {\n      // Skip a comma at the beginning of fragment, otherwise it would\n      // fail to parse\n      if (fragment[0] === ',') {\n        this.jsonParseOffset++;\n        return fragment.slice(1);\n      } // When value (an object or array) is not empty and a fragment\n      // doesn't start with a comma, a single valid fragment starting\n      // is a closing bracket. If it's not, a prefix is adding to fail\n      // parsing. Otherwise, the sequence of chunks can be successfully\n      // parsed, although it should not, e.g. [\"[{}\", \"{}]\"]\n\n\n      if (fragment[0] !== '}' && fragment[0] !== ']') {\n        this.jsonParseOffset -= 3;\n        return '[[]' + fragment;\n      }\n    }\n\n    return fragment;\n  }\n\n  flush(chunk, start, end) {\n    let fragment = chunk.slice(start, end); // Save position correction an error in JSON.parse() if any\n\n    this.jsonParseOffset = this.chunkOffset + start; // Prepend pending chunk if any\n\n    if (this.pendingChunk !== null) {\n      fragment = this.pendingChunk + fragment;\n      this.jsonParseOffset -= this.pendingChunk.length;\n      this.pendingChunk = null;\n    }\n\n    if (this.flushDepth === this.lastFlushDepth) {\n      // Depth didn't changed, so it's a root value or entry/element set\n      if (this.flushDepth > 0) {\n        this.parseAndAppend(this.prepareAddition(fragment), true);\n      } else {\n        // That's an entire value on a top level\n        this.value = JSON.parse(fragment);\n        this.valueStack = {\n          value: this.value,\n          prev: null\n        };\n      }\n    } else if (this.flushDepth > this.lastFlushDepth) {\n      // Add missed closing brackets/parentheses\n      for (let i = this.flushDepth - 1; i >= this.lastFlushDepth; i--) {\n        fragment += this.stack[i] === STACK_OBJECT ? '}' : ']';\n      }\n\n      if (this.lastFlushDepth === 0) {\n        // That's a root value\n        this.value = JSON.parse(fragment);\n        this.valueStack = {\n          value: this.value,\n          prev: null\n        };\n      } else {\n        this.parseAndAppend(this.prepareAddition(fragment), true);\n      } // Move down to the depths to the last object/array, which is current now\n\n\n      for (let i = this.lastFlushDepth || 1; i < this.flushDepth; i++) {\n        let value = this.valueStack.value;\n\n        if (this.stack[i - 1] === STACK_OBJECT) {\n          // find last entry\n          let key; // eslint-disable-next-line curly\n\n          for (key in value);\n\n          value = value[key];\n        } else {\n          // last element\n          value = value[value.length - 1];\n        }\n\n        this.valueStack = {\n          value,\n          prev: this.valueStack\n        };\n      }\n    } else\n      /* this.flushDepth < this.lastFlushDepth */\n      {\n        fragment = this.prepareAddition(fragment); // Add missed opening brackets/parentheses\n\n        for (let i = this.lastFlushDepth - 1; i >= this.flushDepth; i--) {\n          this.jsonParseOffset--;\n          fragment = (this.stack[i] === STACK_OBJECT ? '{' : '[') + fragment;\n        }\n\n        this.parseAndAppend(fragment, false);\n\n        for (let i = this.lastFlushDepth - 1; i >= this.flushDepth; i--) {\n          this.valueStack = this.valueStack.prev;\n        }\n      }\n\n    this.lastFlushDepth = this.flushDepth;\n  }\n\n  push(chunk) {\n    if (typeof chunk !== 'string') {\n      // Suppose chunk is Buffer or Uint8Array\n      // Prepend uncompleted byte sequence if any\n      if (this.pendingByteSeq !== null) {\n        const origRawChunk = chunk;\n        chunk = new Uint8Array(this.pendingByteSeq.length + origRawChunk.length);\n        chunk.set(this.pendingByteSeq);\n        chunk.set(origRawChunk, this.pendingByteSeq.length);\n        this.pendingByteSeq = null;\n      } // In case Buffer/Uint8Array, an input is encoded in UTF8\n      // Seek for parts of uncompleted UTF8 symbol on the ending\n      // This makes sense only if we expect more chunks and last char is not multi-bytes\n\n\n      if (chunk[chunk.length - 1] > 127) {\n        for (let seqLength = 0; seqLength < chunk.length; seqLength++) {\n          const byte = chunk[chunk.length - 1 - seqLength]; // 10xxxxxx - 2nd, 3rd or 4th byte\n          // 110xxxxx – first byte of 2-byte sequence\n          // 1110xxxx - first byte of 3-byte sequence\n          // 11110xxx - first byte of 4-byte sequence\n\n          if (byte >> 6 === 3) {\n            seqLength++; // If the sequence is really incomplete, then preserve it\n            // for the future chunk and cut off it from the current chunk\n\n            if (seqLength !== 4 && byte >> 3 === 0b11110 || seqLength !== 3 && byte >> 4 === 0b1110 || seqLength !== 2 && byte >> 5 === 0b110) {\n              this.pendingByteSeq = chunk.slice(chunk.length - seqLength);\n              chunk = chunk.slice(0, -seqLength);\n            }\n\n            break;\n          }\n        }\n      } // Convert chunk to a string, since single decode per chunk\n      // is much effective than decode multiple small substrings\n\n\n      chunk = decoder.decode(chunk);\n    }\n\n    const chunkLength = chunk.length;\n    let lastFlushPoint = 0;\n    let flushPoint = 0; // Main scan loop\n\n    scan: for (let i = 0; i < chunkLength; i++) {\n      if (this.stateString) {\n        for (; i < chunkLength; i++) {\n          if (this.stateStringEscape) {\n            this.stateStringEscape = false;\n          } else {\n            switch (chunk.charCodeAt(i)) {\n              case 0x22:\n                /* \" */\n                this.stateString = false;\n                continue scan;\n\n              case 0x5C:\n                /* \\ */\n                this.stateStringEscape = true;\n            }\n          }\n        }\n\n        break;\n      }\n\n      switch (chunk.charCodeAt(i)) {\n        case 0x22:\n          /* \" */\n          this.stateString = true;\n          this.stateStringEscape = false;\n          break;\n\n        case 0x2C:\n          /* , */\n          flushPoint = i;\n          break;\n\n        case 0x7B:\n          /* { */\n          // Open an object\n          flushPoint = i + 1;\n          this.stack[this.flushDepth++] = STACK_OBJECT;\n          break;\n\n        case 0x5B:\n          /* [ */\n          // Open an array\n          flushPoint = i + 1;\n          this.stack[this.flushDepth++] = STACK_ARRAY;\n          break;\n\n        case 0x5D:\n        /* ] */\n\n        case 0x7D:\n          /* } */\n          // Close an object or array\n          flushPoint = i + 1;\n          this.flushDepth--;\n\n          if (this.flushDepth < this.lastFlushDepth) {\n            this.flush(chunk, lastFlushPoint, flushPoint);\n            lastFlushPoint = flushPoint;\n          }\n\n          break;\n\n        case 0x09:\n        /* \\t */\n\n        case 0x0A:\n        /* \\n */\n\n        case 0x0D:\n        /* \\r */\n\n        case 0x20:\n          /* space */\n          // Move points forward when they points on current position and it's a whitespace\n          if (lastFlushPoint === i) {\n            lastFlushPoint++;\n          }\n\n          if (flushPoint === i) {\n            flushPoint++;\n          }\n\n          break;\n      }\n    }\n\n    if (flushPoint > lastFlushPoint) {\n      this.flush(chunk, lastFlushPoint, flushPoint);\n    } // Produce pendingChunk if something left\n\n\n    if (flushPoint < chunkLength) {\n      if (this.pendingChunk !== null) {\n        // When there is already a pending chunk then no flush happened,\n        // appending entire chunk to pending one\n        this.pendingChunk += chunk;\n      } else {\n        // Create a pending chunk, it will start with non-whitespace since\n        // flushPoint was moved forward away from whitespaces on scan\n        this.pendingChunk = chunk.slice(flushPoint, chunkLength);\n      }\n    }\n\n    this.chunkOffset += chunkLength;\n  }\n\n  finish() {\n    if (this.pendingChunk !== null) {\n      this.flush('', 0, 0);\n      this.pendingChunk = null;\n    }\n\n    return this.value;\n  }\n\n}\n\n;","map":{"version":3,"names":["isReadableStream","require","TextDecoder","STACK_OBJECT","STACK_ARRAY","decoder","isObject","value","adjustPosition","error","parser","name","jsonParseOffset","message","replace","_","pos","Number","append","array","elements","initialLength","length","i","module","exports","chunkEmitter","ChunkParser","Promise","resolve","reject","on","chunk","push","e","finish","iterator","Symbol","asyncIterator","Error","constructor","undefined","valueStack","stack","Array","lastFlushDepth","flushDepth","stateString","stateStringEscape","pendingByteSeq","pendingChunk","chunkOffset","parseAndAppend","fragment","wrap","Object","assign","JSON","parse","prepareAddition","expectComma","isArray","keys","slice","flush","start","end","prev","key","origRawChunk","Uint8Array","set","seqLength","byte","decode","chunkLength","lastFlushPoint","flushPoint","scan","charCodeAt"],"sources":["/Users/deliabarbuta/Documents/An4Sem1/PAW/Proiect/proiect-paw-tadam/Frontend_OceanCross/node_modules/@discoveryjs/json-ext/src/parse-chunked.js"],"sourcesContent":["const { isReadableStream } = require('./utils');\nconst TextDecoder = require('./text-decoder');\n\nconst STACK_OBJECT = 1;\nconst STACK_ARRAY = 2;\nconst decoder = new TextDecoder();\n\nfunction isObject(value) {\n    return value !== null && typeof value === 'object';\n}\n\nfunction adjustPosition(error, parser) {\n    if (error.name === 'SyntaxError' && parser.jsonParseOffset) {\n        error.message = error.message.replace(/at position (\\d+)/, (_, pos) =>\n            'at position ' + (Number(pos) + parser.jsonParseOffset)\n        );\n    }\n\n    return error;\n}\n\nfunction append(array, elements) {\n    // Note: Avoid to use array.push(...elements) since it may lead to\n    // \"RangeError: Maximum call stack size exceeded\" for a long arrays\n    const initialLength = array.length;\n    array.length += elements.length;\n\n    for (let i = 0; i < elements.length; i++) {\n        array[initialLength + i] = elements[i];\n    }\n}\n\nmodule.exports = function(chunkEmitter) {\n    let parser = new ChunkParser();\n\n    if (isObject(chunkEmitter) && isReadableStream(chunkEmitter)) {\n        return new Promise((resolve, reject) => {\n            chunkEmitter\n                .on('data', chunk => {\n                    try {\n                        parser.push(chunk);\n                    } catch (e) {\n                        reject(adjustPosition(e, parser));\n                        parser = null;\n                    }\n                })\n                .on('error', (e) => {\n                    parser = null;\n                    reject(e);\n                })\n                .on('end', () => {\n                    try {\n                        resolve(parser.finish());\n                    } catch (e) {\n                        reject(adjustPosition(e, parser));\n                    } finally {\n                        parser = null;\n                    }\n                });\n        });\n    }\n\n    if (typeof chunkEmitter === 'function') {\n        const iterator = chunkEmitter();\n\n        if (isObject(iterator) && (Symbol.iterator in iterator || Symbol.asyncIterator in iterator)) {\n            return new Promise(async (resolve, reject) => {\n                try {\n                    for await (const chunk of iterator) {\n                        parser.push(chunk);\n                    }\n\n                    resolve(parser.finish());\n                } catch (e) {\n                    reject(adjustPosition(e, parser));\n                } finally {\n                    parser = null;\n                }\n            });\n        }\n    }\n\n    throw new Error(\n        'Chunk emitter should be readable stream, generator, ' +\n        'async generator or function returning an iterable object'\n    );\n};\n\nclass ChunkParser {\n    constructor() {\n        this.value = undefined;\n        this.valueStack = null;\n\n        this.stack = new Array(100);\n        this.lastFlushDepth = 0;\n        this.flushDepth = 0;\n        this.stateString = false;\n        this.stateStringEscape = false;\n        this.pendingByteSeq = null;\n        this.pendingChunk = null;\n        this.chunkOffset = 0;\n        this.jsonParseOffset = 0;\n    }\n\n    parseAndAppend(fragment, wrap) {\n        // Append new entries or elements\n        if (this.stack[this.lastFlushDepth - 1] === STACK_OBJECT) {\n            if (wrap) {\n                this.jsonParseOffset--;\n                fragment = '{' + fragment + '}';\n            }\n\n            Object.assign(this.valueStack.value, JSON.parse(fragment));\n        } else {\n            if (wrap) {\n                this.jsonParseOffset--;\n                fragment = '[' + fragment + ']';\n            }\n\n            append(this.valueStack.value, JSON.parse(fragment));\n        }\n    }\n\n    prepareAddition(fragment) {\n        const { value } = this.valueStack;\n        const expectComma = Array.isArray(value)\n            ? value.length !== 0\n            : Object.keys(value).length !== 0;\n\n        if (expectComma) {\n            // Skip a comma at the beginning of fragment, otherwise it would\n            // fail to parse\n            if (fragment[0] === ',') {\n                this.jsonParseOffset++;\n                return fragment.slice(1);\n            }\n\n            // When value (an object or array) is not empty and a fragment\n            // doesn't start with a comma, a single valid fragment starting\n            // is a closing bracket. If it's not, a prefix is adding to fail\n            // parsing. Otherwise, the sequence of chunks can be successfully\n            // parsed, although it should not, e.g. [\"[{}\", \"{}]\"]\n            if (fragment[0] !== '}' && fragment[0] !== ']') {\n                this.jsonParseOffset -= 3;\n                return '[[]' + fragment;\n            }\n        }\n\n        return fragment;\n    }\n\n    flush(chunk, start, end) {\n        let fragment = chunk.slice(start, end);\n\n        // Save position correction an error in JSON.parse() if any\n        this.jsonParseOffset = this.chunkOffset + start;\n\n        // Prepend pending chunk if any\n        if (this.pendingChunk !== null) {\n            fragment = this.pendingChunk + fragment;\n            this.jsonParseOffset -= this.pendingChunk.length;\n            this.pendingChunk = null;\n        }\n\n        if (this.flushDepth === this.lastFlushDepth) {\n            // Depth didn't changed, so it's a root value or entry/element set\n            if (this.flushDepth > 0) {\n                this.parseAndAppend(this.prepareAddition(fragment), true);\n            } else {\n                // That's an entire value on a top level\n                this.value = JSON.parse(fragment);\n                this.valueStack = {\n                    value: this.value,\n                    prev: null\n                };\n            }\n        } else if (this.flushDepth > this.lastFlushDepth) {\n            // Add missed closing brackets/parentheses\n            for (let i = this.flushDepth - 1; i >= this.lastFlushDepth; i--) {\n                fragment += this.stack[i] === STACK_OBJECT ? '}' : ']';\n            }\n\n            if (this.lastFlushDepth === 0) {\n                // That's a root value\n                this.value = JSON.parse(fragment);\n                this.valueStack = {\n                    value: this.value,\n                    prev: null\n                };\n            } else {\n                this.parseAndAppend(this.prepareAddition(fragment), true);\n            }\n\n            // Move down to the depths to the last object/array, which is current now\n            for (let i = this.lastFlushDepth || 1; i < this.flushDepth; i++) {\n                let value = this.valueStack.value;\n\n                if (this.stack[i - 1] === STACK_OBJECT) {\n                    // find last entry\n                    let key;\n                    // eslint-disable-next-line curly\n                    for (key in value);\n                    value = value[key];\n                } else {\n                    // last element\n                    value = value[value.length - 1];\n                }\n\n                this.valueStack = {\n                    value,\n                    prev: this.valueStack\n                };\n            }\n        } else /* this.flushDepth < this.lastFlushDepth */ {\n            fragment = this.prepareAddition(fragment);\n\n            // Add missed opening brackets/parentheses\n            for (let i = this.lastFlushDepth - 1; i >= this.flushDepth; i--) {\n                this.jsonParseOffset--;\n                fragment = (this.stack[i] === STACK_OBJECT ? '{' : '[') + fragment;\n            }\n\n            this.parseAndAppend(fragment, false);\n\n            for (let i = this.lastFlushDepth - 1; i >= this.flushDepth; i--) {\n                this.valueStack = this.valueStack.prev;\n            }\n        }\n\n        this.lastFlushDepth = this.flushDepth;\n    }\n\n    push(chunk) {\n        if (typeof chunk !== 'string') {\n            // Suppose chunk is Buffer or Uint8Array\n\n            // Prepend uncompleted byte sequence if any\n            if (this.pendingByteSeq !== null) {\n                const origRawChunk = chunk;\n                chunk = new Uint8Array(this.pendingByteSeq.length + origRawChunk.length);\n                chunk.set(this.pendingByteSeq);\n                chunk.set(origRawChunk, this.pendingByteSeq.length);\n                this.pendingByteSeq = null;\n            }\n\n            // In case Buffer/Uint8Array, an input is encoded in UTF8\n            // Seek for parts of uncompleted UTF8 symbol on the ending\n            // This makes sense only if we expect more chunks and last char is not multi-bytes\n            if (chunk[chunk.length - 1] > 127) {\n                for (let seqLength = 0; seqLength < chunk.length; seqLength++) {\n                    const byte = chunk[chunk.length - 1 - seqLength];\n\n                    // 10xxxxxx - 2nd, 3rd or 4th byte\n                    // 110xxxxx – first byte of 2-byte sequence\n                    // 1110xxxx - first byte of 3-byte sequence\n                    // 11110xxx - first byte of 4-byte sequence\n                    if (byte >> 6 === 3) {\n                        seqLength++;\n\n                        // If the sequence is really incomplete, then preserve it\n                        // for the future chunk and cut off it from the current chunk\n                        if ((seqLength !== 4 && byte >> 3 === 0b11110) ||\n                            (seqLength !== 3 && byte >> 4 === 0b1110) ||\n                            (seqLength !== 2 && byte >> 5 === 0b110)) {\n                            this.pendingByteSeq = chunk.slice(chunk.length - seqLength);\n                            chunk = chunk.slice(0, -seqLength);\n                        }\n\n                        break;\n                    }\n                }\n            }\n\n            // Convert chunk to a string, since single decode per chunk\n            // is much effective than decode multiple small substrings\n            chunk = decoder.decode(chunk);\n        }\n\n        const chunkLength = chunk.length;\n        let lastFlushPoint = 0;\n        let flushPoint = 0;\n\n        // Main scan loop\n        scan: for (let i = 0; i < chunkLength; i++) {\n            if (this.stateString) {\n                for (; i < chunkLength; i++) {\n                    if (this.stateStringEscape) {\n                        this.stateStringEscape = false;\n                    } else {\n                        switch (chunk.charCodeAt(i)) {\n                            case 0x22: /* \" */\n                                this.stateString = false;\n                                continue scan;\n\n                            case 0x5C: /* \\ */\n                                this.stateStringEscape = true;\n                        }\n                    }\n                }\n\n                break;\n            }\n\n            switch (chunk.charCodeAt(i)) {\n                case 0x22: /* \" */\n                    this.stateString = true;\n                    this.stateStringEscape = false;\n                    break;\n\n                case 0x2C: /* , */\n                    flushPoint = i;\n                    break;\n\n                case 0x7B: /* { */\n                    // Open an object\n                    flushPoint = i + 1;\n                    this.stack[this.flushDepth++] = STACK_OBJECT;\n                    break;\n\n                case 0x5B: /* [ */\n                    // Open an array\n                    flushPoint = i + 1;\n                    this.stack[this.flushDepth++] = STACK_ARRAY;\n                    break;\n\n                case 0x5D: /* ] */\n                case 0x7D: /* } */\n                    // Close an object or array\n                    flushPoint = i + 1;\n                    this.flushDepth--;\n\n                    if (this.flushDepth < this.lastFlushDepth) {\n                        this.flush(chunk, lastFlushPoint, flushPoint);\n                        lastFlushPoint = flushPoint;\n                    }\n\n                    break;\n\n                case 0x09: /* \\t */\n                case 0x0A: /* \\n */\n                case 0x0D: /* \\r */\n                case 0x20: /* space */\n                    // Move points forward when they points on current position and it's a whitespace\n                    if (lastFlushPoint === i) {\n                        lastFlushPoint++;\n                    }\n\n                    if (flushPoint === i) {\n                        flushPoint++;\n                    }\n\n                    break;\n            }\n        }\n\n        if (flushPoint > lastFlushPoint) {\n            this.flush(chunk, lastFlushPoint, flushPoint);\n        }\n\n        // Produce pendingChunk if something left\n        if (flushPoint < chunkLength) {\n            if (this.pendingChunk !== null) {\n                // When there is already a pending chunk then no flush happened,\n                // appending entire chunk to pending one\n                this.pendingChunk += chunk;\n            } else {\n                // Create a pending chunk, it will start with non-whitespace since\n                // flushPoint was moved forward away from whitespaces on scan\n                this.pendingChunk = chunk.slice(flushPoint, chunkLength);\n            }\n        }\n\n        this.chunkOffset += chunkLength;\n    }\n\n    finish() {\n        if (this.pendingChunk !== null) {\n            this.flush('', 0, 0);\n            this.pendingChunk = null;\n        }\n\n        return this.value;\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}