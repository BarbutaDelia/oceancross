{"ast":null,"code":"const debug = require('debug')('log4js:categories');\n\nconst configuration = require('./configuration');\n\nconst levels = require('./levels');\n\nconst appenders = require('./appenders');\n\nconst categories = new Map();\n/**\n * Add inherited config to this category.  That includes extra appenders from parent,\n * and level, if none is set on this category.\n * This is recursive, so each parent also gets loaded with inherited appenders.\n * Inheritance is blocked if a category has inherit=false\n * @param  {*} config\n * @param  {*} category the child category\n * @param  {string} categoryName dotted path to category\n * @return {void}\n */\n\nfunction inheritFromParent(config, category, categoryName) {\n  if (category.inherit === false) return;\n  const lastDotIndex = categoryName.lastIndexOf('.');\n  if (lastDotIndex < 0) return; // category is not a child\n\n  const parentCategoryName = categoryName.slice(0, lastDotIndex);\n  let parentCategory = config.categories[parentCategoryName];\n\n  if (!parentCategory) {\n    // parent is missing, so implicitly create it, so that it can inherit from its parents\n    parentCategory = {\n      inherit: true,\n      appenders: []\n    };\n  } // make sure parent has had its inheritance taken care of before pulling its properties to this child\n\n\n  inheritFromParent(config, parentCategory, parentCategoryName); // if the parent is not in the config (because we just created it above),\n  // and it inherited a valid configuration, add it to config.categories\n\n  if (!config.categories[parentCategoryName] && parentCategory.appenders && parentCategory.appenders.length && parentCategory.level) {\n    config.categories[parentCategoryName] = parentCategory;\n  }\n\n  category.appenders = category.appenders || [];\n  category.level = category.level || parentCategory.level; // merge in appenders from parent (parent is already holding its inherited appenders)\n\n  parentCategory.appenders.forEach(ap => {\n    if (!category.appenders.includes(ap)) {\n      category.appenders.push(ap);\n    }\n  });\n  category.parent = parentCategory;\n}\n/**\n * Walk all categories in the config, and pull down any configuration from parent to child.\n * This includes inherited appenders, and level, where level is not set.\n * Inheritance is skipped where a category has inherit=false.\n * @param  {*} config\n */\n\n\nfunction addCategoryInheritance(config) {\n  if (!config.categories) return;\n  const categoryNames = Object.keys(config.categories);\n  categoryNames.forEach(name => {\n    const category = config.categories[name]; // add inherited appenders and level to this category\n\n    inheritFromParent(config, category, name);\n  });\n}\n\nconfiguration.addPreProcessingListener(config => addCategoryInheritance(config));\nconfiguration.addListener(config => {\n  configuration.throwExceptionIf(config, configuration.not(configuration.anObject(config.categories)), 'must have a property \"categories\" of type object.');\n  const categoryNames = Object.keys(config.categories);\n  configuration.throwExceptionIf(config, configuration.not(categoryNames.length), 'must define at least one category.');\n  categoryNames.forEach(name => {\n    const category = config.categories[name];\n    configuration.throwExceptionIf(config, [configuration.not(category.appenders), configuration.not(category.level)], `category \"${name}\" is not valid (must be an object with properties \"appenders\" and \"level\")`);\n    configuration.throwExceptionIf(config, configuration.not(Array.isArray(category.appenders)), `category \"${name}\" is not valid (appenders must be an array of appender names)`);\n    configuration.throwExceptionIf(config, configuration.not(category.appenders.length), `category \"${name}\" is not valid (appenders must contain at least one appender name)`);\n\n    if (Object.prototype.hasOwnProperty.call(category, 'enableCallStack')) {\n      configuration.throwExceptionIf(config, typeof category.enableCallStack !== 'boolean', `category \"${name}\" is not valid (enableCallStack must be boolean type)`);\n    }\n\n    category.appenders.forEach(appender => {\n      configuration.throwExceptionIf(config, configuration.not(appenders.get(appender)), `category \"${name}\" is not valid (appender \"${appender}\" is not defined)`);\n    });\n    configuration.throwExceptionIf(config, configuration.not(levels.getLevel(category.level)), `category \"${name}\" is not valid (level \"${category.level}\" not recognised;` + ` valid levels are ${levels.levels.join(', ')})`);\n  });\n  configuration.throwExceptionIf(config, configuration.not(config.categories.default), 'must define a \"default\" category.');\n});\n\nconst setup = config => {\n  categories.clear();\n\n  if (!config) {\n    return;\n  }\n\n  const categoryNames = Object.keys(config.categories);\n  categoryNames.forEach(name => {\n    const category = config.categories[name];\n    const categoryAppenders = [];\n    category.appenders.forEach(appender => {\n      categoryAppenders.push(appenders.get(appender));\n      debug(`Creating category ${name}`);\n      categories.set(name, {\n        appenders: categoryAppenders,\n        level: levels.getLevel(category.level),\n        enableCallStack: category.enableCallStack || false\n      });\n    });\n  });\n};\n\nconst init = () => {\n  setup();\n};\n\ninit();\nconfiguration.addListener(setup);\n\nconst configForCategory = category => {\n  debug(`configForCategory: searching for config for ${category}`);\n\n  if (categories.has(category)) {\n    debug(`configForCategory: ${category} exists in config, returning it`);\n    return categories.get(category);\n  }\n\n  let sourceCategoryConfig;\n\n  if (category.indexOf('.') > 0) {\n    debug(`configForCategory: ${category} has hierarchy, cloning from parents`);\n    sourceCategoryConfig = { ...configForCategory(category.slice(0, category.lastIndexOf('.')))\n    };\n  } else {\n    if (!categories.has('default')) {\n      setup({\n        categories: {\n          default: {\n            appenders: ['out'],\n            level: 'OFF'\n          }\n        }\n      });\n    }\n\n    debug('configForCategory: cloning default category');\n    sourceCategoryConfig = { ...categories.get('default')\n    };\n  }\n\n  categories.set(category, sourceCategoryConfig);\n  return sourceCategoryConfig;\n};\n\nconst appendersForCategory = category => configForCategory(category).appenders;\n\nconst getLevelForCategory = category => configForCategory(category).level;\n\nconst setLevelForCategory = (category, level) => {\n  configForCategory(category).level = level;\n};\n\nconst getEnableCallStackForCategory = category => configForCategory(category).enableCallStack === true;\n\nconst setEnableCallStackForCategory = (category, useCallStack) => {\n  configForCategory(category).enableCallStack = useCallStack;\n};\n\nmodule.exports = categories;\nmodule.exports = Object.assign(module.exports, {\n  appendersForCategory,\n  getLevelForCategory,\n  setLevelForCategory,\n  getEnableCallStackForCategory,\n  setEnableCallStackForCategory,\n  init\n});","map":{"version":3,"names":["debug","require","configuration","levels","appenders","categories","Map","inheritFromParent","config","category","categoryName","inherit","lastDotIndex","lastIndexOf","parentCategoryName","slice","parentCategory","length","level","forEach","ap","includes","push","parent","addCategoryInheritance","categoryNames","Object","keys","name","addPreProcessingListener","addListener","throwExceptionIf","not","anObject","Array","isArray","prototype","hasOwnProperty","call","enableCallStack","appender","get","getLevel","join","default","setup","clear","categoryAppenders","set","init","configForCategory","has","sourceCategoryConfig","indexOf","appendersForCategory","getLevelForCategory","setLevelForCategory","getEnableCallStackForCategory","setEnableCallStackForCategory","useCallStack","module","exports","assign"],"sources":["/Users/deliabarbuta/Documents/An4Sem1/PAW/Proiect/proiect-paw-tadam/Frontend_OceanCross/node_modules/log4js/lib/categories.js"],"sourcesContent":["const debug = require('debug')('log4js:categories');\nconst configuration = require('./configuration');\nconst levels = require('./levels');\nconst appenders = require('./appenders');\n\nconst categories = new Map();\n\n/**\n * Add inherited config to this category.  That includes extra appenders from parent,\n * and level, if none is set on this category.\n * This is recursive, so each parent also gets loaded with inherited appenders.\n * Inheritance is blocked if a category has inherit=false\n * @param  {*} config\n * @param  {*} category the child category\n * @param  {string} categoryName dotted path to category\n * @return {void}\n */\nfunction inheritFromParent(config, category, categoryName) {\n  if (category.inherit === false) return;\n  const lastDotIndex = categoryName.lastIndexOf('.');\n  if (lastDotIndex < 0) return; // category is not a child\n  const parentCategoryName = categoryName.slice(0, lastDotIndex);\n  let parentCategory = config.categories[parentCategoryName];\n\n  if (!parentCategory) {\n    // parent is missing, so implicitly create it, so that it can inherit from its parents\n    parentCategory = { inherit: true, appenders: [] };\n  }\n\n  // make sure parent has had its inheritance taken care of before pulling its properties to this child\n  inheritFromParent(config, parentCategory, parentCategoryName);\n\n  // if the parent is not in the config (because we just created it above),\n  // and it inherited a valid configuration, add it to config.categories\n  if (\n    !config.categories[parentCategoryName] &&\n    parentCategory.appenders &&\n    parentCategory.appenders.length &&\n    parentCategory.level\n  ) {\n    config.categories[parentCategoryName] = parentCategory;\n  }\n\n  category.appenders = category.appenders || [];\n  category.level = category.level || parentCategory.level;\n\n  // merge in appenders from parent (parent is already holding its inherited appenders)\n  parentCategory.appenders.forEach((ap) => {\n    if (!category.appenders.includes(ap)) {\n      category.appenders.push(ap);\n    }\n  });\n  category.parent = parentCategory;\n}\n\n/**\n * Walk all categories in the config, and pull down any configuration from parent to child.\n * This includes inherited appenders, and level, where level is not set.\n * Inheritance is skipped where a category has inherit=false.\n * @param  {*} config\n */\nfunction addCategoryInheritance(config) {\n  if (!config.categories) return;\n  const categoryNames = Object.keys(config.categories);\n  categoryNames.forEach((name) => {\n    const category = config.categories[name];\n    // add inherited appenders and level to this category\n    inheritFromParent(config, category, name);\n  });\n}\n\nconfiguration.addPreProcessingListener((config) =>\n  addCategoryInheritance(config)\n);\n\nconfiguration.addListener((config) => {\n  configuration.throwExceptionIf(\n    config,\n    configuration.not(configuration.anObject(config.categories)),\n    'must have a property \"categories\" of type object.'\n  );\n\n  const categoryNames = Object.keys(config.categories);\n  configuration.throwExceptionIf(\n    config,\n    configuration.not(categoryNames.length),\n    'must define at least one category.'\n  );\n\n  categoryNames.forEach((name) => {\n    const category = config.categories[name];\n    configuration.throwExceptionIf(\n      config,\n      [\n        configuration.not(category.appenders),\n        configuration.not(category.level),\n      ],\n      `category \"${name}\" is not valid (must be an object with properties \"appenders\" and \"level\")`\n    );\n\n    configuration.throwExceptionIf(\n      config,\n      configuration.not(Array.isArray(category.appenders)),\n      `category \"${name}\" is not valid (appenders must be an array of appender names)`\n    );\n\n    configuration.throwExceptionIf(\n      config,\n      configuration.not(category.appenders.length),\n      `category \"${name}\" is not valid (appenders must contain at least one appender name)`\n    );\n\n    if (Object.prototype.hasOwnProperty.call(category, 'enableCallStack')) {\n      configuration.throwExceptionIf(\n        config,\n        typeof category.enableCallStack !== 'boolean',\n        `category \"${name}\" is not valid (enableCallStack must be boolean type)`\n      );\n    }\n\n    category.appenders.forEach((appender) => {\n      configuration.throwExceptionIf(\n        config,\n        configuration.not(appenders.get(appender)),\n        `category \"${name}\" is not valid (appender \"${appender}\" is not defined)`\n      );\n    });\n\n    configuration.throwExceptionIf(\n      config,\n      configuration.not(levels.getLevel(category.level)),\n      `category \"${name}\" is not valid (level \"${category.level}\" not recognised;` +\n        ` valid levels are ${levels.levels.join(', ')})`\n    );\n  });\n\n  configuration.throwExceptionIf(\n    config,\n    configuration.not(config.categories.default),\n    'must define a \"default\" category.'\n  );\n});\n\nconst setup = (config) => {\n  categories.clear();\n  if (!config) {\n    return;\n  }\n\n  const categoryNames = Object.keys(config.categories);\n  categoryNames.forEach((name) => {\n    const category = config.categories[name];\n    const categoryAppenders = [];\n    category.appenders.forEach((appender) => {\n      categoryAppenders.push(appenders.get(appender));\n      debug(`Creating category ${name}`);\n      categories.set(name, {\n        appenders: categoryAppenders,\n        level: levels.getLevel(category.level),\n        enableCallStack: category.enableCallStack || false,\n      });\n    });\n  });\n};\n\nconst init = () => {\n  setup();\n};\ninit();\n\nconfiguration.addListener(setup);\n\nconst configForCategory = (category) => {\n  debug(`configForCategory: searching for config for ${category}`);\n  if (categories.has(category)) {\n    debug(`configForCategory: ${category} exists in config, returning it`);\n    return categories.get(category);\n  }\n\n  let sourceCategoryConfig;\n  if (category.indexOf('.') > 0) {\n    debug(`configForCategory: ${category} has hierarchy, cloning from parents`);\n    sourceCategoryConfig = {\n      ...configForCategory(category.slice(0, category.lastIndexOf('.'))),\n    };\n  } else {\n    if (!categories.has('default')) {\n      setup({ categories: { default: { appenders: ['out'], level: 'OFF' } } });\n    }\n    debug('configForCategory: cloning default category');\n    sourceCategoryConfig = { ...categories.get('default') };\n  }\n  categories.set(category, sourceCategoryConfig);\n  return sourceCategoryConfig;\n};\n\nconst appendersForCategory = (category) =>\n  configForCategory(category).appenders;\n\nconst getLevelForCategory = (category) => configForCategory(category).level;\nconst setLevelForCategory = (category, level) => {\n  configForCategory(category).level = level;\n};\n\nconst getEnableCallStackForCategory = (category) =>\n  configForCategory(category).enableCallStack === true;\nconst setEnableCallStackForCategory = (category, useCallStack) => {\n  configForCategory(category).enableCallStack = useCallStack;\n};\n\nmodule.exports = categories;\nmodule.exports = Object.assign(module.exports, {\n  appendersForCategory,\n  getLevelForCategory,\n  setLevelForCategory,\n  getEnableCallStackForCategory,\n  setEnableCallStackForCategory,\n  init,\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}