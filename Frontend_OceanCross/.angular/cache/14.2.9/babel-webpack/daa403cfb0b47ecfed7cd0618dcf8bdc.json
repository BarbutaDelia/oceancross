{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"/Users/deliabarbuta/Documents/An4Sem1/PAW/Proiect/proiect-paw-tadam/Frontend_OceanCross/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.fetchFromURL = fetchFromURL;\nexports.flattenSourceMap = flattenSourceMap;\nexports.getSourceMappingURL = getSourceMappingURL;\n\nvar _path = _interopRequireDefault(require(\"path\"));\n\nvar _url = _interopRequireDefault(require(\"url\"));\n\nvar _sourceMapJs = _interopRequireDefault(require(\"source-map-js\"));\n\nvar _iconvLite = require(\"iconv-lite\");\n\nvar _parseDataUrl = _interopRequireDefault(require(\"./parse-data-url\"));\n\nvar _labelsToNames = _interopRequireDefault(require(\"./labels-to-names\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n} // Matches only the last occurrence of sourceMappingURL\n\n\nconst innerRegex = /\\s*[#@]\\s*sourceMappingURL\\s*=\\s*([^\\s'\"]*)\\s*/;\n/* eslint-disable prefer-template */\n\nconst sourceMappingURLRegex = RegExp(\"(?:\" + \"/\\\\*\" + \"(?:\\\\s*\\r?\\n(?://)?)?\" + \"(?:\" + innerRegex.source + \")\" + \"\\\\s*\" + \"\\\\*/\" + \"|\" + \"//(?:\" + innerRegex.source + \")\" + \")\" + \"\\\\s*\");\n/* eslint-enable prefer-template */\n\nfunction labelToName(label) {\n  const labelLowercase = String(label).trim().toLowerCase();\n  return _labelsToNames.default[labelLowercase] || null;\n}\n\nfunction flattenSourceMap(_x) {\n  return _flattenSourceMap.apply(this, arguments);\n}\n\nfunction _flattenSourceMap() {\n  _flattenSourceMap = _asyncToGenerator(function* (map) {\n    const consumer = yield new _sourceMapJs.default.SourceMapConsumer(map);\n    const generatedMap = map.file ? new _sourceMapJs.default.SourceMapGenerator({\n      file: map.file\n    }) : new _sourceMapJs.default.SourceMapGenerator();\n    consumer.sources.forEach(sourceFile => {\n      const sourceContent = consumer.sourceContentFor(sourceFile, true);\n      generatedMap.setSourceContent(sourceFile, sourceContent);\n    });\n    consumer.eachMapping(mapping => {\n      const {\n        source\n      } = consumer.originalPositionFor({\n        line: mapping.generatedLine,\n        column: mapping.generatedColumn\n      });\n      const mappings = {\n        source,\n        original: {\n          line: mapping.originalLine,\n          column: mapping.originalColumn\n        },\n        generated: {\n          line: mapping.generatedLine,\n          column: mapping.generatedColumn\n        }\n      };\n\n      if (source) {\n        generatedMap.addMapping(mappings);\n      }\n    });\n    return generatedMap.toJSON();\n  });\n  return _flattenSourceMap.apply(this, arguments);\n}\n\nfunction getSourceMappingURL(code) {\n  const lines = code.split(/^/m);\n  let match;\n\n  for (let i = lines.length - 1; i >= 0; i--) {\n    match = lines[i].match(sourceMappingURLRegex);\n\n    if (match) {\n      break;\n    }\n  }\n\n  const sourceMappingURL = match ? match[1] || match[2] || \"\" : null;\n  return {\n    sourceMappingURL: sourceMappingURL ? decodeURI(sourceMappingURL) : sourceMappingURL,\n    replacementString: match ? match[0] : null\n  };\n}\n\nfunction getAbsolutePath(context, request, sourceRoot) {\n  if (sourceRoot) {\n    if (_path.default.isAbsolute(sourceRoot)) {\n      return _path.default.join(sourceRoot, request);\n    }\n\n    return _path.default.join(context, sourceRoot, request);\n  }\n\n  return _path.default.join(context, request);\n}\n\nfunction fetchFromDataURL(loaderContext, sourceURL) {\n  const dataURL = (0, _parseDataUrl.default)(sourceURL);\n\n  if (dataURL) {\n    // https://tools.ietf.org/html/rfc4627\n    // JSON text SHALL be encoded in Unicode. The default encoding is UTF-8.\n    const encodingName = labelToName(dataURL.parameters.get(\"charset\")) || \"UTF-8\";\n    return (0, _iconvLite.decode)(dataURL.body, encodingName);\n  }\n\n  throw new Error(`Failed to parse source map from \"data\" URL: ${sourceURL}`);\n}\n\nfunction fetchFromFilesystem(_x2, _x3) {\n  return _fetchFromFilesystem.apply(this, arguments);\n}\n\nfunction _fetchFromFilesystem() {\n  _fetchFromFilesystem = _asyncToGenerator(function* (loaderContext, sourceURL) {\n    let buffer;\n\n    try {\n      buffer = yield new Promise((resolve, reject) => {\n        loaderContext.fs.readFile(sourceURL, (error, data) => {\n          if (error) {\n            return reject(error);\n          }\n\n          return resolve(data);\n        });\n      });\n    } catch (error) {\n      throw new Error(`Failed to parse source map from '${sourceURL}' file: ${error}`);\n    }\n\n    return {\n      path: sourceURL,\n      data: buffer.toString()\n    };\n  });\n  return _fetchFromFilesystem.apply(this, arguments);\n}\n\nfunction fetchPathsFromFilesystem(_x4, _x5) {\n  return _fetchPathsFromFilesystem.apply(this, arguments);\n}\n\nfunction _fetchPathsFromFilesystem() {\n  _fetchPathsFromFilesystem = _asyncToGenerator(function* (loaderContext, possibleRequests, errorsAccumulator = \"\") {\n    let result;\n\n    try {\n      result = yield fetchFromFilesystem(loaderContext, possibleRequests[0], errorsAccumulator);\n    } catch (error) {\n      // eslint-disable-next-line no-param-reassign\n      errorsAccumulator += `${error.message}\\n\\n`;\n      const [, ...tailPossibleRequests] = possibleRequests;\n\n      if (tailPossibleRequests.length === 0) {\n        error.message = errorsAccumulator;\n        throw error;\n      }\n\n      return fetchPathsFromFilesystem(loaderContext, tailPossibleRequests, errorsAccumulator);\n    }\n\n    return result;\n  });\n  return _fetchPathsFromFilesystem.apply(this, arguments);\n}\n\nfunction fetchFromURL(_x6, _x7, _x8, _x9) {\n  return _fetchFromURL.apply(this, arguments);\n}\n\nfunction _fetchFromURL() {\n  _fetchFromURL = _asyncToGenerator(function* (loaderContext, context, url, sourceRoot, skipReading = false) {\n    // 1. It's an absolute url and it is not `windows` path like `C:\\dir\\file`\n    if (/^[a-z][a-z0-9+.-]*:/i.test(url) && !_path.default.win32.isAbsolute(url)) {\n      const {\n        protocol\n      } = _url.default.parse(url);\n\n      if (protocol === \"data:\") {\n        if (skipReading) {\n          return {\n            sourceURL: \"\"\n          };\n        }\n\n        const sourceContent = fetchFromDataURL(loaderContext, url);\n        return {\n          sourceURL: \"\",\n          sourceContent\n        };\n      }\n\n      if (skipReading) {\n        return {\n          sourceURL: url\n        };\n      }\n\n      if (protocol === \"file:\") {\n        const pathFromURL = _url.default.fileURLToPath(url);\n\n        const sourceURL = _path.default.normalize(pathFromURL);\n\n        const {\n          data: sourceContent\n        } = yield fetchFromFilesystem(loaderContext, sourceURL);\n        return {\n          sourceURL,\n          sourceContent\n        };\n      }\n\n      throw new Error(`Failed to parse source map: '${url}' URL is not supported`);\n    } // 2. It's a scheme-relative\n\n\n    if (/^\\/\\//.test(url)) {\n      throw new Error(`Failed to parse source map: '${url}' URL is not supported`);\n    } // 3. Absolute path\n\n\n    if (_path.default.isAbsolute(url)) {\n      let sourceURL = _path.default.normalize(url);\n\n      let sourceContent;\n\n      if (!skipReading) {\n        const possibleRequests = [sourceURL];\n\n        if (url.startsWith(\"/\")) {\n          possibleRequests.push(getAbsolutePath(context, sourceURL.slice(1), sourceRoot));\n        }\n\n        const result = yield fetchPathsFromFilesystem(loaderContext, possibleRequests);\n        sourceURL = result.path;\n        sourceContent = result.data;\n      }\n\n      return {\n        sourceURL,\n        sourceContent\n      };\n    } // 4. Relative path\n\n\n    const sourceURL = getAbsolutePath(context, url, sourceRoot);\n    let sourceContent;\n\n    if (!skipReading) {\n      const {\n        data\n      } = yield fetchFromFilesystem(loaderContext, sourceURL);\n      sourceContent = data;\n    }\n\n    return {\n      sourceURL,\n      sourceContent\n    };\n  });\n  return _fetchFromURL.apply(this, arguments);\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","fetchFromURL","flattenSourceMap","getSourceMappingURL","_path","_interopRequireDefault","require","_url","_sourceMapJs","_iconvLite","_parseDataUrl","_labelsToNames","obj","__esModule","default","innerRegex","sourceMappingURLRegex","RegExp","source","labelToName","label","labelLowercase","String","trim","toLowerCase","map","consumer","SourceMapConsumer","generatedMap","file","SourceMapGenerator","sources","forEach","sourceFile","sourceContent","sourceContentFor","setSourceContent","eachMapping","mapping","originalPositionFor","line","generatedLine","column","generatedColumn","mappings","original","originalLine","originalColumn","generated","addMapping","toJSON","code","lines","split","match","i","length","sourceMappingURL","decodeURI","replacementString","getAbsolutePath","context","request","sourceRoot","isAbsolute","join","fetchFromDataURL","loaderContext","sourceURL","dataURL","encodingName","parameters","get","decode","body","Error","fetchFromFilesystem","buffer","Promise","resolve","reject","fs","readFile","error","data","path","toString","fetchPathsFromFilesystem","possibleRequests","errorsAccumulator","result","message","tailPossibleRequests","url","skipReading","test","win32","protocol","parse","pathFromURL","fileURLToPath","normalize","startsWith","push","slice"],"sources":["/Users/deliabarbuta/Documents/An4Sem1/PAW/Proiect/proiect-paw-tadam/Frontend_OceanCross/node_modules/source-map-loader/dist/utils.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.fetchFromURL = fetchFromURL;\nexports.flattenSourceMap = flattenSourceMap;\nexports.getSourceMappingURL = getSourceMappingURL;\n\nvar _path = _interopRequireDefault(require(\"path\"));\n\nvar _url = _interopRequireDefault(require(\"url\"));\n\nvar _sourceMapJs = _interopRequireDefault(require(\"source-map-js\"));\n\nvar _iconvLite = require(\"iconv-lite\");\n\nvar _parseDataUrl = _interopRequireDefault(require(\"./parse-data-url\"));\n\nvar _labelsToNames = _interopRequireDefault(require(\"./labels-to-names\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// Matches only the last occurrence of sourceMappingURL\nconst innerRegex = /\\s*[#@]\\s*sourceMappingURL\\s*=\\s*([^\\s'\"]*)\\s*/;\n/* eslint-disable prefer-template */\n\nconst sourceMappingURLRegex = RegExp(\"(?:\" + \"/\\\\*\" + \"(?:\\\\s*\\r?\\n(?://)?)?\" + \"(?:\" + innerRegex.source + \")\" + \"\\\\s*\" + \"\\\\*/\" + \"|\" + \"//(?:\" + innerRegex.source + \")\" + \")\" + \"\\\\s*\");\n/* eslint-enable prefer-template */\n\nfunction labelToName(label) {\n  const labelLowercase = String(label).trim().toLowerCase();\n  return _labelsToNames.default[labelLowercase] || null;\n}\n\nasync function flattenSourceMap(map) {\n  const consumer = await new _sourceMapJs.default.SourceMapConsumer(map);\n  const generatedMap = map.file ? new _sourceMapJs.default.SourceMapGenerator({\n    file: map.file\n  }) : new _sourceMapJs.default.SourceMapGenerator();\n  consumer.sources.forEach(sourceFile => {\n    const sourceContent = consumer.sourceContentFor(sourceFile, true);\n    generatedMap.setSourceContent(sourceFile, sourceContent);\n  });\n  consumer.eachMapping(mapping => {\n    const {\n      source\n    } = consumer.originalPositionFor({\n      line: mapping.generatedLine,\n      column: mapping.generatedColumn\n    });\n    const mappings = {\n      source,\n      original: {\n        line: mapping.originalLine,\n        column: mapping.originalColumn\n      },\n      generated: {\n        line: mapping.generatedLine,\n        column: mapping.generatedColumn\n      }\n    };\n\n    if (source) {\n      generatedMap.addMapping(mappings);\n    }\n  });\n  return generatedMap.toJSON();\n}\n\nfunction getSourceMappingURL(code) {\n  const lines = code.split(/^/m);\n  let match;\n\n  for (let i = lines.length - 1; i >= 0; i--) {\n    match = lines[i].match(sourceMappingURLRegex);\n\n    if (match) {\n      break;\n    }\n  }\n\n  const sourceMappingURL = match ? match[1] || match[2] || \"\" : null;\n  return {\n    sourceMappingURL: sourceMappingURL ? decodeURI(sourceMappingURL) : sourceMappingURL,\n    replacementString: match ? match[0] : null\n  };\n}\n\nfunction getAbsolutePath(context, request, sourceRoot) {\n  if (sourceRoot) {\n    if (_path.default.isAbsolute(sourceRoot)) {\n      return _path.default.join(sourceRoot, request);\n    }\n\n    return _path.default.join(context, sourceRoot, request);\n  }\n\n  return _path.default.join(context, request);\n}\n\nfunction fetchFromDataURL(loaderContext, sourceURL) {\n  const dataURL = (0, _parseDataUrl.default)(sourceURL);\n\n  if (dataURL) {\n    // https://tools.ietf.org/html/rfc4627\n    // JSON text SHALL be encoded in Unicode. The default encoding is UTF-8.\n    const encodingName = labelToName(dataURL.parameters.get(\"charset\")) || \"UTF-8\";\n    return (0, _iconvLite.decode)(dataURL.body, encodingName);\n  }\n\n  throw new Error(`Failed to parse source map from \"data\" URL: ${sourceURL}`);\n}\n\nasync function fetchFromFilesystem(loaderContext, sourceURL) {\n  let buffer;\n\n  try {\n    buffer = await new Promise((resolve, reject) => {\n      loaderContext.fs.readFile(sourceURL, (error, data) => {\n        if (error) {\n          return reject(error);\n        }\n\n        return resolve(data);\n      });\n    });\n  } catch (error) {\n    throw new Error(`Failed to parse source map from '${sourceURL}' file: ${error}`);\n  }\n\n  return {\n    path: sourceURL,\n    data: buffer.toString()\n  };\n}\n\nasync function fetchPathsFromFilesystem(loaderContext, possibleRequests, errorsAccumulator = \"\") {\n  let result;\n\n  try {\n    result = await fetchFromFilesystem(loaderContext, possibleRequests[0], errorsAccumulator);\n  } catch (error) {\n    // eslint-disable-next-line no-param-reassign\n    errorsAccumulator += `${error.message}\\n\\n`;\n    const [, ...tailPossibleRequests] = possibleRequests;\n\n    if (tailPossibleRequests.length === 0) {\n      error.message = errorsAccumulator;\n      throw error;\n    }\n\n    return fetchPathsFromFilesystem(loaderContext, tailPossibleRequests, errorsAccumulator);\n  }\n\n  return result;\n}\n\nasync function fetchFromURL(loaderContext, context, url, sourceRoot, skipReading = false) {\n  // 1. It's an absolute url and it is not `windows` path like `C:\\dir\\file`\n  if (/^[a-z][a-z0-9+.-]*:/i.test(url) && !_path.default.win32.isAbsolute(url)) {\n    const {\n      protocol\n    } = _url.default.parse(url);\n\n    if (protocol === \"data:\") {\n      if (skipReading) {\n        return {\n          sourceURL: \"\"\n        };\n      }\n\n      const sourceContent = fetchFromDataURL(loaderContext, url);\n      return {\n        sourceURL: \"\",\n        sourceContent\n      };\n    }\n\n    if (skipReading) {\n      return {\n        sourceURL: url\n      };\n    }\n\n    if (protocol === \"file:\") {\n      const pathFromURL = _url.default.fileURLToPath(url);\n\n      const sourceURL = _path.default.normalize(pathFromURL);\n\n      const {\n        data: sourceContent\n      } = await fetchFromFilesystem(loaderContext, sourceURL);\n      return {\n        sourceURL,\n        sourceContent\n      };\n    }\n\n    throw new Error(`Failed to parse source map: '${url}' URL is not supported`);\n  } // 2. It's a scheme-relative\n\n\n  if (/^\\/\\//.test(url)) {\n    throw new Error(`Failed to parse source map: '${url}' URL is not supported`);\n  } // 3. Absolute path\n\n\n  if (_path.default.isAbsolute(url)) {\n    let sourceURL = _path.default.normalize(url);\n\n    let sourceContent;\n\n    if (!skipReading) {\n      const possibleRequests = [sourceURL];\n\n      if (url.startsWith(\"/\")) {\n        possibleRequests.push(getAbsolutePath(context, sourceURL.slice(1), sourceRoot));\n      }\n\n      const result = await fetchPathsFromFilesystem(loaderContext, possibleRequests);\n      sourceURL = result.path;\n      sourceContent = result.data;\n    }\n\n    return {\n      sourceURL,\n      sourceContent\n    };\n  } // 4. Relative path\n\n\n  const sourceURL = getAbsolutePath(context, url, sourceRoot);\n  let sourceContent;\n\n  if (!skipReading) {\n    const {\n      data\n    } = await fetchFromFilesystem(loaderContext, sourceURL);\n    sourceContent = data;\n  }\n\n  return {\n    sourceURL,\n    sourceContent\n  };\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}