{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar _asyncToGenerator = require(\"/Users/deliabarbuta/Documents/An4Sem1/PAW/Proiect/proiect-paw-tadam/Frontend_OceanCross/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.augmentIndexHtml = void 0;\n\nconst crypto_1 = require(\"crypto\");\n\nconst load_esm_1 = require(\"../load-esm\");\n\nconst html_rewriting_stream_1 = require(\"./html-rewriting-stream\");\n/*\n * Helper function used by the IndexHtmlWebpackPlugin.\n * Can also be directly used by builder, e. g. in order to generate an index.html\n * after processing several configurations in order to build different sets of\n * bundles for differential serving.\n */\n\n\nfunction augmentIndexHtml(_x) {\n  return _augmentIndexHtml.apply(this, arguments);\n}\n\nfunction _augmentIndexHtml() {\n  _augmentIndexHtml = _asyncToGenerator(function* (params) {\n    const {\n      loadOutputFile,\n      files,\n      entrypoints,\n      sri,\n      deployUrl = '',\n      lang,\n      baseHref,\n      html\n    } = params;\n    const warnings = [];\n    const errors = [];\n    let {\n      crossOrigin = 'none'\n    } = params;\n\n    if (sri && crossOrigin === 'none') {\n      crossOrigin = 'anonymous';\n    }\n\n    const stylesheets = new Set();\n    const scripts = new Map(); // Sort files in the order we want to insert them by entrypoint\n\n    for (const [entrypoint, isModule] of entrypoints) {\n      for (const {\n        extension,\n        file,\n        name\n      } of files) {\n        if (name !== entrypoint || scripts.has(file) || stylesheets.has(file)) {\n          continue;\n        }\n\n        switch (extension) {\n          case '.js':\n            // Also, non entrypoints need to be loaded as no module as they can contain problematic code.\n            scripts.set(file, isModule);\n            break;\n\n          case '.css':\n            stylesheets.add(file);\n            break;\n        }\n      }\n    }\n\n    let scriptTags = [];\n\n    for (const [src, isModule] of scripts) {\n      const attrs = [`src=\"${deployUrl}${src}\"`]; // This is also need for non entry-points as they may contain problematic code.\n\n      if (isModule) {\n        attrs.push('type=\"module\"');\n      } else {\n        attrs.push('defer');\n      }\n\n      if (crossOrigin !== 'none') {\n        attrs.push(`crossorigin=\"${crossOrigin}\"`);\n      }\n\n      if (sri) {\n        const content = yield loadOutputFile(src);\n        attrs.push(generateSriAttributes(content));\n      }\n\n      scriptTags.push(`<script ${attrs.join(' ')}></script>`);\n    }\n\n    let linkTags = [];\n\n    for (const src of stylesheets) {\n      const attrs = [`rel=\"stylesheet\"`, `href=\"${deployUrl}${src}\"`];\n\n      if (crossOrigin !== 'none') {\n        attrs.push(`crossorigin=\"${crossOrigin}\"`);\n      }\n\n      if (sri) {\n        const content = yield loadOutputFile(src);\n        attrs.push(generateSriAttributes(content));\n      }\n\n      linkTags.push(`<link ${attrs.join(' ')}>`);\n    }\n\n    const dir = lang ? yield getLanguageDirection(lang, warnings) : undefined;\n    const {\n      rewriter,\n      transformedContent\n    } = yield (0, html_rewriting_stream_1.htmlRewritingStream)(html);\n    const baseTagExists = html.includes('<base');\n    rewriter.on('startTag', tag => {\n      switch (tag.tagName) {\n        case 'html':\n          // Adjust document locale if specified\n          if (isString(lang)) {\n            updateAttribute(tag, 'lang', lang);\n          }\n\n          if (dir) {\n            updateAttribute(tag, 'dir', dir);\n          }\n\n          break;\n\n        case 'head':\n          // Base href should be added before any link, meta tags\n          if (!baseTagExists && isString(baseHref)) {\n            rewriter.emitStartTag(tag);\n            rewriter.emitRaw(`<base href=\"${baseHref}\">`);\n            return;\n          }\n\n          break;\n\n        case 'base':\n          // Adjust base href if specified\n          if (isString(baseHref)) {\n            updateAttribute(tag, 'href', baseHref);\n          }\n\n          break;\n      }\n\n      rewriter.emitStartTag(tag);\n    }).on('endTag', tag => {\n      switch (tag.tagName) {\n        case 'head':\n          for (const linkTag of linkTags) {\n            rewriter.emitRaw(linkTag);\n          }\n\n          linkTags = [];\n          break;\n\n        case 'body':\n          // Add script tags\n          for (const scriptTag of scriptTags) {\n            rewriter.emitRaw(scriptTag);\n          }\n\n          scriptTags = [];\n          break;\n      }\n\n      rewriter.emitEndTag(tag);\n    });\n    const content = yield transformedContent;\n    return {\n      content: linkTags.length || scriptTags.length ? // In case no body/head tags are not present (dotnet partial templates)\n      linkTags.join('') + scriptTags.join('') + content : content,\n      warnings,\n      errors\n    };\n  });\n  return _augmentIndexHtml.apply(this, arguments);\n}\n\nexports.augmentIndexHtml = augmentIndexHtml;\n\nfunction generateSriAttributes(content) {\n  const algo = 'sha384';\n  const hash = (0, crypto_1.createHash)(algo).update(content, 'utf8').digest('base64');\n  return `integrity=\"${algo}-${hash}\"`;\n}\n\nfunction updateAttribute(tag, name, value) {\n  const index = tag.attrs.findIndex(a => a.name === name);\n  const newValue = {\n    name,\n    value\n  };\n\n  if (index === -1) {\n    tag.attrs.push(newValue);\n  } else {\n    tag.attrs[index] = newValue;\n  }\n}\n\nfunction isString(value) {\n  return typeof value === 'string';\n}\n\nfunction getLanguageDirection(_x2, _x3) {\n  return _getLanguageDirection.apply(this, arguments);\n}\n\nfunction _getLanguageDirection() {\n  _getLanguageDirection = _asyncToGenerator(function* (locale, warnings) {\n    const dir = yield getLanguageDirectionFromLocales(locale);\n\n    if (!dir) {\n      warnings.push(`Locale data for '${locale}' cannot be found. 'dir' attribute will not be set for this locale.`);\n    }\n\n    return dir;\n  });\n  return _getLanguageDirection.apply(this, arguments);\n}\n\nfunction getLanguageDirectionFromLocales(_x4) {\n  return _getLanguageDirectionFromLocales.apply(this, arguments);\n}\n\nfunction _getLanguageDirectionFromLocales() {\n  _getLanguageDirectionFromLocales = _asyncToGenerator(function* (locale) {\n    try {\n      const localeData = (yield (0, load_esm_1.loadEsmModule)(`@angular/common/locales/${locale}`)).default;\n      const dir = localeData[localeData.length - 2];\n      return isString(dir) ? dir : undefined;\n    } catch {\n      // In some cases certain locales might map to files which are named only with language id.\n      // Example: `en-US` -> `en`.\n      const [languageId] = locale.split('-', 1);\n\n      if (languageId !== locale) {\n        return getLanguageDirectionFromLocales(languageId);\n      }\n    }\n\n    return undefined;\n  });\n  return _getLanguageDirectionFromLocales.apply(this, arguments);\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","augmentIndexHtml","crypto_1","require","load_esm_1","html_rewriting_stream_1","params","loadOutputFile","files","entrypoints","sri","deployUrl","lang","baseHref","html","warnings","errors","crossOrigin","stylesheets","Set","scripts","Map","entrypoint","isModule","extension","file","name","has","set","add","scriptTags","src","attrs","push","content","generateSriAttributes","join","linkTags","dir","getLanguageDirection","undefined","rewriter","transformedContent","htmlRewritingStream","baseTagExists","includes","on","tag","tagName","isString","updateAttribute","emitStartTag","emitRaw","linkTag","scriptTag","emitEndTag","length","algo","hash","createHash","update","digest","index","findIndex","a","newValue","locale","getLanguageDirectionFromLocales","localeData","loadEsmModule","default","languageId","split"],"sources":["/Users/deliabarbuta/Documents/An4Sem1/PAW/Proiect/proiect-paw-tadam/Frontend_OceanCross/node_modules/@angular-devkit/build-angular/src/utils/index-file/augment-index-html.js"],"sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.augmentIndexHtml = void 0;\nconst crypto_1 = require(\"crypto\");\nconst load_esm_1 = require(\"../load-esm\");\nconst html_rewriting_stream_1 = require(\"./html-rewriting-stream\");\n/*\n * Helper function used by the IndexHtmlWebpackPlugin.\n * Can also be directly used by builder, e. g. in order to generate an index.html\n * after processing several configurations in order to build different sets of\n * bundles for differential serving.\n */\nasync function augmentIndexHtml(params) {\n    const { loadOutputFile, files, entrypoints, sri, deployUrl = '', lang, baseHref, html } = params;\n    const warnings = [];\n    const errors = [];\n    let { crossOrigin = 'none' } = params;\n    if (sri && crossOrigin === 'none') {\n        crossOrigin = 'anonymous';\n    }\n    const stylesheets = new Set();\n    const scripts = new Map();\n    // Sort files in the order we want to insert them by entrypoint\n    for (const [entrypoint, isModule] of entrypoints) {\n        for (const { extension, file, name } of files) {\n            if (name !== entrypoint || scripts.has(file) || stylesheets.has(file)) {\n                continue;\n            }\n            switch (extension) {\n                case '.js':\n                    // Also, non entrypoints need to be loaded as no module as they can contain problematic code.\n                    scripts.set(file, isModule);\n                    break;\n                case '.css':\n                    stylesheets.add(file);\n                    break;\n            }\n        }\n    }\n    let scriptTags = [];\n    for (const [src, isModule] of scripts) {\n        const attrs = [`src=\"${deployUrl}${src}\"`];\n        // This is also need for non entry-points as they may contain problematic code.\n        if (isModule) {\n            attrs.push('type=\"module\"');\n        }\n        else {\n            attrs.push('defer');\n        }\n        if (crossOrigin !== 'none') {\n            attrs.push(`crossorigin=\"${crossOrigin}\"`);\n        }\n        if (sri) {\n            const content = await loadOutputFile(src);\n            attrs.push(generateSriAttributes(content));\n        }\n        scriptTags.push(`<script ${attrs.join(' ')}></script>`);\n    }\n    let linkTags = [];\n    for (const src of stylesheets) {\n        const attrs = [`rel=\"stylesheet\"`, `href=\"${deployUrl}${src}\"`];\n        if (crossOrigin !== 'none') {\n            attrs.push(`crossorigin=\"${crossOrigin}\"`);\n        }\n        if (sri) {\n            const content = await loadOutputFile(src);\n            attrs.push(generateSriAttributes(content));\n        }\n        linkTags.push(`<link ${attrs.join(' ')}>`);\n    }\n    const dir = lang ? await getLanguageDirection(lang, warnings) : undefined;\n    const { rewriter, transformedContent } = await (0, html_rewriting_stream_1.htmlRewritingStream)(html);\n    const baseTagExists = html.includes('<base');\n    rewriter\n        .on('startTag', (tag) => {\n        switch (tag.tagName) {\n            case 'html':\n                // Adjust document locale if specified\n                if (isString(lang)) {\n                    updateAttribute(tag, 'lang', lang);\n                }\n                if (dir) {\n                    updateAttribute(tag, 'dir', dir);\n                }\n                break;\n            case 'head':\n                // Base href should be added before any link, meta tags\n                if (!baseTagExists && isString(baseHref)) {\n                    rewriter.emitStartTag(tag);\n                    rewriter.emitRaw(`<base href=\"${baseHref}\">`);\n                    return;\n                }\n                break;\n            case 'base':\n                // Adjust base href if specified\n                if (isString(baseHref)) {\n                    updateAttribute(tag, 'href', baseHref);\n                }\n                break;\n        }\n        rewriter.emitStartTag(tag);\n    })\n        .on('endTag', (tag) => {\n        switch (tag.tagName) {\n            case 'head':\n                for (const linkTag of linkTags) {\n                    rewriter.emitRaw(linkTag);\n                }\n                linkTags = [];\n                break;\n            case 'body':\n                // Add script tags\n                for (const scriptTag of scriptTags) {\n                    rewriter.emitRaw(scriptTag);\n                }\n                scriptTags = [];\n                break;\n        }\n        rewriter.emitEndTag(tag);\n    });\n    const content = await transformedContent;\n    return {\n        content: linkTags.length || scriptTags.length\n            ? // In case no body/head tags are not present (dotnet partial templates)\n                linkTags.join('') + scriptTags.join('') + content\n            : content,\n        warnings,\n        errors,\n    };\n}\nexports.augmentIndexHtml = augmentIndexHtml;\nfunction generateSriAttributes(content) {\n    const algo = 'sha384';\n    const hash = (0, crypto_1.createHash)(algo).update(content, 'utf8').digest('base64');\n    return `integrity=\"${algo}-${hash}\"`;\n}\nfunction updateAttribute(tag, name, value) {\n    const index = tag.attrs.findIndex((a) => a.name === name);\n    const newValue = { name, value };\n    if (index === -1) {\n        tag.attrs.push(newValue);\n    }\n    else {\n        tag.attrs[index] = newValue;\n    }\n}\nfunction isString(value) {\n    return typeof value === 'string';\n}\nasync function getLanguageDirection(locale, warnings) {\n    const dir = await getLanguageDirectionFromLocales(locale);\n    if (!dir) {\n        warnings.push(`Locale data for '${locale}' cannot be found. 'dir' attribute will not be set for this locale.`);\n    }\n    return dir;\n}\nasync function getLanguageDirectionFromLocales(locale) {\n    try {\n        const localeData = (await (0, load_esm_1.loadEsmModule)(`@angular/common/locales/${locale}`)).default;\n        const dir = localeData[localeData.length - 2];\n        return isString(dir) ? dir : undefined;\n    }\n    catch {\n        // In some cases certain locales might map to files which are named only with language id.\n        // Example: `en-US` -> `en`.\n        const [languageId] = locale.split('-', 1);\n        if (languageId !== locale) {\n            return getLanguageDirectionFromLocales(languageId);\n        }\n    }\n    return undefined;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}