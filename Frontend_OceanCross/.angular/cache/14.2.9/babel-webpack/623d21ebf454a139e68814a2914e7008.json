{"ast":null,"code":"import _asyncToGenerator from \"/Users/deliabarbuta/Documents/An4Sem1/PAW/Proiect/proiect-paw-tadam/Frontend_OceanCross/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport fs from 'node:fs';\nimport nodePath from 'node:path';\nimport merge2 from 'merge2';\nimport fastGlob from 'fast-glob';\nimport dirGlob from 'dir-glob';\nimport { GITIGNORE_FILES_PATTERN, isIgnoredByIgnoreFiles, isIgnoredByIgnoreFilesSync } from './ignore.js';\nimport { FilterStream, toPath, isNegativePattern } from './utilities.js';\n\nconst assertPatternsInput = patterns => {\n  if (patterns.some(pattern => typeof pattern !== 'string')) {\n    throw new TypeError('Patterns must be a string or an array of strings');\n  }\n};\n\nconst toPatternsArray = patterns => {\n  patterns = [...new Set([patterns].flat())];\n  assertPatternsInput(patterns);\n  return patterns;\n};\n\nconst checkCwdOption = options => {\n  if (!options.cwd) {\n    return;\n  }\n\n  let stat;\n\n  try {\n    stat = fs.statSync(options.cwd);\n  } catch {\n    return;\n  }\n\n  if (!stat.isDirectory()) {\n    throw new Error('The `cwd` option must be a path to a directory');\n  }\n};\n\nconst normalizeOptions = (options = {}) => {\n  options = {\n    ignore: [],\n    expandDirectories: true,\n    ...options,\n    cwd: toPath(options.cwd)\n  };\n  checkCwdOption(options);\n  return options;\n};\n\nconst normalizeArguments = fn => /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (patterns, options) {\n    return fn(toPatternsArray(patterns), normalizeOptions(options));\n  });\n\n  return function (_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nconst normalizeArgumentsSync = fn => (patterns, options) => fn(toPatternsArray(patterns), normalizeOptions(options));\n\nconst getIgnoreFilesPatterns = options => {\n  const {\n    ignoreFiles,\n    gitignore\n  } = options;\n  const patterns = ignoreFiles ? toPatternsArray(ignoreFiles) : [];\n\n  if (gitignore) {\n    patterns.push(GITIGNORE_FILES_PATTERN);\n  }\n\n  return patterns;\n};\n\nconst getFilter = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator(function* (options) {\n    const ignoreFilesPatterns = getIgnoreFilesPatterns(options);\n    return createFilterFunction(ignoreFilesPatterns.length > 0 && (yield isIgnoredByIgnoreFiles(ignoreFilesPatterns, {\n      cwd: options.cwd\n    })));\n  });\n\n  return function getFilter(_x3) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nconst getFilterSync = options => {\n  const ignoreFilesPatterns = getIgnoreFilesPatterns(options);\n  return createFilterFunction(ignoreFilesPatterns.length > 0 && isIgnoredByIgnoreFilesSync(ignoreFilesPatterns, {\n    cwd: options.cwd\n  }));\n};\n\nconst createFilterFunction = isIgnored => {\n  const seen = new Set();\n  return fastGlobResult => {\n    const path = fastGlobResult.path || fastGlobResult;\n    const pathKey = nodePath.normalize(path);\n    const seenOrIgnored = seen.has(pathKey) || isIgnored && isIgnored(path);\n    seen.add(pathKey);\n    return !seenOrIgnored;\n  };\n};\n\nconst unionFastGlobResults = (results, filter) => results.flat().filter(fastGlobResult => filter(fastGlobResult));\n\nconst unionFastGlobStreams = (streams, filter) => merge2(streams).pipe(new FilterStream(fastGlobResult => filter(fastGlobResult)));\n\nconst convertNegativePatterns = (patterns, options) => {\n  const tasks = [];\n\n  while (patterns.length > 0) {\n    const index = patterns.findIndex(pattern => isNegativePattern(pattern));\n\n    if (index === -1) {\n      tasks.push({\n        patterns,\n        options\n      });\n      break;\n    }\n\n    const ignorePattern = patterns[index].slice(1);\n\n    for (const task of tasks) {\n      task.options.ignore.push(ignorePattern);\n    }\n\n    if (index !== 0) {\n      tasks.push({\n        patterns: patterns.slice(0, index),\n        options: { ...options,\n          ignore: [...options.ignore, ignorePattern]\n        }\n      });\n    }\n\n    patterns = patterns.slice(index + 1);\n  }\n\n  return tasks;\n};\n\nconst getDirGlobOptions = (options, cwd) => ({ ...(cwd ? {\n    cwd\n  } : {}),\n  ...(Array.isArray(options) ? {\n    files: options\n  } : options)\n});\n\nconst generateTasks = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator(function* (patterns, options) {\n    const globTasks = convertNegativePatterns(patterns, options);\n    const {\n      cwd,\n      expandDirectories\n    } = options;\n\n    if (!expandDirectories) {\n      return globTasks;\n    }\n\n    const patternExpandOptions = getDirGlobOptions(expandDirectories, cwd);\n    const ignoreExpandOptions = cwd ? {\n      cwd\n    } : undefined;\n    return Promise.all(globTasks.map( /*#__PURE__*/function () {\n      var _ref4 = _asyncToGenerator(function* (task) {\n        let {\n          patterns,\n          options\n        } = task;\n        [patterns, options.ignore] = yield Promise.all([dirGlob(patterns, patternExpandOptions), dirGlob(options.ignore, ignoreExpandOptions)]);\n        return {\n          patterns,\n          options\n        };\n      });\n\n      return function (_x6) {\n        return _ref4.apply(this, arguments);\n      };\n    }()));\n  });\n\n  return function generateTasks(_x4, _x5) {\n    return _ref3.apply(this, arguments);\n  };\n}();\n\nconst generateTasksSync = (patterns, options) => {\n  const globTasks = convertNegativePatterns(patterns, options);\n  const {\n    cwd,\n    expandDirectories\n  } = options;\n\n  if (!expandDirectories) {\n    return globTasks;\n  }\n\n  const patternExpandOptions = getDirGlobOptions(expandDirectories, cwd);\n  const ignoreExpandOptions = cwd ? {\n    cwd\n  } : undefined;\n  return globTasks.map(task => {\n    let {\n      patterns,\n      options\n    } = task;\n    patterns = dirGlob.sync(patterns, patternExpandOptions);\n    options.ignore = dirGlob.sync(options.ignore, ignoreExpandOptions);\n    return {\n      patterns,\n      options\n    };\n  });\n};\n\nexport const globby = normalizeArguments( /*#__PURE__*/function () {\n  var _ref5 = _asyncToGenerator(function* (patterns, options) {\n    const [tasks, filter] = yield Promise.all([generateTasks(patterns, options), getFilter(options)]);\n    const results = yield Promise.all(tasks.map(task => fastGlob(task.patterns, task.options)));\n    return unionFastGlobResults(results, filter);\n  });\n\n  return function (_x7, _x8) {\n    return _ref5.apply(this, arguments);\n  };\n}());\nexport const globbySync = normalizeArgumentsSync((patterns, options) => {\n  const tasks = generateTasksSync(patterns, options);\n  const filter = getFilterSync(options);\n  const results = tasks.map(task => fastGlob.sync(task.patterns, task.options));\n  return unionFastGlobResults(results, filter);\n});\nexport const globbyStream = normalizeArgumentsSync((patterns, options) => {\n  const tasks = generateTasksSync(patterns, options);\n  const filter = getFilterSync(options);\n  const streams = tasks.map(task => fastGlob.stream(task.patterns, task.options));\n  return unionFastGlobStreams(streams, filter);\n});\nexport const isDynamicPattern = normalizeArgumentsSync((patterns, options) => patterns.some(pattern => fastGlob.isDynamicPattern(pattern, options)));\nexport const generateGlobTasks = normalizeArguments(generateTasks);\nexport const generateGlobTasksSync = normalizeArgumentsSync(generateTasksSync);\nexport { isGitIgnored, isGitIgnoredSync } from './ignore.js';","map":{"version":3,"names":["fs","nodePath","merge2","fastGlob","dirGlob","GITIGNORE_FILES_PATTERN","isIgnoredByIgnoreFiles","isIgnoredByIgnoreFilesSync","FilterStream","toPath","isNegativePattern","assertPatternsInput","patterns","some","pattern","TypeError","toPatternsArray","Set","flat","checkCwdOption","options","cwd","stat","statSync","isDirectory","Error","normalizeOptions","ignore","expandDirectories","normalizeArguments","fn","normalizeArgumentsSync","getIgnoreFilesPatterns","ignoreFiles","gitignore","push","getFilter","ignoreFilesPatterns","createFilterFunction","length","getFilterSync","isIgnored","seen","fastGlobResult","path","pathKey","normalize","seenOrIgnored","has","add","unionFastGlobResults","results","filter","unionFastGlobStreams","streams","pipe","convertNegativePatterns","tasks","index","findIndex","ignorePattern","slice","task","getDirGlobOptions","Array","isArray","files","generateTasks","globTasks","patternExpandOptions","ignoreExpandOptions","undefined","Promise","all","map","generateTasksSync","sync","globby","globbySync","globbyStream","stream","isDynamicPattern","generateGlobTasks","generateGlobTasksSync","isGitIgnored","isGitIgnoredSync"],"sources":["/Users/deliabarbuta/Documents/An4Sem1/PAW/Proiect/proiect-paw-tadam/Frontend_OceanCross/node_modules/globby/index.js"],"sourcesContent":["import fs from 'node:fs';\nimport nodePath from 'node:path';\nimport merge2 from 'merge2';\nimport fastGlob from 'fast-glob';\nimport dirGlob from 'dir-glob';\nimport {\n\tGITIGNORE_FILES_PATTERN,\n\tisIgnoredByIgnoreFiles,\n\tisIgnoredByIgnoreFilesSync,\n} from './ignore.js';\nimport {FilterStream, toPath, isNegativePattern} from './utilities.js';\n\nconst assertPatternsInput = patterns => {\n\tif (patterns.some(pattern => typeof pattern !== 'string')) {\n\t\tthrow new TypeError('Patterns must be a string or an array of strings');\n\t}\n};\n\nconst toPatternsArray = patterns => {\n\tpatterns = [...new Set([patterns].flat())];\n\tassertPatternsInput(patterns);\n\treturn patterns;\n};\n\nconst checkCwdOption = options => {\n\tif (!options.cwd) {\n\t\treturn;\n\t}\n\n\tlet stat;\n\ttry {\n\t\tstat = fs.statSync(options.cwd);\n\t} catch {\n\t\treturn;\n\t}\n\n\tif (!stat.isDirectory()) {\n\t\tthrow new Error('The `cwd` option must be a path to a directory');\n\t}\n};\n\nconst normalizeOptions = (options = {}) => {\n\toptions = {\n\t\tignore: [],\n\t\texpandDirectories: true,\n\t\t...options,\n\t\tcwd: toPath(options.cwd),\n\t};\n\n\tcheckCwdOption(options);\n\n\treturn options;\n};\n\nconst normalizeArguments = fn => async (patterns, options) => fn(toPatternsArray(patterns), normalizeOptions(options));\nconst normalizeArgumentsSync = fn => (patterns, options) => fn(toPatternsArray(patterns), normalizeOptions(options));\n\nconst getIgnoreFilesPatterns = options => {\n\tconst {ignoreFiles, gitignore} = options;\n\n\tconst patterns = ignoreFiles ? toPatternsArray(ignoreFiles) : [];\n\tif (gitignore) {\n\t\tpatterns.push(GITIGNORE_FILES_PATTERN);\n\t}\n\n\treturn patterns;\n};\n\nconst getFilter = async options => {\n\tconst ignoreFilesPatterns = getIgnoreFilesPatterns(options);\n\treturn createFilterFunction(\n\t\tignoreFilesPatterns.length > 0 && await isIgnoredByIgnoreFiles(ignoreFilesPatterns, {cwd: options.cwd}),\n\t);\n};\n\nconst getFilterSync = options => {\n\tconst ignoreFilesPatterns = getIgnoreFilesPatterns(options);\n\treturn createFilterFunction(\n\t\tignoreFilesPatterns.length > 0 && isIgnoredByIgnoreFilesSync(ignoreFilesPatterns, {cwd: options.cwd}),\n\t);\n};\n\nconst createFilterFunction = isIgnored => {\n\tconst seen = new Set();\n\n\treturn fastGlobResult => {\n\t\tconst path = fastGlobResult.path || fastGlobResult;\n\t\tconst pathKey = nodePath.normalize(path);\n\t\tconst seenOrIgnored = seen.has(pathKey) || (isIgnored && isIgnored(path));\n\t\tseen.add(pathKey);\n\t\treturn !seenOrIgnored;\n\t};\n};\n\nconst unionFastGlobResults = (results, filter) => results.flat().filter(fastGlobResult => filter(fastGlobResult));\nconst unionFastGlobStreams = (streams, filter) => merge2(streams).pipe(new FilterStream(fastGlobResult => filter(fastGlobResult)));\n\nconst convertNegativePatterns = (patterns, options) => {\n\tconst tasks = [];\n\n\twhile (patterns.length > 0) {\n\t\tconst index = patterns.findIndex(pattern => isNegativePattern(pattern));\n\n\t\tif (index === -1) {\n\t\t\ttasks.push({patterns, options});\n\t\t\tbreak;\n\t\t}\n\n\t\tconst ignorePattern = patterns[index].slice(1);\n\n\t\tfor (const task of tasks) {\n\t\t\ttask.options.ignore.push(ignorePattern);\n\t\t}\n\n\t\tif (index !== 0) {\n\t\t\ttasks.push({\n\t\t\t\tpatterns: patterns.slice(0, index),\n\t\t\t\toptions: {\n\t\t\t\t\t...options,\n\t\t\t\t\tignore: [\n\t\t\t\t\t\t...options.ignore,\n\t\t\t\t\t\tignorePattern,\n\t\t\t\t\t],\n\t\t\t\t},\n\t\t\t});\n\t\t}\n\n\t\tpatterns = patterns.slice(index + 1);\n\t}\n\n\treturn tasks;\n};\n\nconst getDirGlobOptions = (options, cwd) => ({\n\t...(cwd ? {cwd} : {}),\n\t...(Array.isArray(options) ? {files: options} : options),\n});\n\nconst generateTasks = async (patterns, options) => {\n\tconst globTasks = convertNegativePatterns(patterns, options);\n\n\tconst {cwd, expandDirectories} = options;\n\n\tif (!expandDirectories) {\n\t\treturn globTasks;\n\t}\n\n\tconst patternExpandOptions = getDirGlobOptions(expandDirectories, cwd);\n\tconst ignoreExpandOptions = cwd ? {cwd} : undefined;\n\n\treturn Promise.all(\n\t\tglobTasks.map(async task => {\n\t\t\tlet {patterns, options} = task;\n\n\t\t\t[\n\t\t\t\tpatterns,\n\t\t\t\toptions.ignore,\n\t\t\t] = await Promise.all([\n\t\t\t\tdirGlob(patterns, patternExpandOptions),\n\t\t\t\tdirGlob(options.ignore, ignoreExpandOptions),\n\t\t\t]);\n\n\t\t\treturn {patterns, options};\n\t\t}),\n\t);\n};\n\nconst generateTasksSync = (patterns, options) => {\n\tconst globTasks = convertNegativePatterns(patterns, options);\n\n\tconst {cwd, expandDirectories} = options;\n\n\tif (!expandDirectories) {\n\t\treturn globTasks;\n\t}\n\n\tconst patternExpandOptions = getDirGlobOptions(expandDirectories, cwd);\n\tconst ignoreExpandOptions = cwd ? {cwd} : undefined;\n\n\treturn globTasks.map(task => {\n\t\tlet {patterns, options} = task;\n\t\tpatterns = dirGlob.sync(patterns, patternExpandOptions);\n\t\toptions.ignore = dirGlob.sync(options.ignore, ignoreExpandOptions);\n\t\treturn {patterns, options};\n\t});\n};\n\nexport const globby = normalizeArguments(async (patterns, options) => {\n\tconst [\n\t\ttasks,\n\t\tfilter,\n\t] = await Promise.all([\n\t\tgenerateTasks(patterns, options),\n\t\tgetFilter(options),\n\t]);\n\tconst results = await Promise.all(tasks.map(task => fastGlob(task.patterns, task.options)));\n\n\treturn unionFastGlobResults(results, filter);\n});\n\nexport const globbySync = normalizeArgumentsSync((patterns, options) => {\n\tconst tasks = generateTasksSync(patterns, options);\n\tconst filter = getFilterSync(options);\n\tconst results = tasks.map(task => fastGlob.sync(task.patterns, task.options));\n\n\treturn unionFastGlobResults(results, filter);\n});\n\nexport const globbyStream = normalizeArgumentsSync((patterns, options) => {\n\tconst tasks = generateTasksSync(patterns, options);\n\tconst filter = getFilterSync(options);\n\tconst streams = tasks.map(task => fastGlob.stream(task.patterns, task.options));\n\n\treturn unionFastGlobStreams(streams, filter);\n});\n\nexport const isDynamicPattern = normalizeArgumentsSync(\n\t(patterns, options) => patterns.some(pattern => fastGlob.isDynamicPattern(pattern, options)),\n);\n\nexport const generateGlobTasks = normalizeArguments(generateTasks);\nexport const generateGlobTasksSync = normalizeArgumentsSync(generateTasksSync);\n\nexport {\n\tisGitIgnored,\n\tisGitIgnoredSync,\n} from './ignore.js';\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}