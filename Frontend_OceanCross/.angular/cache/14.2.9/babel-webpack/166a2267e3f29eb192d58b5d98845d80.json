{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"/Users/deliabarbuta/Documents/An4Sem1/PAW/Proiect/proiect-paw-tadam/Frontend_OceanCross/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\n\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nvar _DirectlyTransferable_value, _ArrayBufferViewTransferable_view, _Piscina_pool;\n\nconst worker_threads_1 = require(\"worker_threads\");\n\nconst events_1 = require(\"events\");\n\nconst eventemitter_asyncresource_1 = __importDefault(require(\"eventemitter-asyncresource\"));\n\nconst async_hooks_1 = require(\"async_hooks\");\n\nconst os_1 = require(\"os\");\n\nconst url_1 = require(\"url\");\n\nconst path_1 = require(\"path\");\n\nconst util_1 = require(\"util\");\n\nconst assert_1 = __importDefault(require(\"assert\"));\n\nconst hdr_histogram_js_1 = require(\"hdr-histogram-js\");\n\nconst perf_hooks_1 = require(\"perf_hooks\");\n\nconst hdr_histogram_percentiles_obj_1 = __importDefault(require(\"hdr-histogram-percentiles-obj\"));\n\nconst common_1 = require(\"./common\");\n\nconst package_json_1 = require(\"../package.json\");\n\nconst cpuCount = (() => {\n  try {\n    return os_1.cpus().length;\n  } catch {\n    /* istanbul ignore next */\n    return 1;\n  }\n})();\n\n;\n\nfunction onabort(abortSignal, listener) {\n  if ('addEventListener' in abortSignal) {\n    abortSignal.addEventListener('abort', listener, {\n      once: true\n    });\n  } else {\n    abortSignal.once('abort', listener);\n  }\n}\n\nclass AbortError extends Error {\n  constructor() {\n    super('The task has been aborted');\n  }\n\n  get name() {\n    return 'AbortError';\n  }\n\n}\n\nclass ArrayTaskQueue {\n  constructor() {\n    this.tasks = [];\n  }\n\n  get size() {\n    return this.tasks.length;\n  }\n\n  shift() {\n    return this.tasks.shift();\n  }\n\n  push(task) {\n    this.tasks.push(task);\n  }\n\n  remove(task) {\n    const index = this.tasks.indexOf(task);\n    assert_1.default.notStrictEqual(index, -1);\n    this.tasks.splice(index, 1);\n  }\n\n}\n\nconst kDefaultOptions = {\n  filename: null,\n  name: 'default',\n  minThreads: Math.max(cpuCount / 2, 1),\n  maxThreads: cpuCount * 1.5,\n  idleTimeout: 0,\n  maxQueue: Infinity,\n  concurrentTasksPerWorker: 1,\n  useAtomics: true,\n  taskQueue: new ArrayTaskQueue(),\n  niceIncrement: 0,\n  trackUnmanagedFds: true\n};\nconst kDefaultRunOptions = {\n  transferList: undefined,\n  filename: null,\n  signal: null,\n  name: null\n};\n\nclass DirectlyTransferable {\n  constructor(value) {\n    _DirectlyTransferable_value.set(this, void 0);\n\n    __classPrivateFieldSet(this, _DirectlyTransferable_value, value, \"f\");\n  }\n\n  get [(_DirectlyTransferable_value = new WeakMap(), common_1.kTransferable)]() {\n    return __classPrivateFieldGet(this, _DirectlyTransferable_value, \"f\");\n  }\n\n  get [common_1.kValue]() {\n    return __classPrivateFieldGet(this, _DirectlyTransferable_value, \"f\");\n  }\n\n}\n\nclass ArrayBufferViewTransferable {\n  constructor(view) {\n    _ArrayBufferViewTransferable_view.set(this, void 0);\n\n    __classPrivateFieldSet(this, _ArrayBufferViewTransferable_view, view, \"f\");\n  }\n\n  get [(_ArrayBufferViewTransferable_view = new WeakMap(), common_1.kTransferable)]() {\n    return __classPrivateFieldGet(this, _ArrayBufferViewTransferable_view, \"f\").buffer;\n  }\n\n  get [common_1.kValue]() {\n    return __classPrivateFieldGet(this, _ArrayBufferViewTransferable_view, \"f\");\n  }\n\n}\n\nlet taskIdCounter = 0;\n\nfunction maybeFileURLToPath(filename) {\n  return filename.startsWith('file:') ? url_1.fileURLToPath(new url_1.URL(filename)) : filename;\n} // Extend AsyncResource so that async relations between posting a task and\n// receiving its result are visible to diagnostic tools.\n\n\nclass TaskInfo extends async_hooks_1.AsyncResource {\n  constructor(task, transferList, filename, name, callback, abortSignal, triggerAsyncId) {\n    super('Piscina.Task', {\n      requireManualDestroy: true,\n      triggerAsyncId\n    });\n    this.abortListener = null;\n    this.workerInfo = null;\n    this.callback = callback;\n    this.task = task;\n    this.transferList = transferList; // If the task is a Transferable returned by\n    // Piscina.move(), then add it to the transferList\n    // automatically\n\n    if (common_1.isMovable(task)) {\n      // This condition should never be hit but typescript\n      // complains if we dont do the check.\n\n      /* istanbul ignore if */\n      if (this.transferList == null) {\n        this.transferList = [];\n      }\n\n      this.transferList = this.transferList.concat(task[common_1.kTransferable]);\n      this.task = task[common_1.kValue];\n    }\n\n    this.filename = filename;\n    this.name = name;\n    this.taskId = taskIdCounter++;\n    this.abortSignal = abortSignal;\n    this.created = perf_hooks_1.performance.now();\n    this.started = 0;\n  }\n\n  releaseTask() {\n    const ret = this.task;\n    this.task = null;\n    return ret;\n  }\n\n  done(err, result) {\n    this.runInAsyncScope(this.callback, null, err, result);\n    this.emitDestroy(); // `TaskInfo`s are used only once.\n    // If an abort signal was used, remove the listener from it when\n    // done to make sure we do not accidentally leak.\n\n    if (this.abortSignal && this.abortListener) {\n      if ('removeEventListener' in this.abortSignal && this.abortListener) {\n        this.abortSignal.removeEventListener('abort', this.abortListener);\n      } else {\n        this.abortSignal.off('abort', this.abortListener);\n      }\n    }\n  }\n\n  get [common_1.kQueueOptions]() {\n    return common_1.kQueueOptions in this.task ? this.task[common_1.kQueueOptions] : null;\n  }\n\n}\n\nclass AsynchronouslyCreatedResource {\n  constructor() {\n    this.onreadyListeners = [];\n  }\n\n  markAsReady() {\n    const listeners = this.onreadyListeners;\n    assert_1.default(listeners !== null);\n    this.onreadyListeners = null;\n\n    for (const listener of listeners) {\n      listener();\n    }\n  }\n\n  isReady() {\n    return this.onreadyListeners === null;\n  }\n\n  onReady(fn) {\n    if (this.onreadyListeners === null) {\n      fn(); // Zalgo is okay here.\n\n      return;\n    }\n\n    this.onreadyListeners.push(fn);\n  }\n\n}\n\nclass AsynchronouslyCreatedResourcePool {\n  constructor(maximumUsage) {\n    this.pendingItems = new Set();\n    this.readyItems = new Set();\n    this.maximumUsage = maximumUsage;\n    this.onAvailableListeners = [];\n  }\n\n  add(item) {\n    this.pendingItems.add(item);\n    item.onReady(() => {\n      /* istanbul ignore else */\n      if (this.pendingItems.has(item)) {\n        this.pendingItems.delete(item);\n        this.readyItems.add(item);\n        this.maybeAvailable(item);\n      }\n    });\n  }\n\n  delete(item) {\n    this.pendingItems.delete(item);\n    this.readyItems.delete(item);\n  }\n\n  findAvailable() {\n    let minUsage = this.maximumUsage;\n    let candidate = null;\n\n    for (const item of this.readyItems) {\n      const usage = item.currentUsage();\n      if (usage === 0) return item;\n\n      if (usage < minUsage) {\n        candidate = item;\n        minUsage = usage;\n      }\n    }\n\n    return candidate;\n  }\n\n  *[Symbol.iterator]() {\n    yield* this.pendingItems;\n    yield* this.readyItems;\n  }\n\n  get size() {\n    return this.pendingItems.size + this.readyItems.size;\n  }\n\n  maybeAvailable(item) {\n    /* istanbul ignore else */\n    if (item.currentUsage() < this.maximumUsage) {\n      for (const listener of this.onAvailableListeners) {\n        listener(item);\n      }\n    }\n  }\n\n  onAvailable(fn) {\n    this.onAvailableListeners.push(fn);\n  }\n\n}\n\nconst Errors = {\n  ThreadTermination: () => new Error('Terminating worker thread'),\n  FilenameNotProvided: () => new Error('filename must be provided to run() or in options object'),\n  TaskQueueAtLimit: () => new Error('Task queue is at limit'),\n  NoTaskQueueAvailable: () => new Error('No task queue available and all Workers are busy')\n};\n\nclass WorkerInfo extends AsynchronouslyCreatedResource {\n  constructor(worker, port, onMessage) {\n    super();\n    this.idleTimeout = null; // eslint-disable-line no-undef\n\n    this.lastSeenResponseCount = 0;\n    this.worker = worker;\n    this.port = port;\n    this.port.on('message', message => this._handleResponse(message));\n    this.onMessage = onMessage;\n    this.taskInfos = new Map();\n    this.sharedBuffer = new Int32Array(new SharedArrayBuffer(common_1.kFieldCount * Int32Array.BYTES_PER_ELEMENT));\n  }\n\n  destroy() {\n    this.worker.terminate();\n    this.port.close();\n    this.clearIdleTimeout();\n\n    for (const taskInfo of this.taskInfos.values()) {\n      taskInfo.done(Errors.ThreadTermination());\n    }\n\n    this.taskInfos.clear();\n  }\n\n  clearIdleTimeout() {\n    if (this.idleTimeout !== null) {\n      clearTimeout(this.idleTimeout);\n      this.idleTimeout = null;\n    }\n  }\n\n  ref() {\n    this.port.ref();\n    return this;\n  }\n\n  unref() {\n    // Note: Do not call ref()/unref() on the Worker itself since that may cause\n    // a hard crash, see https://github.com/nodejs/node/pull/33394.\n    this.port.unref();\n    return this;\n  }\n\n  _handleResponse(message) {\n    this.onMessage(message);\n\n    if (this.taskInfos.size === 0) {\n      // No more tasks running on this Worker means it should not keep the\n      // process running.\n      this.unref();\n    }\n  }\n\n  postTask(taskInfo) {\n    assert_1.default(!this.taskInfos.has(taskInfo.taskId));\n    const message = {\n      task: taskInfo.releaseTask(),\n      taskId: taskInfo.taskId,\n      filename: taskInfo.filename,\n      name: taskInfo.name\n    };\n\n    try {\n      this.port.postMessage(message, taskInfo.transferList);\n    } catch (err) {\n      // This would mostly happen if e.g. message contains unserializable data\n      // or transferList is invalid.\n      taskInfo.done(err);\n      return;\n    }\n\n    taskInfo.workerInfo = this;\n    this.taskInfos.set(taskInfo.taskId, taskInfo);\n    this.ref();\n    this.clearIdleTimeout(); // Inform the worker that there are new messages posted, and wake it up\n    // if it is waiting for one.\n\n    Atomics.add(this.sharedBuffer, common_1.kRequestCountField, 1);\n    Atomics.notify(this.sharedBuffer, common_1.kRequestCountField, 1);\n  }\n\n  processPendingMessages() {\n    // If we *know* that there are more messages than we have received using\n    // 'message' events yet, then try to load and handle them synchronously,\n    // without the need to wait for more expensive events on the event loop.\n    // This would usually break async tracking, but in our case, we already have\n    // the extra TaskInfo/AsyncResource layer that rectifies that situation.\n    const actualResponseCount = Atomics.load(this.sharedBuffer, common_1.kResponseCountField);\n\n    if (actualResponseCount !== this.lastSeenResponseCount) {\n      this.lastSeenResponseCount = actualResponseCount;\n      let entry;\n\n      while ((entry = worker_threads_1.receiveMessageOnPort(this.port)) !== undefined) {\n        this._handleResponse(entry.message);\n      }\n    }\n  }\n\n  isRunningAbortableTask() {\n    // If there are abortable tasks, we are running one at most per Worker.\n    if (this.taskInfos.size !== 1) return false;\n    const [[, task]] = this.taskInfos;\n    return task.abortSignal !== null;\n  }\n\n  currentUsage() {\n    if (this.isRunningAbortableTask()) return Infinity;\n    return this.taskInfos.size;\n  }\n\n}\n\nclass ThreadPool {\n  constructor(publicInterface, options) {\n    var _a;\n\n    this.skipQueue = [];\n    this.completed = 0;\n    this.start = perf_hooks_1.performance.now();\n    this.inProcessPendingMessages = false;\n    this.startingUp = false;\n    this.workerFailsDuringBootstrap = false;\n    this.publicInterface = publicInterface;\n    this.taskQueue = options.taskQueue || new ArrayTaskQueue();\n    this.runTime = hdr_histogram_js_1.build({\n      lowestDiscernibleValue: 1\n    });\n    this.waitTime = hdr_histogram_js_1.build({\n      lowestDiscernibleValue: 1\n    });\n    const filename = options.filename ? maybeFileURLToPath(options.filename) : null;\n    this.options = { ...kDefaultOptions,\n      ...options,\n      filename,\n      maxQueue: 0\n    }; // The >= and <= could be > and < but this way we get 100 % coverage 🙃\n\n    if (options.maxThreads !== undefined && this.options.minThreads >= options.maxThreads) {\n      this.options.minThreads = options.maxThreads;\n    }\n\n    if (options.minThreads !== undefined && this.options.maxThreads <= options.minThreads) {\n      this.options.maxThreads = options.minThreads;\n    }\n\n    if (options.maxQueue === 'auto') {\n      this.options.maxQueue = this.options.maxThreads ** 2;\n    } else {\n      this.options.maxQueue = (_a = options.maxQueue) !== null && _a !== void 0 ? _a : kDefaultOptions.maxQueue;\n    }\n\n    this.workers = new AsynchronouslyCreatedResourcePool(this.options.concurrentTasksPerWorker);\n    this.workers.onAvailable(w => this._onWorkerAvailable(w));\n    this.startingUp = true;\n\n    this._ensureMinimumWorkers();\n\n    this.startingUp = false;\n  }\n\n  _ensureMinimumWorkers() {\n    while (this.workers.size < this.options.minThreads) {\n      this._addNewWorker();\n    }\n  }\n\n  _addNewWorker() {\n    const pool = this;\n    const worker = new worker_threads_1.Worker(path_1.resolve(__dirname, 'worker.js'), {\n      env: this.options.env,\n      argv: this.options.argv,\n      execArgv: this.options.execArgv,\n      resourceLimits: this.options.resourceLimits,\n      workerData: this.options.workerData,\n      trackUnmanagedFds: this.options.trackUnmanagedFds\n    });\n    const {\n      port1,\n      port2\n    } = new worker_threads_1.MessageChannel();\n    const workerInfo = new WorkerInfo(worker, port1, onMessage);\n\n    if (this.startingUp) {\n      // There is no point in waiting for the initial set of Workers to indicate\n      // that they are ready, we just mark them as such from the start.\n      workerInfo.markAsReady();\n    }\n\n    const message = {\n      filename: this.options.filename,\n      name: this.options.name,\n      port: port2,\n      sharedBuffer: workerInfo.sharedBuffer,\n      useAtomics: this.options.useAtomics,\n      niceIncrement: this.options.niceIncrement\n    };\n    worker.postMessage(message, [port2]);\n\n    function onMessage(message) {\n      const {\n        taskId,\n        result\n      } = message; // In case of success: Call the callback that was passed to `runTask`,\n      // remove the `TaskInfo` associated with the Worker, which marks it as\n      // free again.\n\n      const taskInfo = workerInfo.taskInfos.get(taskId);\n      workerInfo.taskInfos.delete(taskId);\n      pool.workers.maybeAvailable(workerInfo);\n      /* istanbul ignore if */\n\n      if (taskInfo === undefined) {\n        const err = new Error(`Unexpected message from Worker: ${util_1.inspect(message)}`);\n        pool.publicInterface.emit('error', err);\n      } else {\n        taskInfo.done(message.error, result);\n      }\n\n      pool._processPendingMessages();\n    }\n\n    worker.on('message', message => {\n      if (message.ready === true) {\n        if (workerInfo.currentUsage() === 0) {\n          workerInfo.unref();\n        }\n\n        if (!workerInfo.isReady()) {\n          workerInfo.markAsReady();\n        }\n\n        return;\n      }\n\n      worker.emit('error', new Error(`Unexpected message on Worker: ${util_1.inspect(message)}`));\n    });\n    worker.on('error', err => {\n      // Work around the bug in https://github.com/nodejs/node/pull/33394\n      worker.ref = () => {}; // In case of an uncaught exception: Call the callback that was passed to\n      // `postTask` with the error, or emit an 'error' event if there is none.\n\n\n      const taskInfos = [...workerInfo.taskInfos.values()];\n      workerInfo.taskInfos.clear(); // Remove the worker from the list and potentially start a new Worker to\n      // replace the current one.\n\n      this._removeWorker(workerInfo);\n\n      if (workerInfo.isReady() && !this.workerFailsDuringBootstrap) {\n        this._ensureMinimumWorkers();\n      } else {\n        // Do not start new workers over and over if they already fail during\n        // bootstrap, there's no point.\n        this.workerFailsDuringBootstrap = true;\n      }\n\n      if (taskInfos.length > 0) {\n        for (const taskInfo of taskInfos) {\n          taskInfo.done(err, null);\n        }\n      } else {\n        this.publicInterface.emit('error', err);\n      }\n    });\n    worker.unref();\n    port1.on('close', () => {\n      // The port is only closed if the Worker stops for some reason, but we\n      // always .unref() the Worker itself. We want to receive e.g. 'error'\n      // events on it, so we ref it once we know it's going to exit anyway.\n      worker.ref();\n    });\n    this.workers.add(workerInfo);\n  }\n\n  _processPendingMessages() {\n    if (this.inProcessPendingMessages || !this.options.useAtomics) {\n      return;\n    }\n\n    this.inProcessPendingMessages = true;\n\n    try {\n      for (const workerInfo of this.workers) {\n        workerInfo.processPendingMessages();\n      }\n    } finally {\n      this.inProcessPendingMessages = false;\n    }\n  }\n\n  _removeWorker(workerInfo) {\n    workerInfo.destroy();\n    this.workers.delete(workerInfo);\n  }\n\n  _onWorkerAvailable(workerInfo) {\n    while ((this.taskQueue.size > 0 || this.skipQueue.length > 0) && workerInfo.currentUsage() < this.options.concurrentTasksPerWorker) {\n      // The skipQueue will have tasks that we previously shifted off\n      // the task queue but had to skip over... we have to make sure\n      // we drain that before we drain the taskQueue.\n      const taskInfo = this.skipQueue.shift() || this.taskQueue.shift(); // If the task has an abortSignal and the worker has any other\n      // tasks, we cannot distribute the task to it. Skip for now.\n\n      if (taskInfo.abortSignal && workerInfo.taskInfos.size > 0) {\n        this.skipQueue.push(taskInfo);\n        break;\n      }\n\n      const now = perf_hooks_1.performance.now();\n      this.waitTime.recordValue(now - taskInfo.created);\n      taskInfo.started = now;\n      workerInfo.postTask(taskInfo);\n\n      this._maybeDrain();\n\n      return;\n    }\n\n    if (workerInfo.taskInfos.size === 0 && this.workers.size > this.options.minThreads) {\n      workerInfo.idleTimeout = setTimeout(() => {\n        assert_1.default.strictEqual(workerInfo.taskInfos.size, 0);\n\n        if (this.workers.size > this.options.minThreads) {\n          this._removeWorker(workerInfo);\n        }\n      }, this.options.idleTimeout).unref();\n    }\n  }\n\n  runTask(task, options) {\n    let {\n      filename,\n      name\n    } = options;\n    const {\n      transferList = [],\n      signal = null\n    } = options;\n\n    if (filename == null) {\n      filename = this.options.filename;\n    }\n\n    if (name == null) {\n      name = this.options.name;\n    }\n\n    if (typeof filename !== 'string') {\n      return Promise.reject(Errors.FilenameNotProvided());\n    }\n\n    filename = maybeFileURLToPath(filename);\n    let resolve;\n    let reject; // eslint-disable-next-line\n\n    const ret = new Promise((res, rej) => {\n      resolve = res;\n      reject = rej;\n    });\n    const taskInfo = new TaskInfo(task, transferList, filename, name, (err, result) => {\n      this.completed++;\n\n      if (taskInfo.started) {\n        this.runTime.recordValue(perf_hooks_1.performance.now() - taskInfo.started);\n      }\n\n      if (err !== null) {\n        reject(err);\n      } else {\n        resolve(result);\n      }\n    }, signal, this.publicInterface.asyncResource.asyncId());\n\n    if (signal !== null) {\n      // If the AbortSignal has an aborted property and it's truthy,\n      // reject immediately.\n      if (signal.aborted) {\n        return Promise.reject(new AbortError());\n      }\n\n      taskInfo.abortListener = () => {\n        // Call reject() first to make sure we always reject with the AbortError\n        // if the task is aborted, not with an Error from the possible\n        // thread termination below.\n        reject(new AbortError());\n\n        if (taskInfo.workerInfo !== null) {\n          // Already running: We cancel the Worker this is running on.\n          this._removeWorker(taskInfo.workerInfo);\n\n          this._ensureMinimumWorkers();\n        } else {\n          // Not yet running: Remove it from the queue.\n          this.taskQueue.remove(taskInfo);\n        }\n      };\n\n      onabort(signal, taskInfo.abortListener);\n    } // If there is a task queue, there's no point in looking for an available\n    // Worker thread. Add this task to the queue, if possible.\n\n\n    if (this.taskQueue.size > 0) {\n      const totalCapacity = this.options.maxQueue + this.pendingCapacity();\n\n      if (this.taskQueue.size >= totalCapacity) {\n        if (this.options.maxQueue === 0) {\n          return Promise.reject(Errors.NoTaskQueueAvailable());\n        } else {\n          return Promise.reject(Errors.TaskQueueAtLimit());\n        }\n      } else {\n        if (this.workers.size < this.options.maxThreads) {\n          this._addNewWorker();\n        }\n\n        this.taskQueue.push(taskInfo);\n      }\n\n      return ret;\n    } // Look for a Worker with a minimum number of tasks it is currently running.\n\n\n    let workerInfo = this.workers.findAvailable(); // If we want the ability to abort this task, use only workers that have\n    // no running tasks.\n\n    if (workerInfo !== null && workerInfo.currentUsage() > 0 && signal) {\n      workerInfo = null;\n    } // If no Worker was found, or that Worker was handling another task in some\n    // way, and we still have the ability to spawn new threads, do so.\n\n\n    let waitingForNewWorker = false;\n\n    if ((workerInfo === null || workerInfo.currentUsage() > 0) && this.workers.size < this.options.maxThreads) {\n      this._addNewWorker();\n\n      waitingForNewWorker = true;\n    } // If no Worker is found, try to put the task into the queue.\n\n\n    if (workerInfo === null) {\n      if (this.options.maxQueue <= 0 && !waitingForNewWorker) {\n        return Promise.reject(Errors.NoTaskQueueAvailable());\n      } else {\n        this.taskQueue.push(taskInfo);\n      }\n\n      return ret;\n    } // TODO(addaleax): Clean up the waitTime/runTime recording.\n\n\n    const now = perf_hooks_1.performance.now();\n    this.waitTime.recordValue(now - taskInfo.created);\n    taskInfo.started = now;\n    workerInfo.postTask(taskInfo);\n\n    this._maybeDrain();\n\n    return ret;\n  }\n\n  pendingCapacity() {\n    return this.workers.pendingItems.size * this.options.concurrentTasksPerWorker;\n  }\n\n  _maybeDrain() {\n    if (this.taskQueue.size === 0 && this.skipQueue.length === 0) {\n      this.publicInterface.emit('drain');\n    }\n  }\n\n  destroy() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      while (_this.skipQueue.length > 0) {\n        const taskInfo = _this.skipQueue.shift();\n\n        taskInfo.done(new Error('Terminating worker thread'));\n      }\n\n      while (_this.taskQueue.size > 0) {\n        const taskInfo = _this.taskQueue.shift();\n\n        taskInfo.done(new Error('Terminating worker thread'));\n      }\n\n      const exitEvents = [];\n\n      while (_this.workers.size > 0) {\n        const [workerInfo] = _this.workers;\n        exitEvents.push(events_1.once(workerInfo.worker, 'exit'));\n\n        _this._removeWorker(workerInfo);\n      }\n\n      yield Promise.all(exitEvents);\n    })();\n  }\n\n}\n\nclass Piscina extends eventemitter_asyncresource_1.default {\n  constructor(options = {}) {\n    super({ ...options,\n      name: 'Piscina'\n    });\n\n    _Piscina_pool.set(this, void 0);\n\n    if (typeof options.filename !== 'string' && options.filename != null) {\n      throw new TypeError('options.filename must be a string or null');\n    }\n\n    if (typeof options.name !== 'string' && options.name != null) {\n      throw new TypeError('options.name must be a string or null');\n    }\n\n    if (options.minThreads !== undefined && (typeof options.minThreads !== 'number' || options.minThreads < 0)) {\n      throw new TypeError('options.minThreads must be a non-negative integer');\n    }\n\n    if (options.maxThreads !== undefined && (typeof options.maxThreads !== 'number' || options.maxThreads < 1)) {\n      throw new TypeError('options.maxThreads must be a positive integer');\n    }\n\n    if (options.minThreads !== undefined && options.maxThreads !== undefined && options.minThreads > options.maxThreads) {\n      throw new RangeError('options.minThreads and options.maxThreads must not conflict');\n    }\n\n    if (options.idleTimeout !== undefined && (typeof options.idleTimeout !== 'number' || options.idleTimeout < 0)) {\n      throw new TypeError('options.idleTimeout must be a non-negative integer');\n    }\n\n    if (options.maxQueue !== undefined && options.maxQueue !== 'auto' && (typeof options.maxQueue !== 'number' || options.maxQueue < 0)) {\n      throw new TypeError('options.maxQueue must be a non-negative integer');\n    }\n\n    if (options.concurrentTasksPerWorker !== undefined && (typeof options.concurrentTasksPerWorker !== 'number' || options.concurrentTasksPerWorker < 1)) {\n      throw new TypeError('options.concurrentTasksPerWorker must be a positive integer');\n    }\n\n    if (options.useAtomics !== undefined && typeof options.useAtomics !== 'boolean') {\n      throw new TypeError('options.useAtomics must be a boolean value');\n    }\n\n    if (options.resourceLimits !== undefined && (typeof options.resourceLimits !== 'object' || options.resourceLimits === null)) {\n      throw new TypeError('options.resourceLimits must be an object');\n    }\n\n    if (options.taskQueue !== undefined && !common_1.isTaskQueue(options.taskQueue)) {\n      throw new TypeError('options.taskQueue must be a TaskQueue object');\n    }\n\n    if (options.niceIncrement !== undefined && (typeof options.niceIncrement !== 'number' || options.niceIncrement < 0)) {\n      throw new TypeError('options.niceIncrement must be a non-negative integer');\n    }\n\n    if (options.trackUnmanagedFds !== undefined && typeof options.trackUnmanagedFds !== 'boolean') {\n      throw new TypeError('options.trackUnmanagedFds must be a boolean value');\n    }\n\n    __classPrivateFieldSet(this, _Piscina_pool, new ThreadPool(this, options), \"f\");\n  }\n  /** @deprecated Use run(task, options) instead **/\n\n\n  runTask(task, transferList, filename, signal) {\n    // If transferList is a string or AbortSignal, shift it.\n    if (typeof transferList === 'object' && !Array.isArray(transferList) || typeof transferList === 'string') {\n      signal = filename;\n      filename = transferList;\n      transferList = undefined;\n    } // If filename is an AbortSignal, shift it.\n\n\n    if (typeof filename === 'object' && !Array.isArray(filename)) {\n      signal = filename;\n      filename = undefined;\n    }\n\n    if (transferList !== undefined && !Array.isArray(transferList)) {\n      return Promise.reject(new TypeError('transferList argument must be an Array'));\n    }\n\n    if (filename !== undefined && typeof filename !== 'string') {\n      return Promise.reject(new TypeError('filename argument must be a string'));\n    }\n\n    if (signal !== undefined && typeof signal !== 'object') {\n      return Promise.reject(new TypeError('signal argument must be an object'));\n    }\n\n    return __classPrivateFieldGet(this, _Piscina_pool, \"f\").runTask(task, {\n      transferList,\n      filename: filename || null,\n      name: 'default',\n      signal: signal || null\n    });\n  }\n\n  run(task, options = kDefaultRunOptions) {\n    if (options === null || typeof options !== 'object') {\n      return Promise.reject(new TypeError('options must be an object'));\n    }\n\n    const {\n      transferList,\n      filename,\n      name,\n      signal\n    } = options;\n\n    if (transferList !== undefined && !Array.isArray(transferList)) {\n      return Promise.reject(new TypeError('transferList argument must be an Array'));\n    }\n\n    if (filename != null && typeof filename !== 'string') {\n      return Promise.reject(new TypeError('filename argument must be a string'));\n    }\n\n    if (name != null && typeof name !== 'string') {\n      return Promise.reject(new TypeError('name argument must be a string'));\n    }\n\n    if (signal != null && typeof signal !== 'object') {\n      return Promise.reject(new TypeError('signal argument must be an object'));\n    }\n\n    return __classPrivateFieldGet(this, _Piscina_pool, \"f\").runTask(task, {\n      transferList,\n      filename,\n      name,\n      signal\n    });\n  }\n\n  destroy() {\n    return __classPrivateFieldGet(this, _Piscina_pool, \"f\").destroy();\n  }\n\n  get options() {\n    return __classPrivateFieldGet(this, _Piscina_pool, \"f\").options;\n  }\n\n  get threads() {\n    const ret = [];\n\n    for (const workerInfo of __classPrivateFieldGet(this, _Piscina_pool, \"f\").workers) {\n      ret.push(workerInfo.worker);\n    }\n\n    return ret;\n  }\n\n  get queueSize() {\n    const pool = __classPrivateFieldGet(this, _Piscina_pool, \"f\");\n\n    return Math.max(pool.taskQueue.size - pool.pendingCapacity(), 0);\n  }\n\n  get completed() {\n    return __classPrivateFieldGet(this, _Piscina_pool, \"f\").completed;\n  }\n\n  get waitTime() {\n    const result = hdr_histogram_percentiles_obj_1.default.histAsObj(__classPrivateFieldGet(this, _Piscina_pool, \"f\").waitTime);\n    return hdr_histogram_percentiles_obj_1.default.addPercentiles(__classPrivateFieldGet(this, _Piscina_pool, \"f\").waitTime, result);\n  }\n\n  get runTime() {\n    const result = hdr_histogram_percentiles_obj_1.default.histAsObj(__classPrivateFieldGet(this, _Piscina_pool, \"f\").runTime);\n    return hdr_histogram_percentiles_obj_1.default.addPercentiles(__classPrivateFieldGet(this, _Piscina_pool, \"f\").runTime, result);\n  }\n\n  get utilization() {\n    // The capacity is the max compute time capacity of the\n    // pool to this point in time as determined by the length\n    // of time the pool has been running multiplied by the\n    // maximum number of threads.\n    const capacity = this.duration * __classPrivateFieldGet(this, _Piscina_pool, \"f\").options.maxThreads;\n\n    const totalMeanRuntime = __classPrivateFieldGet(this, _Piscina_pool, \"f\").runTime.mean * __classPrivateFieldGet(this, _Piscina_pool, \"f\").runTime.totalCount; // We calculate the appoximate pool utilization by multiplying\n    // the mean run time of all tasks by the number of runtime\n    // samples taken and dividing that by the capacity. The\n    // theory here is that capacity represents the absolute upper\n    // limit of compute time this pool could ever attain (but\n    // never will for a variety of reasons. Multiplying the\n    // mean run time by the number of tasks sampled yields an\n    // approximation of the realized compute time. The utilization\n    // then becomes a point-in-time measure of how active the\n    // pool is.\n\n\n    return totalMeanRuntime / capacity;\n  }\n\n  get duration() {\n    return perf_hooks_1.performance.now() - __classPrivateFieldGet(this, _Piscina_pool, \"f\").start;\n  }\n\n  static get isWorkerThread() {\n    return common_1.commonState.isWorkerThread;\n  }\n\n  static get workerData() {\n    return common_1.commonState.workerData;\n  }\n\n  static get version() {\n    return package_json_1.version;\n  }\n\n  static get Piscina() {\n    return Piscina;\n  }\n\n  static move(val) {\n    if (val != null && typeof val === 'object' && typeof val !== 'function') {\n      if (!common_1.isTransferable(val)) {\n        if (util_1.types.isArrayBufferView(val)) {\n          val = new ArrayBufferViewTransferable(val);\n        } else {\n          val = new DirectlyTransferable(val);\n        }\n      }\n\n      common_1.markMovable(val);\n    }\n\n    return val;\n  }\n\n  static get transferableSymbol() {\n    return common_1.kTransferable;\n  }\n\n  static get valueSymbol() {\n    return common_1.kValue;\n  }\n\n  static get queueOptionsSymbol() {\n    return common_1.kQueueOptions;\n  }\n\n}\n\n_Piscina_pool = new WeakMap();\nmodule.exports = Piscina;","map":{"version":3,"names":["__classPrivateFieldSet","receiver","state","value","kind","f","TypeError","has","call","set","__classPrivateFieldGet","get","__importDefault","mod","__esModule","_DirectlyTransferable_value","_ArrayBufferViewTransferable_view","_Piscina_pool","worker_threads_1","require","events_1","eventemitter_asyncresource_1","async_hooks_1","os_1","url_1","path_1","util_1","assert_1","hdr_histogram_js_1","perf_hooks_1","hdr_histogram_percentiles_obj_1","common_1","package_json_1","cpuCount","cpus","length","onabort","abortSignal","listener","addEventListener","once","AbortError","Error","constructor","name","ArrayTaskQueue","tasks","size","shift","push","task","remove","index","indexOf","default","notStrictEqual","splice","kDefaultOptions","filename","minThreads","Math","max","maxThreads","idleTimeout","maxQueue","Infinity","concurrentTasksPerWorker","useAtomics","taskQueue","niceIncrement","trackUnmanagedFds","kDefaultRunOptions","transferList","undefined","signal","DirectlyTransferable","WeakMap","kTransferable","kValue","ArrayBufferViewTransferable","view","buffer","taskIdCounter","maybeFileURLToPath","startsWith","fileURLToPath","URL","TaskInfo","AsyncResource","callback","triggerAsyncId","requireManualDestroy","abortListener","workerInfo","isMovable","concat","taskId","created","performance","now","started","releaseTask","ret","done","err","result","runInAsyncScope","emitDestroy","removeEventListener","off","kQueueOptions","AsynchronouslyCreatedResource","onreadyListeners","markAsReady","listeners","isReady","onReady","fn","AsynchronouslyCreatedResourcePool","maximumUsage","pendingItems","Set","readyItems","onAvailableListeners","add","item","delete","maybeAvailable","findAvailable","minUsage","candidate","usage","currentUsage","Symbol","iterator","onAvailable","Errors","ThreadTermination","FilenameNotProvided","TaskQueueAtLimit","NoTaskQueueAvailable","WorkerInfo","worker","port","onMessage","lastSeenResponseCount","on","message","_handleResponse","taskInfos","Map","sharedBuffer","Int32Array","SharedArrayBuffer","kFieldCount","BYTES_PER_ELEMENT","destroy","terminate","close","clearIdleTimeout","taskInfo","values","clear","clearTimeout","ref","unref","postTask","postMessage","Atomics","kRequestCountField","notify","processPendingMessages","actualResponseCount","load","kResponseCountField","entry","receiveMessageOnPort","isRunningAbortableTask","ThreadPool","publicInterface","options","_a","skipQueue","completed","start","inProcessPendingMessages","startingUp","workerFailsDuringBootstrap","runTime","build","lowestDiscernibleValue","waitTime","workers","w","_onWorkerAvailable","_ensureMinimumWorkers","_addNewWorker","pool","Worker","resolve","__dirname","env","argv","execArgv","resourceLimits","workerData","port1","port2","MessageChannel","inspect","emit","error","_processPendingMessages","ready","_removeWorker","recordValue","_maybeDrain","setTimeout","strictEqual","runTask","Promise","reject","res","rej","asyncResource","asyncId","aborted","totalCapacity","pendingCapacity","waitingForNewWorker","exitEvents","all","Piscina","RangeError","isTaskQueue","Array","isArray","run","threads","queueSize","histAsObj","addPercentiles","utilization","capacity","duration","totalMeanRuntime","mean","totalCount","isWorkerThread","commonState","version","move","val","isTransferable","types","isArrayBufferView","markMovable","transferableSymbol","valueSymbol","queueOptionsSymbol","module","exports"],"sources":["/Users/deliabarbuta/Documents/An4Sem1/PAW/Proiect/proiect-paw-tadam/Frontend_OceanCross/node_modules/piscina/dist/src/index.js"],"sourcesContent":["\"use strict\";\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nvar _DirectlyTransferable_value, _ArrayBufferViewTransferable_view, _Piscina_pool;\nconst worker_threads_1 = require(\"worker_threads\");\nconst events_1 = require(\"events\");\nconst eventemitter_asyncresource_1 = __importDefault(require(\"eventemitter-asyncresource\"));\nconst async_hooks_1 = require(\"async_hooks\");\nconst os_1 = require(\"os\");\nconst url_1 = require(\"url\");\nconst path_1 = require(\"path\");\nconst util_1 = require(\"util\");\nconst assert_1 = __importDefault(require(\"assert\"));\nconst hdr_histogram_js_1 = require(\"hdr-histogram-js\");\nconst perf_hooks_1 = require(\"perf_hooks\");\nconst hdr_histogram_percentiles_obj_1 = __importDefault(require(\"hdr-histogram-percentiles-obj\"));\nconst common_1 = require(\"./common\");\nconst package_json_1 = require(\"../package.json\");\nconst cpuCount = (() => {\n    try {\n        return os_1.cpus().length;\n    }\n    catch {\n        /* istanbul ignore next */\n        return 1;\n    }\n})();\n;\nfunction onabort(abortSignal, listener) {\n    if ('addEventListener' in abortSignal) {\n        abortSignal.addEventListener('abort', listener, { once: true });\n    }\n    else {\n        abortSignal.once('abort', listener);\n    }\n}\nclass AbortError extends Error {\n    constructor() {\n        super('The task has been aborted');\n    }\n    get name() { return 'AbortError'; }\n}\nclass ArrayTaskQueue {\n    constructor() {\n        this.tasks = [];\n    }\n    get size() { return this.tasks.length; }\n    shift() {\n        return this.tasks.shift();\n    }\n    push(task) {\n        this.tasks.push(task);\n    }\n    remove(task) {\n        const index = this.tasks.indexOf(task);\n        assert_1.default.notStrictEqual(index, -1);\n        this.tasks.splice(index, 1);\n    }\n}\nconst kDefaultOptions = {\n    filename: null,\n    name: 'default',\n    minThreads: Math.max(cpuCount / 2, 1),\n    maxThreads: cpuCount * 1.5,\n    idleTimeout: 0,\n    maxQueue: Infinity,\n    concurrentTasksPerWorker: 1,\n    useAtomics: true,\n    taskQueue: new ArrayTaskQueue(),\n    niceIncrement: 0,\n    trackUnmanagedFds: true\n};\nconst kDefaultRunOptions = {\n    transferList: undefined,\n    filename: null,\n    signal: null,\n    name: null\n};\nclass DirectlyTransferable {\n    constructor(value) {\n        _DirectlyTransferable_value.set(this, void 0);\n        __classPrivateFieldSet(this, _DirectlyTransferable_value, value, \"f\");\n    }\n    get [(_DirectlyTransferable_value = new WeakMap(), common_1.kTransferable)]() { return __classPrivateFieldGet(this, _DirectlyTransferable_value, \"f\"); }\n    get [common_1.kValue]() { return __classPrivateFieldGet(this, _DirectlyTransferable_value, \"f\"); }\n}\nclass ArrayBufferViewTransferable {\n    constructor(view) {\n        _ArrayBufferViewTransferable_view.set(this, void 0);\n        __classPrivateFieldSet(this, _ArrayBufferViewTransferable_view, view, \"f\");\n    }\n    get [(_ArrayBufferViewTransferable_view = new WeakMap(), common_1.kTransferable)]() { return __classPrivateFieldGet(this, _ArrayBufferViewTransferable_view, \"f\").buffer; }\n    get [common_1.kValue]() { return __classPrivateFieldGet(this, _ArrayBufferViewTransferable_view, \"f\"); }\n}\nlet taskIdCounter = 0;\nfunction maybeFileURLToPath(filename) {\n    return filename.startsWith('file:')\n        ? url_1.fileURLToPath(new url_1.URL(filename))\n        : filename;\n}\n// Extend AsyncResource so that async relations between posting a task and\n// receiving its result are visible to diagnostic tools.\nclass TaskInfo extends async_hooks_1.AsyncResource {\n    constructor(task, transferList, filename, name, callback, abortSignal, triggerAsyncId) {\n        super('Piscina.Task', { requireManualDestroy: true, triggerAsyncId });\n        this.abortListener = null;\n        this.workerInfo = null;\n        this.callback = callback;\n        this.task = task;\n        this.transferList = transferList;\n        // If the task is a Transferable returned by\n        // Piscina.move(), then add it to the transferList\n        // automatically\n        if (common_1.isMovable(task)) {\n            // This condition should never be hit but typescript\n            // complains if we dont do the check.\n            /* istanbul ignore if */\n            if (this.transferList == null) {\n                this.transferList = [];\n            }\n            this.transferList =\n                this.transferList.concat(task[common_1.kTransferable]);\n            this.task = task[common_1.kValue];\n        }\n        this.filename = filename;\n        this.name = name;\n        this.taskId = taskIdCounter++;\n        this.abortSignal = abortSignal;\n        this.created = perf_hooks_1.performance.now();\n        this.started = 0;\n    }\n    releaseTask() {\n        const ret = this.task;\n        this.task = null;\n        return ret;\n    }\n    done(err, result) {\n        this.runInAsyncScope(this.callback, null, err, result);\n        this.emitDestroy(); // `TaskInfo`s are used only once.\n        // If an abort signal was used, remove the listener from it when\n        // done to make sure we do not accidentally leak.\n        if (this.abortSignal && this.abortListener) {\n            if ('removeEventListener' in this.abortSignal && this.abortListener) {\n                this.abortSignal.removeEventListener('abort', this.abortListener);\n            }\n            else {\n                this.abortSignal.off('abort', this.abortListener);\n            }\n        }\n    }\n    get [common_1.kQueueOptions]() {\n        return common_1.kQueueOptions in this.task ? this.task[common_1.kQueueOptions] : null;\n    }\n}\nclass AsynchronouslyCreatedResource {\n    constructor() {\n        this.onreadyListeners = [];\n    }\n    markAsReady() {\n        const listeners = this.onreadyListeners;\n        assert_1.default(listeners !== null);\n        this.onreadyListeners = null;\n        for (const listener of listeners) {\n            listener();\n        }\n    }\n    isReady() {\n        return this.onreadyListeners === null;\n    }\n    onReady(fn) {\n        if (this.onreadyListeners === null) {\n            fn(); // Zalgo is okay here.\n            return;\n        }\n        this.onreadyListeners.push(fn);\n    }\n}\nclass AsynchronouslyCreatedResourcePool {\n    constructor(maximumUsage) {\n        this.pendingItems = new Set();\n        this.readyItems = new Set();\n        this.maximumUsage = maximumUsage;\n        this.onAvailableListeners = [];\n    }\n    add(item) {\n        this.pendingItems.add(item);\n        item.onReady(() => {\n            /* istanbul ignore else */\n            if (this.pendingItems.has(item)) {\n                this.pendingItems.delete(item);\n                this.readyItems.add(item);\n                this.maybeAvailable(item);\n            }\n        });\n    }\n    delete(item) {\n        this.pendingItems.delete(item);\n        this.readyItems.delete(item);\n    }\n    findAvailable() {\n        let minUsage = this.maximumUsage;\n        let candidate = null;\n        for (const item of this.readyItems) {\n            const usage = item.currentUsage();\n            if (usage === 0)\n                return item;\n            if (usage < minUsage) {\n                candidate = item;\n                minUsage = usage;\n            }\n        }\n        return candidate;\n    }\n    *[Symbol.iterator]() {\n        yield* this.pendingItems;\n        yield* this.readyItems;\n    }\n    get size() {\n        return this.pendingItems.size + this.readyItems.size;\n    }\n    maybeAvailable(item) {\n        /* istanbul ignore else */\n        if (item.currentUsage() < this.maximumUsage) {\n            for (const listener of this.onAvailableListeners) {\n                listener(item);\n            }\n        }\n    }\n    onAvailable(fn) {\n        this.onAvailableListeners.push(fn);\n    }\n}\nconst Errors = {\n    ThreadTermination: () => new Error('Terminating worker thread'),\n    FilenameNotProvided: () => new Error('filename must be provided to run() or in options object'),\n    TaskQueueAtLimit: () => new Error('Task queue is at limit'),\n    NoTaskQueueAvailable: () => new Error('No task queue available and all Workers are busy')\n};\nclass WorkerInfo extends AsynchronouslyCreatedResource {\n    constructor(worker, port, onMessage) {\n        super();\n        this.idleTimeout = null; // eslint-disable-line no-undef\n        this.lastSeenResponseCount = 0;\n        this.worker = worker;\n        this.port = port;\n        this.port.on('message', (message) => this._handleResponse(message));\n        this.onMessage = onMessage;\n        this.taskInfos = new Map();\n        this.sharedBuffer = new Int32Array(new SharedArrayBuffer(common_1.kFieldCount * Int32Array.BYTES_PER_ELEMENT));\n    }\n    destroy() {\n        this.worker.terminate();\n        this.port.close();\n        this.clearIdleTimeout();\n        for (const taskInfo of this.taskInfos.values()) {\n            taskInfo.done(Errors.ThreadTermination());\n        }\n        this.taskInfos.clear();\n    }\n    clearIdleTimeout() {\n        if (this.idleTimeout !== null) {\n            clearTimeout(this.idleTimeout);\n            this.idleTimeout = null;\n        }\n    }\n    ref() {\n        this.port.ref();\n        return this;\n    }\n    unref() {\n        // Note: Do not call ref()/unref() on the Worker itself since that may cause\n        // a hard crash, see https://github.com/nodejs/node/pull/33394.\n        this.port.unref();\n        return this;\n    }\n    _handleResponse(message) {\n        this.onMessage(message);\n        if (this.taskInfos.size === 0) {\n            // No more tasks running on this Worker means it should not keep the\n            // process running.\n            this.unref();\n        }\n    }\n    postTask(taskInfo) {\n        assert_1.default(!this.taskInfos.has(taskInfo.taskId));\n        const message = {\n            task: taskInfo.releaseTask(),\n            taskId: taskInfo.taskId,\n            filename: taskInfo.filename,\n            name: taskInfo.name\n        };\n        try {\n            this.port.postMessage(message, taskInfo.transferList);\n        }\n        catch (err) {\n            // This would mostly happen if e.g. message contains unserializable data\n            // or transferList is invalid.\n            taskInfo.done(err);\n            return;\n        }\n        taskInfo.workerInfo = this;\n        this.taskInfos.set(taskInfo.taskId, taskInfo);\n        this.ref();\n        this.clearIdleTimeout();\n        // Inform the worker that there are new messages posted, and wake it up\n        // if it is waiting for one.\n        Atomics.add(this.sharedBuffer, common_1.kRequestCountField, 1);\n        Atomics.notify(this.sharedBuffer, common_1.kRequestCountField, 1);\n    }\n    processPendingMessages() {\n        // If we *know* that there are more messages than we have received using\n        // 'message' events yet, then try to load and handle them synchronously,\n        // without the need to wait for more expensive events on the event loop.\n        // This would usually break async tracking, but in our case, we already have\n        // the extra TaskInfo/AsyncResource layer that rectifies that situation.\n        const actualResponseCount = Atomics.load(this.sharedBuffer, common_1.kResponseCountField);\n        if (actualResponseCount !== this.lastSeenResponseCount) {\n            this.lastSeenResponseCount = actualResponseCount;\n            let entry;\n            while ((entry = worker_threads_1.receiveMessageOnPort(this.port)) !== undefined) {\n                this._handleResponse(entry.message);\n            }\n        }\n    }\n    isRunningAbortableTask() {\n        // If there are abortable tasks, we are running one at most per Worker.\n        if (this.taskInfos.size !== 1)\n            return false;\n        const [[, task]] = this.taskInfos;\n        return task.abortSignal !== null;\n    }\n    currentUsage() {\n        if (this.isRunningAbortableTask())\n            return Infinity;\n        return this.taskInfos.size;\n    }\n}\nclass ThreadPool {\n    constructor(publicInterface, options) {\n        var _a;\n        this.skipQueue = [];\n        this.completed = 0;\n        this.start = perf_hooks_1.performance.now();\n        this.inProcessPendingMessages = false;\n        this.startingUp = false;\n        this.workerFailsDuringBootstrap = false;\n        this.publicInterface = publicInterface;\n        this.taskQueue = options.taskQueue || new ArrayTaskQueue();\n        this.runTime = hdr_histogram_js_1.build({ lowestDiscernibleValue: 1 });\n        this.waitTime = hdr_histogram_js_1.build({ lowestDiscernibleValue: 1 });\n        const filename = options.filename ? maybeFileURLToPath(options.filename) : null;\n        this.options = { ...kDefaultOptions, ...options, filename, maxQueue: 0 };\n        // The >= and <= could be > and < but this way we get 100 % coverage 🙃\n        if (options.maxThreads !== undefined &&\n            this.options.minThreads >= options.maxThreads) {\n            this.options.minThreads = options.maxThreads;\n        }\n        if (options.minThreads !== undefined &&\n            this.options.maxThreads <= options.minThreads) {\n            this.options.maxThreads = options.minThreads;\n        }\n        if (options.maxQueue === 'auto') {\n            this.options.maxQueue = this.options.maxThreads ** 2;\n        }\n        else {\n            this.options.maxQueue = (_a = options.maxQueue) !== null && _a !== void 0 ? _a : kDefaultOptions.maxQueue;\n        }\n        this.workers = new AsynchronouslyCreatedResourcePool(this.options.concurrentTasksPerWorker);\n        this.workers.onAvailable((w) => this._onWorkerAvailable(w));\n        this.startingUp = true;\n        this._ensureMinimumWorkers();\n        this.startingUp = false;\n    }\n    _ensureMinimumWorkers() {\n        while (this.workers.size < this.options.minThreads) {\n            this._addNewWorker();\n        }\n    }\n    _addNewWorker() {\n        const pool = this;\n        const worker = new worker_threads_1.Worker(path_1.resolve(__dirname, 'worker.js'), {\n            env: this.options.env,\n            argv: this.options.argv,\n            execArgv: this.options.execArgv,\n            resourceLimits: this.options.resourceLimits,\n            workerData: this.options.workerData,\n            trackUnmanagedFds: this.options.trackUnmanagedFds\n        });\n        const { port1, port2 } = new worker_threads_1.MessageChannel();\n        const workerInfo = new WorkerInfo(worker, port1, onMessage);\n        if (this.startingUp) {\n            // There is no point in waiting for the initial set of Workers to indicate\n            // that they are ready, we just mark them as such from the start.\n            workerInfo.markAsReady();\n        }\n        const message = {\n            filename: this.options.filename,\n            name: this.options.name,\n            port: port2,\n            sharedBuffer: workerInfo.sharedBuffer,\n            useAtomics: this.options.useAtomics,\n            niceIncrement: this.options.niceIncrement\n        };\n        worker.postMessage(message, [port2]);\n        function onMessage(message) {\n            const { taskId, result } = message;\n            // In case of success: Call the callback that was passed to `runTask`,\n            // remove the `TaskInfo` associated with the Worker, which marks it as\n            // free again.\n            const taskInfo = workerInfo.taskInfos.get(taskId);\n            workerInfo.taskInfos.delete(taskId);\n            pool.workers.maybeAvailable(workerInfo);\n            /* istanbul ignore if */\n            if (taskInfo === undefined) {\n                const err = new Error(`Unexpected message from Worker: ${util_1.inspect(message)}`);\n                pool.publicInterface.emit('error', err);\n            }\n            else {\n                taskInfo.done(message.error, result);\n            }\n            pool._processPendingMessages();\n        }\n        worker.on('message', (message) => {\n            if (message.ready === true) {\n                if (workerInfo.currentUsage() === 0) {\n                    workerInfo.unref();\n                }\n                if (!workerInfo.isReady()) {\n                    workerInfo.markAsReady();\n                }\n                return;\n            }\n            worker.emit('error', new Error(`Unexpected message on Worker: ${util_1.inspect(message)}`));\n        });\n        worker.on('error', (err) => {\n            // Work around the bug in https://github.com/nodejs/node/pull/33394\n            worker.ref = () => { };\n            // In case of an uncaught exception: Call the callback that was passed to\n            // `postTask` with the error, or emit an 'error' event if there is none.\n            const taskInfos = [...workerInfo.taskInfos.values()];\n            workerInfo.taskInfos.clear();\n            // Remove the worker from the list and potentially start a new Worker to\n            // replace the current one.\n            this._removeWorker(workerInfo);\n            if (workerInfo.isReady() && !this.workerFailsDuringBootstrap) {\n                this._ensureMinimumWorkers();\n            }\n            else {\n                // Do not start new workers over and over if they already fail during\n                // bootstrap, there's no point.\n                this.workerFailsDuringBootstrap = true;\n            }\n            if (taskInfos.length > 0) {\n                for (const taskInfo of taskInfos) {\n                    taskInfo.done(err, null);\n                }\n            }\n            else {\n                this.publicInterface.emit('error', err);\n            }\n        });\n        worker.unref();\n        port1.on('close', () => {\n            // The port is only closed if the Worker stops for some reason, but we\n            // always .unref() the Worker itself. We want to receive e.g. 'error'\n            // events on it, so we ref it once we know it's going to exit anyway.\n            worker.ref();\n        });\n        this.workers.add(workerInfo);\n    }\n    _processPendingMessages() {\n        if (this.inProcessPendingMessages || !this.options.useAtomics) {\n            return;\n        }\n        this.inProcessPendingMessages = true;\n        try {\n            for (const workerInfo of this.workers) {\n                workerInfo.processPendingMessages();\n            }\n        }\n        finally {\n            this.inProcessPendingMessages = false;\n        }\n    }\n    _removeWorker(workerInfo) {\n        workerInfo.destroy();\n        this.workers.delete(workerInfo);\n    }\n    _onWorkerAvailable(workerInfo) {\n        while ((this.taskQueue.size > 0 || this.skipQueue.length > 0) &&\n            workerInfo.currentUsage() < this.options.concurrentTasksPerWorker) {\n            // The skipQueue will have tasks that we previously shifted off\n            // the task queue but had to skip over... we have to make sure\n            // we drain that before we drain the taskQueue.\n            const taskInfo = this.skipQueue.shift() ||\n                this.taskQueue.shift();\n            // If the task has an abortSignal and the worker has any other\n            // tasks, we cannot distribute the task to it. Skip for now.\n            if (taskInfo.abortSignal && workerInfo.taskInfos.size > 0) {\n                this.skipQueue.push(taskInfo);\n                break;\n            }\n            const now = perf_hooks_1.performance.now();\n            this.waitTime.recordValue(now - taskInfo.created);\n            taskInfo.started = now;\n            workerInfo.postTask(taskInfo);\n            this._maybeDrain();\n            return;\n        }\n        if (workerInfo.taskInfos.size === 0 &&\n            this.workers.size > this.options.minThreads) {\n            workerInfo.idleTimeout = setTimeout(() => {\n                assert_1.default.strictEqual(workerInfo.taskInfos.size, 0);\n                if (this.workers.size > this.options.minThreads) {\n                    this._removeWorker(workerInfo);\n                }\n            }, this.options.idleTimeout).unref();\n        }\n    }\n    runTask(task, options) {\n        let { filename, name } = options;\n        const { transferList = [], signal = null } = options;\n        if (filename == null) {\n            filename = this.options.filename;\n        }\n        if (name == null) {\n            name = this.options.name;\n        }\n        if (typeof filename !== 'string') {\n            return Promise.reject(Errors.FilenameNotProvided());\n        }\n        filename = maybeFileURLToPath(filename);\n        let resolve;\n        let reject;\n        // eslint-disable-next-line\n        const ret = new Promise((res, rej) => { resolve = res; reject = rej; });\n        const taskInfo = new TaskInfo(task, transferList, filename, name, (err, result) => {\n            this.completed++;\n            if (taskInfo.started) {\n                this.runTime.recordValue(perf_hooks_1.performance.now() - taskInfo.started);\n            }\n            if (err !== null) {\n                reject(err);\n            }\n            else {\n                resolve(result);\n            }\n        }, signal, this.publicInterface.asyncResource.asyncId());\n        if (signal !== null) {\n            // If the AbortSignal has an aborted property and it's truthy,\n            // reject immediately.\n            if (signal.aborted) {\n                return Promise.reject(new AbortError());\n            }\n            taskInfo.abortListener = () => {\n                // Call reject() first to make sure we always reject with the AbortError\n                // if the task is aborted, not with an Error from the possible\n                // thread termination below.\n                reject(new AbortError());\n                if (taskInfo.workerInfo !== null) {\n                    // Already running: We cancel the Worker this is running on.\n                    this._removeWorker(taskInfo.workerInfo);\n                    this._ensureMinimumWorkers();\n                }\n                else {\n                    // Not yet running: Remove it from the queue.\n                    this.taskQueue.remove(taskInfo);\n                }\n            };\n            onabort(signal, taskInfo.abortListener);\n        }\n        // If there is a task queue, there's no point in looking for an available\n        // Worker thread. Add this task to the queue, if possible.\n        if (this.taskQueue.size > 0) {\n            const totalCapacity = this.options.maxQueue + this.pendingCapacity();\n            if (this.taskQueue.size >= totalCapacity) {\n                if (this.options.maxQueue === 0) {\n                    return Promise.reject(Errors.NoTaskQueueAvailable());\n                }\n                else {\n                    return Promise.reject(Errors.TaskQueueAtLimit());\n                }\n            }\n            else {\n                if (this.workers.size < this.options.maxThreads) {\n                    this._addNewWorker();\n                }\n                this.taskQueue.push(taskInfo);\n            }\n            return ret;\n        }\n        // Look for a Worker with a minimum number of tasks it is currently running.\n        let workerInfo = this.workers.findAvailable();\n        // If we want the ability to abort this task, use only workers that have\n        // no running tasks.\n        if (workerInfo !== null && workerInfo.currentUsage() > 0 && signal) {\n            workerInfo = null;\n        }\n        // If no Worker was found, or that Worker was handling another task in some\n        // way, and we still have the ability to spawn new threads, do so.\n        let waitingForNewWorker = false;\n        if ((workerInfo === null || workerInfo.currentUsage() > 0) &&\n            this.workers.size < this.options.maxThreads) {\n            this._addNewWorker();\n            waitingForNewWorker = true;\n        }\n        // If no Worker is found, try to put the task into the queue.\n        if (workerInfo === null) {\n            if (this.options.maxQueue <= 0 && !waitingForNewWorker) {\n                return Promise.reject(Errors.NoTaskQueueAvailable());\n            }\n            else {\n                this.taskQueue.push(taskInfo);\n            }\n            return ret;\n        }\n        // TODO(addaleax): Clean up the waitTime/runTime recording.\n        const now = perf_hooks_1.performance.now();\n        this.waitTime.recordValue(now - taskInfo.created);\n        taskInfo.started = now;\n        workerInfo.postTask(taskInfo);\n        this._maybeDrain();\n        return ret;\n    }\n    pendingCapacity() {\n        return this.workers.pendingItems.size *\n            this.options.concurrentTasksPerWorker;\n    }\n    _maybeDrain() {\n        if (this.taskQueue.size === 0 && this.skipQueue.length === 0) {\n            this.publicInterface.emit('drain');\n        }\n    }\n    async destroy() {\n        while (this.skipQueue.length > 0) {\n            const taskInfo = this.skipQueue.shift();\n            taskInfo.done(new Error('Terminating worker thread'));\n        }\n        while (this.taskQueue.size > 0) {\n            const taskInfo = this.taskQueue.shift();\n            taskInfo.done(new Error('Terminating worker thread'));\n        }\n        const exitEvents = [];\n        while (this.workers.size > 0) {\n            const [workerInfo] = this.workers;\n            exitEvents.push(events_1.once(workerInfo.worker, 'exit'));\n            this._removeWorker(workerInfo);\n        }\n        await Promise.all(exitEvents);\n    }\n}\nclass Piscina extends eventemitter_asyncresource_1.default {\n    constructor(options = {}) {\n        super({ ...options, name: 'Piscina' });\n        _Piscina_pool.set(this, void 0);\n        if (typeof options.filename !== 'string' && options.filename != null) {\n            throw new TypeError('options.filename must be a string or null');\n        }\n        if (typeof options.name !== 'string' && options.name != null) {\n            throw new TypeError('options.name must be a string or null');\n        }\n        if (options.minThreads !== undefined &&\n            (typeof options.minThreads !== 'number' || options.minThreads < 0)) {\n            throw new TypeError('options.minThreads must be a non-negative integer');\n        }\n        if (options.maxThreads !== undefined &&\n            (typeof options.maxThreads !== 'number' || options.maxThreads < 1)) {\n            throw new TypeError('options.maxThreads must be a positive integer');\n        }\n        if (options.minThreads !== undefined && options.maxThreads !== undefined &&\n            options.minThreads > options.maxThreads) {\n            throw new RangeError('options.minThreads and options.maxThreads must not conflict');\n        }\n        if (options.idleTimeout !== undefined &&\n            (typeof options.idleTimeout !== 'number' || options.idleTimeout < 0)) {\n            throw new TypeError('options.idleTimeout must be a non-negative integer');\n        }\n        if (options.maxQueue !== undefined &&\n            options.maxQueue !== 'auto' &&\n            (typeof options.maxQueue !== 'number' || options.maxQueue < 0)) {\n            throw new TypeError('options.maxQueue must be a non-negative integer');\n        }\n        if (options.concurrentTasksPerWorker !== undefined &&\n            (typeof options.concurrentTasksPerWorker !== 'number' ||\n                options.concurrentTasksPerWorker < 1)) {\n            throw new TypeError('options.concurrentTasksPerWorker must be a positive integer');\n        }\n        if (options.useAtomics !== undefined &&\n            typeof options.useAtomics !== 'boolean') {\n            throw new TypeError('options.useAtomics must be a boolean value');\n        }\n        if (options.resourceLimits !== undefined &&\n            (typeof options.resourceLimits !== 'object' ||\n                options.resourceLimits === null)) {\n            throw new TypeError('options.resourceLimits must be an object');\n        }\n        if (options.taskQueue !== undefined && !common_1.isTaskQueue(options.taskQueue)) {\n            throw new TypeError('options.taskQueue must be a TaskQueue object');\n        }\n        if (options.niceIncrement !== undefined &&\n            (typeof options.niceIncrement !== 'number' || options.niceIncrement < 0)) {\n            throw new TypeError('options.niceIncrement must be a non-negative integer');\n        }\n        if (options.trackUnmanagedFds !== undefined &&\n            typeof options.trackUnmanagedFds !== 'boolean') {\n            throw new TypeError('options.trackUnmanagedFds must be a boolean value');\n        }\n        __classPrivateFieldSet(this, _Piscina_pool, new ThreadPool(this, options), \"f\");\n    }\n    /** @deprecated Use run(task, options) instead **/\n    runTask(task, transferList, filename, signal) {\n        // If transferList is a string or AbortSignal, shift it.\n        if ((typeof transferList === 'object' && !Array.isArray(transferList)) ||\n            typeof transferList === 'string') {\n            signal = filename;\n            filename = transferList;\n            transferList = undefined;\n        }\n        // If filename is an AbortSignal, shift it.\n        if (typeof filename === 'object' && !Array.isArray(filename)) {\n            signal = filename;\n            filename = undefined;\n        }\n        if (transferList !== undefined && !Array.isArray(transferList)) {\n            return Promise.reject(new TypeError('transferList argument must be an Array'));\n        }\n        if (filename !== undefined && typeof filename !== 'string') {\n            return Promise.reject(new TypeError('filename argument must be a string'));\n        }\n        if (signal !== undefined && typeof signal !== 'object') {\n            return Promise.reject(new TypeError('signal argument must be an object'));\n        }\n        return __classPrivateFieldGet(this, _Piscina_pool, \"f\").runTask(task, {\n            transferList,\n            filename: filename || null,\n            name: 'default',\n            signal: signal || null\n        });\n    }\n    run(task, options = kDefaultRunOptions) {\n        if (options === null || typeof options !== 'object') {\n            return Promise.reject(new TypeError('options must be an object'));\n        }\n        const { transferList, filename, name, signal } = options;\n        if (transferList !== undefined && !Array.isArray(transferList)) {\n            return Promise.reject(new TypeError('transferList argument must be an Array'));\n        }\n        if (filename != null && typeof filename !== 'string') {\n            return Promise.reject(new TypeError('filename argument must be a string'));\n        }\n        if (name != null && typeof name !== 'string') {\n            return Promise.reject(new TypeError('name argument must be a string'));\n        }\n        if (signal != null && typeof signal !== 'object') {\n            return Promise.reject(new TypeError('signal argument must be an object'));\n        }\n        return __classPrivateFieldGet(this, _Piscina_pool, \"f\").runTask(task, { transferList, filename, name, signal });\n    }\n    destroy() {\n        return __classPrivateFieldGet(this, _Piscina_pool, \"f\").destroy();\n    }\n    get options() {\n        return __classPrivateFieldGet(this, _Piscina_pool, \"f\").options;\n    }\n    get threads() {\n        const ret = [];\n        for (const workerInfo of __classPrivateFieldGet(this, _Piscina_pool, \"f\").workers) {\n            ret.push(workerInfo.worker);\n        }\n        return ret;\n    }\n    get queueSize() {\n        const pool = __classPrivateFieldGet(this, _Piscina_pool, \"f\");\n        return Math.max(pool.taskQueue.size - pool.pendingCapacity(), 0);\n    }\n    get completed() {\n        return __classPrivateFieldGet(this, _Piscina_pool, \"f\").completed;\n    }\n    get waitTime() {\n        const result = hdr_histogram_percentiles_obj_1.default.histAsObj(__classPrivateFieldGet(this, _Piscina_pool, \"f\").waitTime);\n        return hdr_histogram_percentiles_obj_1.default.addPercentiles(__classPrivateFieldGet(this, _Piscina_pool, \"f\").waitTime, result);\n    }\n    get runTime() {\n        const result = hdr_histogram_percentiles_obj_1.default.histAsObj(__classPrivateFieldGet(this, _Piscina_pool, \"f\").runTime);\n        return hdr_histogram_percentiles_obj_1.default.addPercentiles(__classPrivateFieldGet(this, _Piscina_pool, \"f\").runTime, result);\n    }\n    get utilization() {\n        // The capacity is the max compute time capacity of the\n        // pool to this point in time as determined by the length\n        // of time the pool has been running multiplied by the\n        // maximum number of threads.\n        const capacity = this.duration * __classPrivateFieldGet(this, _Piscina_pool, \"f\").options.maxThreads;\n        const totalMeanRuntime = __classPrivateFieldGet(this, _Piscina_pool, \"f\").runTime.mean *\n            __classPrivateFieldGet(this, _Piscina_pool, \"f\").runTime.totalCount;\n        // We calculate the appoximate pool utilization by multiplying\n        // the mean run time of all tasks by the number of runtime\n        // samples taken and dividing that by the capacity. The\n        // theory here is that capacity represents the absolute upper\n        // limit of compute time this pool could ever attain (but\n        // never will for a variety of reasons. Multiplying the\n        // mean run time by the number of tasks sampled yields an\n        // approximation of the realized compute time. The utilization\n        // then becomes a point-in-time measure of how active the\n        // pool is.\n        return totalMeanRuntime / capacity;\n    }\n    get duration() {\n        return perf_hooks_1.performance.now() - __classPrivateFieldGet(this, _Piscina_pool, \"f\").start;\n    }\n    static get isWorkerThread() {\n        return common_1.commonState.isWorkerThread;\n    }\n    static get workerData() {\n        return common_1.commonState.workerData;\n    }\n    static get version() {\n        return package_json_1.version;\n    }\n    static get Piscina() {\n        return Piscina;\n    }\n    static move(val) {\n        if (val != null && typeof val === 'object' && typeof val !== 'function') {\n            if (!common_1.isTransferable(val)) {\n                if (util_1.types.isArrayBufferView(val)) {\n                    val = new ArrayBufferViewTransferable(val);\n                }\n                else {\n                    val = new DirectlyTransferable(val);\n                }\n            }\n            common_1.markMovable(val);\n        }\n        return val;\n    }\n    static get transferableSymbol() { return common_1.kTransferable; }\n    static get valueSymbol() { return common_1.kValue; }\n    static get queueOptionsSymbol() { return common_1.kQueueOptions; }\n}\n_Piscina_pool = new WeakMap();\nmodule.exports = Piscina;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}